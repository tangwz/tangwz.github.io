<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>架构 on 多颗糖</title>
    <link>https://tangwz.com/tags/%E6%9E%B6%E6%9E%84/</link>
    <description>Recent content in 架构 on 多颗糖</description>
    <image>
      <url>https://tangwz.com/</url>
      <link>https://tangwz.com/</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://tangwz.com/tags/%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>软件架构基础 5 架构特性识别与实战: 订餐系统</title>
      <link>https://tangwz.com/post/fosa5/</link>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tangwz.com/post/fosa5/</guid>
      <description>架构师一般从三个方面来发现架构特性：
 领域关注(Domain Concerns) 需求 隐性领域知识  在《软件架构基础 4》中我们讨论了隐性领域知识，这里将介绍另外两种。
搬运下 wikipedia 对于领域(Domain)的解释：
 A domain is the targeted subject area of a computer program. It is a term used in software engineering. Formally it represents the target subject of a specific programming project, whether narrowly or broadly defined. For example, a particular programming project might have had as a goal the creation of a program for a particular hospital, and that hospital would be the domain.</description>
      <content:encoded><![CDATA[<p>架构师一般从三个方面来发现架构特性：</p>
<ul>
<li>领域关注(Domain Concerns)</li>
<li>需求</li>
<li>隐性领域知识</li>
</ul>
<p>在《软件架构基础 4》中我们讨论了隐性领域知识，这里将介绍另外两种。</p>
<p>搬运下 wikipedia 对于领域(Domain)的解释：</p>
<blockquote>
<p>A domain is the targeted subject area of a computer program. It is a term used in software engineering. Formally it represents the target subject of a specific programming project, whether narrowly or broadly defined. For example, a particular programming project might have had as a goal the creation of a program for a particular hospital, and that hospital would be the domain.</p>
</blockquote>
<p>简而言之，领域就是指程序的目标主题领域，假如为医院开发某个程序，那么医院就是领域。Domain 这个词常常出现在软件工程中，例如领域驱动架构(DDD)、领域模型（Domain model）。</p>
<h2 id="领域关注domain-concerns">领域关注(Domain Concerns)</h2>
<p>架构师必须能够将领域关注的问题转化为确定、正确的架构特性。例如，可扩展性是最重要的关注点，还是容错、安全或性能？也许系统需要所有四个特性的结合。</p>
<p>有一个小窍门，那就是<strong>努力让最终的清单尽可能的简短</strong>。架构中一个常见的反模式是试图设计一个通用架构，支持所有的架构特性。架构所支持的每一个架构特性都会使整个系统设计变得复杂，支持过多的架构特性会导致架构师和开发人员在还没有开始解决问题之前就变得越来越复杂。</p>
<p><strong>不要纠结于架构特性的数量，而是要保持设计简单的动机。</strong></p>
<p>一开始就考虑系统最终的架构特性列表是愚蠢的，这不仅浪费时间还会产生挫败感和分歧。<strong>更好的办法是选出最重要的三个特性（顺序不限）</strong>。</p>
<p>架构师谈论的是可扩展性、互操作性、容错性、可学习性和可用性，业务利益相关者谈论的是合并和收购、用户满意度、销售时间和竞争优势。两者之间可能互相不理解，下表提供一个领域关注到架构特性的转换。</p>
<table>
<thead>
<tr>
<th>领域关注</th>
<th>架构特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>兼并和收购</td>
<td>互操作性、可扩展性、适应性、可扩展性。</td>
</tr>
<tr>
<td>销售时间</td>
<td>敏捷性、可测试性、可部署性</td>
</tr>
<tr>
<td>用户满意度</td>
<td>性能、可用性、容错性、可测试性、可部署性、敏捷性、安全性。</td>
</tr>
<tr>
<td>竞争优势</td>
<td>敏捷性、可测试性、可部署性、可扩展性、可用性、容错性。</td>
</tr>
<tr>
<td>时间和预算</td>
<td>简单性、可行性。</td>
</tr>
</tbody>
</table>
<p>需要注意的一个重要问题是，<strong>敏捷性不等于销售时间。相反，销售时间是敏捷性+可测试性+可部署性。这是很多架构师在翻译领域关注点时陷入的陷阱——只关注其中一个点。</strong></p>
<p>例如，一个业务利益相关者可能会说：“由于监管要求，我们必须按时完成基金的日终计价”。一个无效的架构师可能只会关注性能，因为这似乎是该领域关注的主要焦点。然而，该架构师会因为很多原因而失败：</p>
<ul>
<li>首先，如果系统在需要的时候无法使用，那么系统的速度有多快都不重要；</li>
<li>第二，随着业务的发展和更多资金，系统必须也能扩展到及时完成日终处理；</li>
<li>第三，系统不仅要可用，而且要可靠，以便在计算日终基金价格时不会崩溃；</li>
<li>第四，如果日终基金定价完成了 85%，系统崩溃了怎么办？它必须能够恢复并继续计算。</li>
<li>最后，系统可能很快，但基金价格是否计算正确？</li>
</ul>
<p>所以，除了性能之外，架构师还必须同样关注可用性、可扩展性、可靠性、可恢复性和可审计性。</p>
<h2 id="从需求提取架构特">从需求提取架构特</h2>
<p>性</p>
<p>一些架构特征来自需求文档中的明确声明。例如，明确的预期用户数和规模。另一些则来自架构师的领域知识，这是领域知识对架构师总是有益的众多原因之一。</p>
<p>例如，假设一个架构师设计了一个为大学生处理班级注册的应用程序，为了便于计算，假设学校有 1000 名学生，注册时间为 10 小时。架构师在设计系统时，是否应该假设注册过程中的学生会随着时间推移均匀分布？或者，基于对大学生习惯和癖好的了解，架构师是否应该设计一个能够处理所有 1000 名学生在最后 10 分钟注册的系统？任何一个了解学生有多么拖延的人都知道这个问题的答案! 像这样的细节很少会出现在需求文档中，但它们确实为设计决策提供了信息。</p>
<h2 id="案例学习三明治店网上订餐系统">案例学习：三明治店网上订餐系统</h2>
<p><img loading="lazy" src="/media/images/20210125-fosa5/pizza.jpg" alt=""  />
</p>
<h3 id="描述">描述</h3>
<p>一家全国性的三明治店想实现网上订餐（除了目前的呼叫服务外）。</p>
<h3 id="用户">用户</h3>
<p>数千人，也许有一天会到数百万人。</p>
<h3 id="需求">需求</h3>
<ul>
<li>用户下单，然后会得到一个领取三明治的时间和到店的方向（必须与几个外部地图服务整合，包括交通信息）；</li>
<li>如果店家提供送餐服务，就派司机带着三明治给用户送去；</li>
<li>移动设备的可访问性；</li>
<li>提供全国性的每日促销/特价活动；</li>
<li>提供本地每日促销/特价活动；</li>
<li>接受在线、当面或货到付款；</li>
</ul>
<h3 id="其它需求">其它需求</h3>
<ul>
<li>三明治店都是加盟店，每个店都有不同的老板；</li>
<li>母公司近期有海外扩张计划；</li>
<li>企业的目标是雇佣廉价的劳动力，以实现利润最大化&quot;；</li>
</ul>
<p><strong>鉴于以上这种情况，架构师将如何推导出架构特征？</strong></p>
<p>需求的每一部分都可能有助于架构的一个或多个方面，架构师在这里并不设计整个系统，相反，架构师要寻找影响或冲击设计的东西，特别是结构性的。</p>
<p>首先，将候选架构特性分为显性和隐性特性。</p>
<h3 id="显性架构特性">显性架构特性</h3>
<p>明确的架构特性作为必要的一部分出现在需求规范中，例如，一个购物网站可能支持的并发用户数量，需求中明确了这一点。架构师应该考虑需求的每个部分，看看它是否有助于架构特性。但首先，架构师应该考虑领域级的关于预期指标的估计。</p>
<p>首先应该引起架构师注意的细节之一是用户数量：目前是数千人，也许有一天会到数百万人（这是一家雄心勃勃的三明治商店！）。因此，可扩展性&ndash;处理大量并发用户而不严重降低性能的能力&ndash;是架构的首要特性之一。请注意，需求陈述并没有明确要求可扩展性，而是将该要求表述为预期的用户数。架构师必须经常将业务语言解码成工程等价物。</p>
<p>然而，我们可能还需要弹性&ndash;处理突发请求的能力。这两个特性经常出现在一起，但它们有不同的限制。</p>
<p>可扩展性看起来像下图所示的图形：</p>
<p><img loading="lazy" src="/media/images/20210125-fosa5/scalability.jpg" alt=""  />
</p>
<p>弹性则是流量的爆发，如下图所示：</p>
<p><img loading="lazy" src="/media/images/20210125-fosa5/flexible.jpg" alt=""  />
</p>
<p>有些系统是可扩展的，但不是弹性的。例如，考虑一个酒店预订系统，如果没有特殊的销售或活动，并发用户数量可能是一致的。相反，考虑一个音乐会门票预订系统，随着新票的发售，狂热的粉丝会涌入网站，这就需要高度的弹性。<strong>通常情况下，弹性系统需要可扩展性：处理突发事件和大量并发用户的能力。</strong></p>
<p>弹性的要求并没有出现在需求中，然而架构师应该将其确定为一个重要的考虑因素。一个三明治店的流量是全天一致的吗？还是在用餐时间前后会有爆棚的客流？几乎可以肯定是后者。因此，一个好的架构师应该识别这种潜在的架构特征。</p>
<p>架构师应该依次考虑这些业务需求中的每一个，看看是否存在架构特征。</p>
<ol>
<li><em>用户下单，然后得到一个领取三明治的时间和去商店的方向（必须提供与外部地图服务整合的选项，包括交通信息）</em>。外部地图服务意味着集成，这可能会影响可靠性等方面。例如，如果开发人员构建了一个依赖于第三方系统的系统，然而调用它却失败了，这就会影响调用系统的可靠性。但是，架构师也要警惕架构特性的过度规范，如果外部流量服务出现故障怎么办？三明治网站是否应该失败，或者只是在没有流量信息的情况下提供稍低的效率？</li>
<li>*如果店家提供送餐服务，就派司机带着三明治给用户送去。*看起来不需要特殊的架构特性来支持这个需求。</li>
<li>*移动设备的可访问性。*这一要求将主要影响到应用程序的设计，要做一个 portable web application 或是几个 native web applications。考虑到预算限制和应用程序的简单性，一个移动端优化的 web 应用更好。因此，架构师还要考虑为页面加载时间和移动端的性能架构特性。注意，架构师在这样的情况下不应该单独行动，而是应该与用户体验设计师、业务利益相关者和其他相关方合作，审核这样的决策。</li>
<li><em>提供全国性的每日促销/特价。</em></li>
<li>*提供本地每日促销/特价活动。*这两个要求都规定了促销和特价商品的可定制性。注意，需求 1 还意味着基于地址的可定制信息，基于这三个需求，架构师可以考虑将可定制性作为一种架构特性。例如，微内核架构这样的架构风格，通过定义一个插件架构，可以极好地支持自定义行为。传统的设计也可以通过设计模式（如模板）来满足这种需求。需要架构师权衡取舍。</li>
<li>*接受在线、当面或货到付款。<em>网上支付意味着安全性，但这一要求没有任何内容表明安全程度特别高。
7.</em> 三明治店都是加盟店，每个店都有不同的老板。*这个要求可能会对架构造成成本限制&ndash;架构师应该检查可行性（应用成本、时间和员工技能培训等约束条件），看看是否需要一个简单性或牺牲性的架构。</li>
<li>*母公司近期有向海外扩张的计划。*这个要求意味着国际化，也就是 i18n。许多技术可以处理这一要求，应该不需要特殊的结构来适应。</li>
<li>*企业的目标是雇佣廉价的劳动力以实现利润最大化。*这个要求表明可用性将是重要的，但同样是更关注设计而不是架构特点。</li>
</ol>
<p>还有一个架构特征是性能：没有人愿意从一个性能差的三明治店购买，尤其是在高峰期。然而，性能是一个有着不同差别的概念&ndash;架构师应该为什么样的性能而设计？我们将在后续章节中介绍性能的各种细微差别。</p>
<p>我们还希望将性能数字与可扩展性数字结合起来定义。换句话说，我们必须在没有特定规模的情况下建立一个性能基线，并确定在一定数量的用户下，可接受的性能水平是多少。</p>
<h3 id="隐形架构特性">隐形架构特性</h3>
<p><img loading="lazy" src="/media/images/20210125-fosa5/implicit.jpg" alt=""  />
</p>
<p>许多没有在需求文档中指定的架构特性却非常重要。</p>
<p>系统可能支持的一个隐含的架构特性是可用性：确保用户可以访问三明治网站。与可用性密切相关的是可靠性：<strong>确保网站在交互过程中保持运行&ndash;没有人想从一个不断掉线的网站上购买</strong>。</p>
<p>安全性在每个系统中都是一个隐含的特性：<strong>没有人愿意使用不安全的软件。然而，它可能会根据关键性来确定优先级</strong>。</p>
<p>对于该三明治店的支付应该由第三方处理，因此，只要开发者遵循一般的安全（不将信用卡号码以纯文本的形式传递，不存储太多信息等），架构师应该不需要任何特殊的结构设计来适应安全问题，在应用中做好设计就足够了。</p>
<p>三明治店需要支持的最后一个主要架构特性：可定制性。需求的几个部分提供了自定义行为：食谱、本地销售等。通常这应该属于应用程序的设计，这个设计元素对应用的成功并不关键。</p>
<p>在选择架构特性的过程中，没有正确的答案，只有不正确的答案：</p>
<blockquote>
<p>架构没有错误的答案，只有昂贵的答案。</p>
</blockquote>
<p>架构师可以设计一个在结构上不适应可定制性的架构，要求应用本身来支持这种行为。架构师不应该过于强调发现完全正确的架构特性集&ndash;开发人员可以用各种方式来实现功能。当然，正确识别重要的结构元素可能会促进更简单或更优雅的设计。</p>
<p>架构师还必须优先朝着找到最简单的集合的方向发展。<strong>团队在确定架构特性方面一个有用的尝试是找到最不重要的一个特性</strong>，如果你必须消除一个，那会是哪个？一般来说，架构师更有可能剔除显性的架构特征，因为许多隐性的特征是一个应用想成功最基本的特性。</p>
<p>在三明治店的案例中，哪个架构特性是最不重要的？（不存在绝对正确的答案）</p>
<p>在这种情况下，解决方案可能会失去<strong>可定制性</strong>或<strong>性能</strong>。我们可以取消可定制性作为架构特性，并计划将该行为作为应用设计的一部分来实现。性能可能是成功的最不关键因素，当然，开发人员并不是要构建一个性能糟糕的应用，而是要构建一个不将性能优先于其他特性（如可扩展性或可用性）的应用。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>软件架构基础 4: 你的架构需要考虑的架构特性</title>
      <link>https://tangwz.com/post/fosa4/</link>
      <pubDate>Sat, 16 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tangwz.com/post/fosa4/</guid>
      <description>一个公司决定用软件解决一个特定的问题，公司会收集该系统的需求清单。需求可以说是软件开发的基础，但除了需求以外，架构师有很多因素需要去考虑。
下图在第 1 章出现过：
架构师可能会参与收集需求，但架构师一个关键的职责是要发现、定义其它和具体需求没有直接关系的东西，这些东西称之为架构特性（architectural characteristics）。
一个架构特性满足三个标准：
 指定了一个非领域（业务）设计的考虑因素：例如，一个重要的架构特性是应用程序的性能水平，而这一点往往不会出现在需求文档中； 影响结构上的设计：这个架构特性是否需要特殊的结构才能成功？例如，考虑要支持支付功能的系统，可以选择第三方支付（只需要符合安全即可嵌入），还是应用自己处理支付（这需要设计特定的支付模块），这将导致不同的架构设计； 对应用的成功至关重要：应用程序可以支持大量的架构特性，但每个架构特性的支持都会增加设计的复杂性，因此，架构师的一项工作是选择最少的架构特性；  架构特性主要分为显性的和隐性的。
隐性的很少出现在需求中，但它们却是项目成功的必要条件。例如，可用性、可靠性和安全性几乎是所有应用的基础，然而它们很少在设计文档中被提及。
架构师必须在分析阶段利用他们的知识来发现这些架构特性。
架构特性列表 架构特性存在于软件系统的广泛范围内，从代码特性如模块化，到复杂的问题如可扩展性和弹性。由于软件生态系统变化如此之快，新的概念、术语、措施和验证不断出现，并不存在真正的标准。但是架构师通常将架构特性分为下面几大类：
运行架构特性 运行架构特性涵盖了性能、可扩展性、弹性、可用性和可靠性等能力。
   类型 定义     可用性(Availability) 系统可用时间，如果是24/7，则需要使系统在发生任何故障时能够迅速启动和运行   持续性(Continuity) 灾难恢复能力   性能(Performance) 包括压力测试、峰值分析、分析功能的使用频率、所需容量和响应时间。性能报告有时需要自行演练，需要几个月才能完成。   可恢复性(Recoverability) 业务持续性要求(例如，在发生灾难的情况下，系统需要多快才能重新上线？)。这将影响备份策略和对冗余硬件的要求   可靠性/安全性(Reliability/safety) 评估系统是否需要具备某些安全功能，如果发生故障，是否会给公司带来大笔资金损失？   稳健性(Robustness) 在网络连接中断、断电或硬件故障时，系统是否能够处理运行中的错误和边界条件   可扩展性(Scalability) 随着用户或请求数量的增加，系统执行和运行的能力    结构架构特性 架构师也必须关注代码结构。在许多情况下，架构师对代码质量问题负有单独或共同的责任，如良好的模块化、组件之间的可控耦合、可读的代码以及一系列其他内部质量评估。
   类型 定义     可配置性(Configurability) 能够轻松地变更软件配置   可扩展性(Extensibility) 添加新的功能是多么的重要   可安装性(Installability) 易于在所有必要的平台上安装   可利用性/重复使用(Leverageability/reuse) 能够重复利用通用组件   本地化(Localization) 在文字输入、显示上支持多种语言；在报表、计量单位、货币上支持各种字符   可维护性(Maintainability) 如何轻松地进行应用变更和系统维护   可移植性(Portability) 系统是否需要运行在超过一个平台上   支持性(Supportability) 应用程序需要什么级别的技术支持？需要什么级别的日志和其他设施来调试系统中的错误？   可升级性(Upgradeability) 能够在服务器和客户端上轻松、快速地升级    交叉架构特性 许多特征不在分类范围内或无法分类，却形成了重要的设计限制和考虑因素。</description>
      <content:encoded><![CDATA[<p>一个公司决定用软件解决一个特定的问题，公司会收集该系统的需求清单。需求可以说是软件开发的基础，但除了需求以外，架构师有很多因素需要去考虑。</p>
<p>下图在第 1 章出现过：</p>
<p><img loading="lazy" src="/media/images/20210116-fosa4/requirements.jpg" alt=""  />
</p>
<p>架构师可能会参与收集需求，但架构师一个关键的职责是要发现、定义其它和具体需求没有直接关系的东西，这些东西称之为架构特性（architectural characteristics）。</p>
<p>一个架构特性满足三个标准：</p>
<ul>
<li>指定了一个非领域（业务）设计的考虑因素：例如，一<strong>个重要的架构特性是应用程序的性能水平，而这一点往往不会出现在需求文档中</strong>；</li>
<li>影响结构上的设计：这个架构特性是否需要特殊的结构才能成功？例如，考虑要支持支付功能的系统，可以选择第三方支付（只需要符合安全即可嵌入），还是应用自己处理支付（这需要设计特定的支付模块），这将导致不同的架构设计；</li>
<li>对应用的成功至关重要：应用程序可以支持大量的架构特性，但每个架构特性的支持都会增加设计的复杂性，因此，架构师的一项工作是<strong>选择最少的架构特性</strong>；</li>
</ul>
<p><img loading="lazy" src="/media/images/20210116-fosa4/characteristics.jpg" alt=""  />
</p>
<p>架构特性主要分为显性的和隐性的。</p>
<p>隐性的很少出现在需求中，但它们却是项目成功的必要条件。例如，可用性、可靠性和安全性几乎是所有应用的基础，然而它们很少在设计文档中被提及。</p>
<p>架构师必须在分析阶段利用他们的知识来发现这些架构特性。</p>
<h2 id="架构特性列表">架构特性列表</h2>
<p>架构特性存在于软件系统的广泛范围内，从代码特性如模块化，到复杂的问题如可扩展性和弹性。由于软件生态系统变化如此之快，新的概念、术语、措施和验证不断出现，并不存在真正的标准。但是架构师通常将架构特性分为下面几大类：</p>
<h3 id="运行架构特性">运行架构特性</h3>
<p>运行架构特性涵盖了性能、可扩展性、弹性、可用性和可靠性等能力。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>可用性(Availability)</td>
<td>系统可用时间，如果是24/7，则需要使系统在发生任何故障时能够迅速启动和运行</td>
</tr>
<tr>
<td>持续性(Continuity)</td>
<td>灾难恢复能力</td>
</tr>
<tr>
<td>性能(Performance)</td>
<td>包括压力测试、峰值分析、分析功能的使用频率、所需容量和响应时间。性能报告有时需要自行演练，需要几个月才能完成。</td>
</tr>
<tr>
<td>可恢复性(Recoverability)</td>
<td>业务持续性要求(例如，在发生灾难的情况下，系统需要多快才能重新上线？)。这将影响备份策略和对冗余硬件的要求</td>
</tr>
<tr>
<td>可靠性/安全性(Reliability/safety)</td>
<td>评估系统是否需要具备某些安全功能，如果发生故障，是否会给公司带来大笔资金损失？</td>
</tr>
<tr>
<td>稳健性(Robustness)</td>
<td>在网络连接中断、断电或硬件故障时，系统是否能够处理运行中的错误和边界条件</td>
</tr>
<tr>
<td>可扩展性(Scalability)</td>
<td>随着用户或请求数量的增加，系统执行和运行的能力</td>
</tr>
</tbody>
</table>
<h3 id="结构架构特性">结构架构特性</h3>
<p>架构师也必须关注代码结构。在许多情况下，架构师对代码质量问题负有单独或共同的责任，如良好的模块化、组件之间的可控耦合、可读的代码以及一系列其他内部质量评估。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>可配置性(Configurability)</td>
<td>能够轻松地变更软件配置</td>
</tr>
<tr>
<td>可扩展性(Extensibility)</td>
<td>添加新的功能是多么的重要</td>
</tr>
<tr>
<td>可安装性(Installability)</td>
<td>易于在所有必要的平台上安装</td>
</tr>
<tr>
<td>可利用性/重复使用(Leverageability/reuse)</td>
<td>能够重复利用通用组件</td>
</tr>
<tr>
<td>本地化(Localization)</td>
<td>在文字输入、显示上支持多种语言；在报表、计量单位、货币上支持各种字符</td>
</tr>
<tr>
<td>可维护性(Maintainability)</td>
<td>如何轻松地进行应用变更和系统维护</td>
</tr>
<tr>
<td>可移植性(Portability)</td>
<td>系统是否需要运行在超过一个平台上</td>
</tr>
<tr>
<td>支持性(Supportability)</td>
<td>应用程序需要什么级别的技术支持？需要什么级别的日志和其他设施来调试系统中的错误？</td>
</tr>
<tr>
<td>可升级性(Upgradeability)</td>
<td>能够在服务器和客户端上轻松、快速地升级</td>
</tr>
</tbody>
</table>
<h3 id="交叉架构特性">交叉架构特性</h3>
<p>许多特征不在分类范围内或无法分类，却形成了重要的设计限制和考虑因素。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>可访问性(Accessibility)</td>
<td>让您的所有用户，包括色盲或听障等残疾用户都能访问(例如 Iphone 就有类似的支持)</td>
</tr>
<tr>
<td>归档性(Archivability)</td>
<td>数据是否需要在一段时间后归档或删除？例如，客户账户在三个月后要删除或标记为过时，并归档到二级数据库，以便将来访问。</td>
</tr>
<tr>
<td>认证(Authentication)</td>
<td>安全要求，确保用户就是那个人。</td>
</tr>
<tr>
<td>权限(Authorization)</td>
<td>安全性要求，以确保用户只能访问应用程序中的某些功能</td>
</tr>
<tr>
<td>法律要求(Legal)</td>
<td>系统在什么法律约束下运行(数据保护、萨班斯法案、GDPR 等)？公司需要哪些保留权限？关于应用程序的构建或部署方式有什么规定？</td>
</tr>
<tr>
<td>隐私(Privacy)</td>
<td>能够对公司内部员工隐藏交易(加密的交易即使是 DBA 和网络架构师也无法看到)</td>
</tr>
<tr>
<td>安全性(Security)</td>
<td>数据库中的数据是否需要加密？内部系统之间的网络通信是否需要加密？远程用户访问时需要进行哪种类型的认证？</td>
</tr>
<tr>
<td>可用性/可实现性(Usability/achievability)</td>
<td>你的用户使用应用程序需要的培训程度，是否易用？。<strong>需要像对待其他架构问题一样认真对待可用性要求。</strong></td>
</tr>
</tbody>
</table>
<h3 id="其它架构特性">其它架构特性</h3>
<p>ISO 也发布过软件质量的列表，参见：https://iso25000.com/index.php/en/iso-25000-standards/iso-25010</p>
<p>主要分为下图的各大类，在此不再展开。</p>
<p><img loading="lazy" src="/media/images/20210116-fosa4/quality.jpg" alt=""  />
</p>
<p><strong>任何架构特征列表必然是不完整的，任何软件都可能根据独特的因素发明重要的架构特征。</strong></p>
<h2 id="权衡架构">权衡架构</h2>
<p>由于各种原因，应用程序只能支持列出的几个架构特性：</p>
<ul>
<li>每一个被支持的特性都需要设计上的努力，或许还需要结构上的支持；</li>
<li>更大的问题在于，每个架构特性往往会对其他特性产生影响。例如，如果架构师想要提高安全性，几乎肯定会对性能产生负面影响；</li>
</ul>
<p>因此，架构师很少会遇到这样的情况：他们能够设计一个系统，并将每一个架构特性最大化。<strong>更多的情况是，决定要在几个相互竞争的问题之间进行权衡。</strong></p>
<p>过多的架构特性导致设计变得笨重。</p>
<p>**架构师应该努力使架构设计尽可能地迭代。**如果能更容易地对架构进行修改，就可以减少在第一次尝试中就设计出完全正确的东西的压力。敏捷软件开发最重要的经验之一就是迭代的价值，这在软件开发的各个层面都适用，包括架构。</p>
<p>（这本书一直在强调，在软件架构和开发中，快速迭代和敏捷的重要性。）</p>
<p><strong>永远不要追求最佳的架构。</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title> 软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？</title>
      <link>https://tangwz.com/post/fosa3/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tangwz.com/post/fosa3/</guid>
      <description>0. 写在前面 什么是好的代码？好的代码应该模块化。
王垠在其《编程的智慧》中也提到，要“写模块化的代码”。(不对人做评价，这篇文章写得是非常好的。)
如果你读过《代码大全》和《代码整洁之道》等书，一定对**“高内聚、低耦合”**不陌生。
好的模块化代码就是要高内聚、低耦合。
事实上，内聚和耦合是 1972 年就提出的概念，由于耦合不好具体的衡量，Meilir Page-Jones 在 1992 年提出了共生性（Connascence）。本章重点就是介绍如何评估模块化架构，以及引入共生性这一概念来帮助更好的模块化。
1. 模块化 不同的平台、语言为代码提供了不同的复用机制，将相关代码组合成模块。
理解模块对于架构师来说非常重要，因为用来分析架构的工具（可视化等）常常都依赖于模块化的概念。如果一个架构师在设计一个系统时，没有注意到各个部分是如何连接在一起的，那么他们最终创建的系统会带来无数的问题。
架构师必须保持良好的结构，这不会偶然发生。
模块的代码到底是什么？我们用模块化来描述相关代码中的逻辑分组，这些模块可以用来构造一个更复杂的结构。
现代的语言有各种各样的封装机制，例如，许多语言可以在函数/方法、类、包/命名空间中定义行为，每个包都有不同的可见性和范围规则。（这有时候也会让开发人员选择困难）
架构师必须意识到开发者是如何组织包的，如果几个包紧密的耦合在一起，那么重用其中一个包就变得非常困难。
鉴于模块化的重要性，研究人员提供了各种语言无关的标准来衡量，我们专注于三个关键概念：
 内聚（Cohesion） 耦合（Coupling） 共生性（Connascence）（注：参考《UML面向对象设计基础》的翻译）  2. 内聚（Cohesion） 内聚性是指子程序中各种操作之间联系的紧密程度，我们的目标是让每一个模块只做好一件事，不去做其他事情。
 试图分割一个内聚的模块只会导致耦合性增加和可读性降低。（Attempting to divide a cohesive module would only result in increased coupling and decreased readability.） —— Larry Constantine
 计算机科学家们已经定义了一系列的内聚的衡量标准，从最好到最坏列出如下：
 功能性内聚（Functional cohesion）：模块内所有元素都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分，具有最高的内聚； 顺序内聚（Sequential cohesion）：模块必须顺序执行； 通信内聚（Communicational cohesion）：两个不同操作的模块使用同样的数据。例如，在数据库中添加一条记录，并根据该信息生成一封邮件； 过程内聚（Procedural cohesion）：两个模块必须以特定的次序执行。 时间内聚（Temporal cohesion）：把需要同时执行的动作组合在一起形成的模块。 逻辑内聚（Logical cohesion）：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能。 巧合内聚（Coincidental cohesion）：模块内的各个元素之间没有任何联系，只是偶然地被凑到一起；内聚程度最低。  内聚不容易考量，特定的模块需要架构师来具体决定，例如，考虑一个模块定义了：
Customer：</description>
      <content:encoded><![CDATA[<h2 id="0--写在前面">0.  写在前面</h2>
<p>什么是好的代码？好的代码应该模块化。</p>
<p>王垠在其<a href="https://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy">《编程的智慧》</a>中也提到，要“写模块化的代码”。(不对人做评价，这篇文章写得是非常好的。)</p>
<p>如果你读过《代码大全》和《代码整洁之道》等书，一定对**“高内聚、低耦合”**不陌生。</p>
<p><strong>好的模块化代码就是要高内聚、低耦合。</strong></p>
<p>事实上，内聚和耦合是 1972 年就提出的概念，由于耦合不好具体的衡量，Meilir Page-Jones 在 1992 年提出了共生性（Connascence）。本章重点就是介绍如何评估模块化架构，以及引入共生性这一概念来帮助更好的模块化。</p>
<h2 id="1-模块化">1. 模块化</h2>
<p>不同的平台、语言为代码提供了不同的复用机制，将相关代码组合成模块。</p>
<p>理解模块对于架构师来说非常重要，因为用来分析架构的工具（可视化等）常常都依赖于模块化的概念。如果一个架构师在设计一个系统时，没有注意到各个部分是如何连接在一起的，那么他们最终创建的系统会带来无数的问题。</p>
<p>架构师必须保持良好的结构，这不会偶然发生。</p>
<p>模块的代码到底是什么？我们用模块化来描述相关代码中的逻辑分组，这些模块可以用来构造一个更复杂的结构。</p>
<p>现代的语言有各种各样的封装机制，例如，许多语言可以在函数/方法、类、包/命名空间中定义行为，每个包都有不同的可见性和范围规则。（这有时候也会让开发人员选择困难）</p>
<p>架构师必须意识到开发者是如何组织包的，如果几个包紧密的耦合在一起，那么重用其中一个包就变得非常困难。</p>
<p>鉴于模块化的重要性，研究人员提供了各种语言无关的标准来衡量，我们专注于三个关键概念：</p>
<ul>
<li>内聚（Cohesion）</li>
<li>耦合（Coupling）</li>
<li>共生性（Connascence）（注：参考<a href="https://book.douban.com/subject/10737799/">《UML面向对象设计基础》</a>的翻译）</li>
</ul>
<h2 id="2-内聚cohesion">2. 内聚（Cohesion）</h2>
<p>内聚性是指子程序中各种操作之间联系的紧密程度，我们的目标是让每一个模块只做好一件事，不去做其他事情。</p>
<blockquote>
<p>试图分割一个内聚的模块只会导致耦合性增加和可读性降低。（Attempting to divide a cohesive module would only result in increased coupling and decreased readability.） —— Larry Constantine</p>
</blockquote>
<p><img loading="lazy" src="/media/images/20210114-fosa3/cohesion1.jpg" alt=""  />
</p>
<p>计算机科学家们已经定义了一系列的内聚的衡量标准，从最好到最坏列出如下：</p>
<ul>
<li>功能性内聚（Functional cohesion）：模块内所有元素都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分，具有最高的内聚；</li>
<li>顺序内聚（Sequential cohesion）：模块必须顺序执行；</li>
<li>通信内聚（Communicational cohesion）：两个不同操作的模块使用同样的数据。例如，在数据库中添加一条记录，并根据该信息生成一封邮件；</li>
<li>过程内聚（Procedural cohesion）：两个模块必须以特定的次序执行。</li>
<li>时间内聚（Temporal cohesion）：把需要同时执行的动作组合在一起形成的模块。</li>
<li>逻辑内聚（Logical cohesion）：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能。</li>
<li>巧合内聚（Coincidental cohesion）：模块内的各个元素之间没有任何联系，只是偶然地被凑到一起；内聚程度最低。</li>
</ul>
<p><img loading="lazy" src="/media/images/20210114-fosa3/cohesion2.jpg" alt=""  />
</p>
<p>内聚不容易考量，特定的模块需要架构师来具体决定，例如，考虑一个模块定义了：</p>
<p>Customer：</p>
<ul>
<li>add customer</li>
<li>update customer</li>
<li>get customer</li>
<li>notify customer</li>
<li>get customer orders</li>
<li>cancel customer orders</li>
</ul>
<p>或者说将后两个函数剥离出来，分成两个模块：</p>
<p>Customer：</p>
<ul>
<li>add customer</li>
<li>update customer</li>
<li>get customer</li>
<li>notify customer</li>
</ul>
<p>Order：</p>
<ul>
<li>get customer orders</li>
<li>cancel customer orders</li>
</ul>
<p>哪个更好？一如既往，这要看情况：</p>
<ul>
<li>订单只有这两个操作吗？如果是这样，将这些操作放在客户包中维护可能是有意义的；</li>
<li>客户包按预期是否会变得更大？</li>
<li>订单是否需要如此多的客户信息？</li>
</ul>
<p>这些问题代表了软件架构师工作核心的权衡分析。</p>
<p>由于内聚非常主观，计算机科学家制定了一个标准来衡量内聚性，其中 <strong>LCOM(Lack of Cohesion in Methods)</strong> 为著名。这里涉及到的数学公式平时很少用到，在此不再展开，只需要知道有这么一个公式，在需要的时候可以再查询拿出来用。想进一步了解的读者可以查看：<a href="https://en.wikipedia.org/wiki/Programming_complexity">https://en.wikipedia.org/wiki/Programming_complexity</a></p>
<h2 id="3-耦合coupling">3. 耦合（Coupling）</h2>
<p>我们常常谈到要“解耦”，弱耦合是系统可维护的关键。</p>
<p>耦合其实也有多种类型，但在此不再介绍，因为它们已经被共生性（Connascence）所取代。</p>
<h2 id="4-共生性connascence">4. 共生性（Connascence）</h2>
<p>1996 年 Meilir Page-Jones 发表了
<a href="https://dl.acm.org/doi/book/10.5555/231061">《What Every Programmer Should Know About Object-Oriented Design》</a>，完善了耦合的度量，并命名为：Connascence。</p>
<p>他是这样定义的：</p>
<blockquote>
<p>如果一个组件的改变会要求另一个组件进行修改，才能保持系统的整体正确性，那么这两个组件就是共生的。 —— Meilir Page-Jones</p>
</blockquote>
<p>共生性分为静态的和动态的。我们将分别介绍各种类型的共生性，对于部分重要的、不易理解的，我将补充一些代码案例，作为具体的参考来帮助理解。</p>
<p><strong>静态共生性：</strong></p>
<h3 id="41-名称共生性connascence-of-name-con">4.1 名称共生性（Connascence of Name, CoN）</h3>
<p><code>methodA()</code> 改名为 <code>methodB()</code> 时,　调用 <code>methodA()</code> 的地方都要改名，这是代码库中最常见的耦合方式，现代的 IDE 的检索功能使修改代码的名称变得很容易，这是最理想的耦合方式；</p>
<p><img loading="lazy" src="/media/images/20210114-fosa3/con.jpg" alt=""  />
</p>
<h3 id="42-类型共生性connascence-of-type-cot">4.2 类型共生性（Connascence of Type, CoT)</h3>
<p>如果一个变量从值 100 变成了一个很大的数，变量的类型可能要从 int 改成 BigInteger</p>
<h3 id="43-意义共生性connascence-of-meaning-com">4.3 意义共生性（Connascence of Meaning, CoM）</h3>
<p>例如，在很多语言中，通常会把大于 0 的数字认为是 True，0 认为是 False。下面是 Java 中的一个具体例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">a<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>b<span style="color:#f92672">)</span>
<span style="color:#75715e">// 如果 a = b，则返回值 0；
</span><span style="color:#75715e">// 如果 a &gt; b，则返回大于 0 的值；
</span><span style="color:#75715e">// 如果 a &lt; b，则返回小于 0 的值。
</span></code></pre></div><h3 id="44-位置共生性connascence-of-position-cop">4.4 位置共生性（Connascence of Position, CoP）</h3>
<p>函数的参数的位置顺序或个数耦合，例如下面的函数增加一个参数后，函数调用将会出错。</p>
<p><img loading="lazy" src="/media/images/20210114-fosa3/cop.jpg" alt=""  />
</p>
<p><img loading="lazy" src="/media/images/20210114-fosa3/cop2.jpg" alt=""  />
</p>
<p>针对这个例子，我们可以通过下面的办法，将位置共生性转为名称共生性来降低耦合性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">User</span> { <span style="color:#a6e22e">FirstName</span>, <span style="color:#a6e22e">LastName</span>, <span style="color:#a6e22e">Address</span> }
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SaveUser</span>(<span style="color:#a6e22e">User</span>);

<span style="color:#a6e22e">myrepo</span>.<span style="color:#a6e22e">SaveUser</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">User</span>{
        <span style="color:#a6e22e">FirstName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bob&#34;</span>,
        <span style="color:#a6e22e">LastName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Marley&#34;</span>,
        <span style="color:#a6e22e">Address</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Jamaica&#34;</span>});
</code></pre></div><h3 id="45-算法共生性connascence-of-algorithm-coa">4.5 算法共生性（Connascence of Algorithm, CoA）</h3>
<p>多个组件必须就一个特定的算法达成一致。例如：客户端和服务端用相同的算法验证用户身份。这代表一种较高的耦合形式——如果算法细节改变，验证将不再有效。</p>
<hr>
<p><strong>动态共生性：</strong></p>
<h3 id="46-执行共生性connascence-of-execution-coe">4.6 执行共生性（Connascence of Execution, CoE）</h3>
<p>代码的执行顺序上的耦合。例如下面的代码，在设置主题之前就发送了，明显在顺序上有问题。</p>
<pre tabindex="0"><code>email = new Email();
email.setRecipient(&quot;foo@example.com&quot;);
email.setSender(&quot;me@me.com&quot;);
email.send();
email.setSubject(&quot;whoops&quot;);
</code></pre><h3 id="47-时间共生性connascence-of-timing-cot">4.7 时间共生性（Connascence of Timing, CoT）</h3>
<p>常见情况是两个线程同时执行造成的竞赛条件。</p>
<p>这里我们可以看一个有趣的例子，发生在 bootstrap 的一个 issue：<a href="https://github.com/twbs/bootstrap/issues/3902">https://github.com/twbs/bootstrap/issues/3902</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// using bootstrap modal
</span><span style="color:#75715e"></span><span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">element</span>).<span style="color:#a6e22e">modal</span>(<span style="color:#e6db74">&#39;hide&#39;</span>)
<span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">element</span>).<span style="color:#a6e22e">modal</span>(<span style="color:#e6db74">&#39;show&#39;</span>) <span style="color:#75715e">// Error!
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 隐藏一个 modal 大约需要 500ms 的动画，
</span><span style="color:#75715e">// 如果你在这时候直接调用了 &#39;show&#39;，将会发生异常
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 我们必须这样做
</span><span style="color:#75715e"></span><span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">element</span>).<span style="color:#a6e22e">modal</span>(<span style="color:#e6db74">&#39;hide&#39;</span>)
<span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">element</span>).<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;hidden.bs.modal&#39;</span>, ()=&gt;{
    <span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">element</span>).<span style="color:#a6e22e">modal</span>(<span style="color:#e6db74">&#39;show&#39;</span>) <span style="color:#75715e">// ok
</span><span style="color:#75715e"></span>})
</code></pre></div><h3 id="48-值共生性connascence-of-values-cov">4.8 值共生性（Connascence of Values, CoV）</h3>
<p>常见的情况在分布式事务中，例如需要在多个独立的数据库中做分布式事务。</p>
<h3 id="49-身份共生性connascence-of-identity-coi">4.9 身份共生性（Connascence of Identity, CoI）</h3>
<p>两个独立的模块需要共享和更新同一个数据结构，例如：分布式队列。</p>
<h2 id="5-共生性的属性">5. 共生性的属性</h2>
<h3 id="51-强度strength">5.1 强度（Strength）</h3>
<p>Page-Jones 指出，共生性有明确的强弱谱系，如下图所示，按强度递增排序。identity 具有最强的共生性，name 具有最弱的共生性。——也就是说用 name 的方式耦合则为最弱的耦合方式。</p>
<p><img loading="lazy" src="/media/images/20210114-fosa3/strength.jpg" alt=""  />
</p>
<p><strong>架构师应该倾向于静态共生性而不是动态共生性</strong>，因为开发人员可以通过现代的 IDE 来很快地确定它。</p>
<h3 id="52-局部性locality">5.2 局部性（Locality）</h3>
<p>局部性指两个模块的之间的远近程度。</p>
<p>通常情况下，在同一模块中、距离较近的类比在不同模块中、距离距离较远的类具有更高的共生性。换句话说，随着两个模块在代码中的距离增加，共生性会减弱。</p>
<h3 id="53-程度degree">5.3 程度（Degree）</h3>
<p>共生性的程度与模块的影响大小有关——它影响了几个类还是几十个类？影响较小的共生性对代码库的损坏就较小。</p>
<h2 id="6-如何通过共生性来提高系统模块化">6. 如何通过共生性来提高系统模块化</h2>
<p>讲了这么多，我们到底如何实践共生性呢？</p>
<p>Page-Jones 提供了三个使用共生性来提高系统模块化的指南：
1.通过将系统拆分成封装的元素，使得整体的共生性达到最弱
2.最大限度地减少任何跨越封装边界的共生性
3.最大限度地提高封装边界的共生性</p>
<p>Jim Weirich （传奇的软件架构创新者，Ruby 社区活跃人士）简化了上面较为抽象的指导，提供了两个更具体的建议：</p>
<ul>
<li><strong>程度法则（Rule of Degree）：将强共生性转化为弱共生性。</strong></li>
<li><strong>局部性规则（Rule of Locality）：随着软件元素之间距离的增加，应使用较弱的共生性。</strong></li>
</ul>
<h2 id="7-耦合性和共生性">7. 耦合性和共生性</h2>
<p>从架构师的角度来看，耦合和共生是有所重叠的，这是不同时代的产物，下图列出两者重叠的部分：</p>
<p><img loading="lazy" src="/media/images/20210114-fosa3/coupling_and_connascence.jpg" alt=""  />
</p>
<p>共生性提供了更精细化的考量，例如左边的数据耦合，在右边的静态共生性提供了更具体的建议。</p>
<h2 id="8-局限性">8. 局限性</h2>
<p>尽管如此，架构师在应用这些指标来分析和设计系统时，存在几个问题：</p>
<ul>
<li>这些度量从代码层面考察细节，关注代码质量，而不一定是架构。架构师更关注模块如何耦合，而不是耦合程度，例如，架构师关心的是同步或异步通信，而不关心如何实现。</li>
<li>共生性并没有真正解决许多现代架构师必须做出的一个基本决定&ndash;在分布式架构（例如：微服务）中，使用同步还是异步通信？在后面会介绍新的方法来思考现代的共生性。</li>
</ul>
<p>虽然对模块化进行了大量的介绍和思考，<strong>开发人员和架构师在实际实施过程中，还是会遇到很多的困难。</strong></p>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
<p>设计良好的架构，并非易事！</p>
]]></content:encoded>
    </item>
    
    <item>
      <title> 软件架构基础 2：架构思维</title>
      <link>https://tangwz.com/post/fosa2/</link>
      <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tangwz.com/post/fosa2/</guid>
      <description>架构思维指用架构的眼光和观点来看待事物，主要包括：
 理解软件架构和软件设计的区别，知道与开发团队合作，并让架构发挥作用。 拥有技术广度的同时，保持一定的技术深度，看到别人看不到的解决方案和可能性。 理解、分析、协调各种解决方案和技术之间的权衡。 理解业务驱动的重要性，以及如何将其转化为架构。  架构与设计 软件架构和软件设计的区别往往是一个令人困惑的问题。架构在哪里结束，设计在哪里开始？架构师与开发人员的职责分别是什么？
下图是传统的架构师和开发的关系，架构师分析业务需求，提取和定义架构特性，选择架构风格，以及创建组件，然后交给开发团队，开发团队为每个组件创建类、用户界面，以及开发和测试源码。
这样的架构很少能够成功，因为单箭头穿过架构师和开发人员，意味着架构师的想法和决定很少传到开发团队，而开发团队碰到的架构问题也很少回到架构师那里———这样的模式是脱节的。
想要架构发挥作用，必须打破架构师和开发人员之间的物理和虚拟的障碍，形成一种双向关系。这种模式不仅有利于架构师和开发之间的双向沟通，而且可以让架构师为团队中的开发人员提供指导和辅导。
下图展示了一种双向沟通关系。
与老派的瀑布流程静态且僵化的软件架构不同，当今系统的架构在项目的每一次迭代都会发生变化和发展，架构师和开发团队之间的紧密合作是任何软件项目成功的关键。
技术广度 如果说开发人员必须具备很好的技术深度才能完成工作，那么架构师必须具备大量的技术广度来思考问题。
下图代表知识金字塔，包括三类知识：
 你知道的东西(Stuff you know)：日常工作中使用的技术、框架、语言和工具； 你知道你不知道的东西(Stuff you know you don&amp;rsquo;t know)：略知一二但没有深入理解或没有专业知识的东西，例如：你可能听过 Clojure，但是不知道怎么使用这种语言进行编码； 你不知道你不知道的东西(Stuff you don&amp;rsquo;t know you don&amp;rsquo;t know)：你不知道这些东西的存在，是知识三角中最大的一部分；  对开发人员来说，最重要的是顶部的部分。
随着开发人员向架构师角色的过渡，知识的性质发生了变化。架构师的很大一部分价值如何使用技术解决特定问题。例如，作为一名架构师，知道针对特定问题存在五种解决方案比只在一种解决方案上拥有单一的专业知识更有利。
对架构师来说，金字塔最重要的部分是顶部和中间部分。
对于架构师来说，明智的做法是牺牲一些很难学到（hard-won）的专业知识，利用这段时间来拓宽自己的广度。这也是一种取舍。
如下图，“你知道的东西”变小了，只保留一些技术深度（渗透下来的绿色），用来换取技术广度。
知识金字塔说明了架构师和开发人员的不同。
开发人员用他们的整个职业生涯来磨练专业知识，过渡到架构师的角色意味着这种观点的转变。这对许多人来说很难，常导致两个问题：
 试图在每个领域都保持专业性，导致任何一个领域都不成功，把工作做得很粗糙； 错误地以为自己陈旧的知识仍然是前沿的，经常在大公司看到这种情况；  向架构师角色过渡的开发人员必须改变他们看待知识获取的方式，平衡关于深度与广度的知识组合是每个开发人员在整个职业生涯中应该考虑的问题。
分析权衡  架构就是你没法用 Google 搜索的东西。
 架构中的一切都是权衡。
每个架构问题的答案都包含了“这取决于……”，你没法在 Google 搜索是 REST 还是消息传递更好，是微服务好还是单体架构更好？因为它确实取决于，取决于部署环境、业务、公司文化、预算、时间、开发人员的技能组合以及其他几十个因素。
架构之所以这么难，因为每个人的环境、情况和问题都不一样。
在架构中没有正确或错误的答案，只有权衡。
考虑一个拍卖系统，有以下两种数据消费模式。
图 6: 发布-订阅（pub-sub）消息传递。 图 7：队列，点对点消息传递。 发布-订阅模型的优势：
 假如我们要增加一个“竞价历史”新服务，则完全不需要对现有系统进行任何修改；而在队列模型中，我们可能需要修改生产者添加一个队列； 解耦：生产者不需要知道数据有哪些服务在使用、如何去使用；而在队列模型中，生产者需要知道是什么类型的数据，发送给谁。  **架构师的思维需要看到方案的好处和坏处。**队列模型的优势：</description>
      <content:encoded><![CDATA[<p>架构思维指用架构的眼光和观点来看待事物，主要包括：</p>
<ul>
<li>理解软件架构和软件设计的区别，知道与开发团队合作，并让架构发挥作用。</li>
<li>拥有技术广度的同时，保持一定的技术深度，看到别人看不到的解决方案和可能性。</li>
<li>理解、分析、协调各种解决方案和技术之间的权衡。</li>
<li>理解业务驱动的重要性，以及如何将其转化为架构。</li>
</ul>
<h2 id="架构与设计">架构与设计</h2>
<p>软件架构和软件设计的区别往往是一个令人困惑的问题。架构在哪里结束，设计在哪里开始？架构师与开发人员的职责分别是什么？</p>
<p>下图是传统的架构师和开发的关系，架构师分析业务需求，提取和定义架构特性，选择架构风格，以及创建组件，然后交给开发团队，开发团队为每个组件创建类、用户界面，以及开发和测试源码。</p>
<p><img loading="lazy" src="/media/images/20210108-fosa2/Architect-Dev1.jpg" alt=""  />
</p>
<p>这样的架构很少能够成功，因为单箭头穿过架构师和开发人员，意味着架构师的想法和决定很少传到开发团队，而开发团队碰到的架构问题也很少回到架构师那里———这样的模式是脱节的。</p>
<p>想要架构发挥作用，必须打破架构师和开发人员之间的物理和虚拟的障碍，形成一种双向关系。这种模式不仅有利于架构师和开发之间的双向沟通，而且可以让架构师为团队中的开发人员提供指导和辅导。</p>
<p>下图展示了一种双向沟通关系。</p>
<p><img loading="lazy" src="/media/images/20210108-fosa2/Architect-Dev2.jpg" alt=""  />
</p>
<p>与老派的瀑布流程静态且僵化的软件架构不同，<strong>当今系统的架构在项目的每一次迭代都会发生变化和发展，架构师和开发团队之间的紧密合作是任何软件项目成功的关键。</strong></p>
<h2 id="技术广度">技术广度</h2>
<p>如果说开发人员必须具备很好的技术深度才能完成工作，那么架构师必须具备大量的技术广度来思考问题。</p>
<p>下图代表知识金字塔，包括三类知识：</p>
<ul>
<li>你知道的东西(Stuff you know)：日常工作中使用的技术、框架、语言和工具；</li>
<li>你知道你不知道的东西(Stuff you know you don&rsquo;t know)：略知一二但没有深入理解或没有专业知识的东西，例如：你可能听过 Clojure，但是不知道怎么使用这种语言进行编码；</li>
<li>你不知道你不知道的东西(Stuff you don&rsquo;t know you don&rsquo;t know)：你不知道这些东西的存在，是知识三角中最大的一部分；</li>
</ul>
<p><img loading="lazy" src="/media/images/20210108-fosa2/Stuff1.jpg" alt=""  />
</p>
<p>对开发人员来说，最重要的是顶部的部分。</p>
<p>随着开发人员向架构师角色的过渡，知识的性质发生了变化。架构师的很大一部分价值如何使用技术解决特定问题。例如，作为一名架构师，知道针对特定问题存在五种解决方案比只在一种解决方案上拥有单一的专业知识更有利。</p>
<p><strong>对架构师来说，金字塔最重要的部分是顶部和中间部分。</strong></p>
<p><img loading="lazy" src="/media/images/20210108-fosa2/Stuff2.jpg" alt=""  />
</p>
<p>对于架构师来说，明智的做法是牺牲一些很难学到（hard-won）的专业知识，利用这段时间来拓宽自己的广度。这也是一种取舍。</p>
<p>如下图，“你知道的东西”变小了，只保留一些技术深度（渗透下来的绿色），用来换取技术广度。</p>
<p><img loading="lazy" src="/media/images/20210108-fosa2/Stuff3.jpg" alt=""  />
</p>
<p>知识金字塔说明了架构师和开发人员的不同。</p>
<p>开发人员用他们的整个职业生涯来磨练专业知识，过渡到架构师的角色意味着这种观点的转变。这对许多人来说很难，常导致两个问题：</p>
<ul>
<li>试图在每个领域都保持专业性，导致任何一个领域都不成功，把工作做得很粗糙；</li>
<li>错误地以为自己陈旧的知识仍然是前沿的，经常在大公司看到这种情况；</li>
</ul>
<p>向架构师角色过渡的开发人员必须改变他们看待知识获取的方式，<strong>平衡关于深度与广度的知识组合是每个开发人员在整个职业生涯中应该考虑的问题。</strong></p>
<h2 id="分析权衡">分析权衡</h2>
<blockquote>
<p>架构就是你没法用 Google 搜索的东西。</p>
</blockquote>
<p>架构中的一切都是权衡。</p>
<p>每个架构问题的答案都包含了“这取决于……”，你没法在 Google 搜索是 REST 还是消息传递更好，是微服务好还是单体架构更好？因为它确实取决于，取决于部署环境、业务、公司文化、预算、时间、开发人员的技能组合以及其他几十个因素。</p>
<p><strong>架构之所以这么难，因为每个人的环境、情况和问题都不一样。</strong></p>
<p><strong>在架构中没有正确或错误的答案，只有权衡。</strong></p>
<p>考虑一个拍卖系统，有以下两种数据消费模式。</p>
<p>图 6: 发布-订阅（pub-sub）消息传递。
<img loading="lazy" src="/media/images/20210108-fosa2/Pub-sub.jpg" alt=""  />
</p>
<p>图 7：队列，点对点消息传递。
<img loading="lazy" src="/media/images/20210108-fosa2/Queue.jpg" alt=""  />
</p>
<p>发布-订阅模型的优势：</p>
<ul>
<li>假如我们要增加一个“竞价历史”新服务，则完全不需要对现有系统进行任何修改；而在队列模型中，我们可能需要修改生产者添加一个队列；</li>
<li>解耦：生产者不需要知道数据有哪些服务在使用、如何去使用；而在队列模型中，生产者需要知道是什么类型的数据，发送给谁。</li>
</ul>
<p>**架构师的思维需要看到方案的好处和坏处。**队列模型的优势：</p>
<ul>
<li>任何人都能访问发布-订阅模型的数据，存在数据访问和安全问题。</li>
<li>发布-订阅模型只能接受相同格式的数据，假设新的“竞价历史”服务需要当前的售价以及竞价，但其他服务原本没有这些信息，在这种情况下需要修改数据格式，并且会影响使用该数据的所有其他服务。在队列模型中，这将是一个单独的通道，因此是一个单独的格式，不影响任何其他服务。</li>
<li>发布-订阅模型不支持监控某个主题的消息数量，导致不支持自动缩放。在队列中很容易知道哪个队列消息量大，独立地自动伸缩。请注意，这种权衡是特定于技术的，高级消息队列协议（Advanced Message Queuing Protocol，AMQP）可以支持负载均衡和监控。</li>
</ul>
<p>鉴于这种权衡分析，现在哪个是更好的选择？答案是什么呢? 这就要看情况了!</p>
<h2 id="理解业务">理解业务</h2>
<p>架构思维就是要理解系统成功所需的业务因素，并将这些需求转化为架构特性（如可扩展性、性能和可用性）。</p>
<p>这是一项具有挑战性的任务，要求架构师具有一定程度的业务领域知识，并与关键业务利益相关者建立健康的协作关系。</p>
<h2 id="平衡架构和编码">平衡架构和编码</h2>
<p>架构师面临的困难任务之一是如何平衡架构和编码。</p>
<p><strong>每个架构师都应该进行编码</strong>，并且能够保持一定的技术深度（参见“技术广度”）。虽然这看起来似乎是一个简单的任务，但有时却相当难以完成。</p>
<p>架构师需要避免<strong>瓶颈陷阱</strong>。当架构师掌握项目关键路径内的代码（通常是底层框架代码）的所有权，并成为团队的瓶颈时，就会出现瓶颈陷阱**。架构师不是全职开发人员，需要在开发人员（编写和测试代码）和架构师（画图、参加会议，以及参加更多的会议）之间取得平衡。**</p>
<p>避免瓶颈陷阱的方法：将关键路径和框架代码委托给开发团队中的其他人，然后集中精力在一到三次迭代后对一个业务功能进行编码。</p>
<p>架构师如何才能保持亲力亲为并保持一定的技术深度呢？有四种基本方法可以让架构师在工作中练习，而不必“在家练习编码”（尽管也建议在家里练习编码）：</p>
<ul>
<li>经常做 POC（proof-of-concept），通过考虑实现细节来验证架构决策。例如，如果架构师在两种缓存解决方案中无法抉择，那么可以每种缓存开发一个实例，并进行对比。</li>
<li>处理一些技术债务或架构问题，让开发团队腾出时间来处理关键的功能开发。这些问题通常是低优先级的，一般不会影响迭代。还可以在迭代中修复 bug，在帮助开发团队的同时也保持了编码，还可以找出代码库可能存在的问题和弱点。</li>
<li>通过创建简单的命令行工具和分析工具来帮助开发团队自动化完成日常任务，<strong>寻找开发团队执行的重复性任务，并将这个过程自动化。开发团队会感谢自动化。</strong></li>
<li>经常做 code review。虽然并不是实际写代码，但至少参与了源代码的编写。此外，<strong>做 code review 还能确保代码符合架构的要求，帮助和指导开发</strong>。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title> 软件架构基础 1：基本介绍</title>
      <link>https://tangwz.com/post/fosa1/</link>
      <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tangwz.com/post/fosa1/</guid>
      <description>《软件架构基础（Fundamentals of Software Architecture）》被誉为和《设计数据密集型应用》一样经典的后端书籍，架构师的入门指南。本篇为该书第一章的读书笔记。
如今，全球范围内“架构师”这一头衔炒得十分火热，但没有真正的指南来帮助开发人员成为软件架构师。
这本书主要有三部分内容：基础、架构风格、技术和软技能。基础部分是关于软件体系结构的一般概念；架构风格部分介绍了不同的架构风格，并以一些架构特征标准进行评价；技术和软技能部分涵盖了很多好的概念，包括做出健康的架构决策、风险分析技术、演讲能力、管理团队关系、谈判、架构师职业规划等。
 架构就是关于重要的东西&amp;hellip;&amp;hellip;不管那是什么。—— Ralph Johnson
 1. 什么是软件架构 学习架构就像学习艺术一样，读者必须要在特定的背景下去理解它。
在一个动态系统中，不存在一劳永逸的解决方案。
学习架构时，必须放在上下文中理解。架构师做的许多决定都是基于他们所处的实际情况。
 例如，在 20 世纪末的主要目标是有效地利用共享资源，因为当时所有的基础设施都是昂贵的商业化产品：操作系统、服务器和数据库等等。如果你在 2002 年告诉主管，“我有一个革命性的架构好主意，每个服务都运行在自己隔离的机器上，有自己的专用数据库……（即描述今天的微服务架构）所以，我需要 50 个 Windows 的许可证，另外 30 个服务器许可证，以及至少 50 个数据库许可证。”在 2002 年想构建这样的微服务架构成本之高难以想象。然而这几年，随着开源运动的兴起，以及 DevOps 的出现，我们可以合理地构建一个如上所述的架构。
 整个行业都在努力精确定义“软件架构”，有些称为系统的蓝图，有些定义为开发的路线图。本书关于架构的定义主要从四个方面：
 系统的结构（Structure） 系统所支持的架构特性、能力（Architecture characteristics） 架构决策（Architecture decisions） 设计原则（Design principles）  系统的结构指的是系统实现架构风格的类型（如微服务、分层或微内核）。但仅仅通过结构来描述一个架构，并不能完全阐明一个架构。 架构特性多以 &amp;ldquo;-ility&amp;rdquo; 结尾（例如 Availability、Scalability） 架构决策定义了系统应该如何构建的规则。例如，架构师可能会做出一个架构决策，即在分层架构中只有业务层和服务层可以访问数据库（见图），限制表现层直接调用数据库。架构决策形成了系统的约束，并指导开发团队什么是允许的，什么是不允许的。 设计原则与架构决策的不同之处在于，设计原则是一个指导方针，而不是一个硬性规定。例如，图示的设计原则指出，开发团队应该在微服务架构中的服务之间传递异步消息来提高性能。一个架构决策永远不可能涵盖服务之间通信的每一个条件和选项，设计原则为首选方法（在本例中，异步消息传递）提供指导，允许开发人员在特定情况下选择更合适的通信协议（如 REST 或 gRPC）。 2. 对架构师的 8 个期待 2.1 做出架构决定 架构师应确定架构和设计原则，用于指导团队、部门或整个企业的技术决策。
架构师应该指导而不是指定技术选择。例如，架构师应该决定开发团队使用基于响应式 (Reactive) 的框架进行开发，从而指导开发团队在 Angular、Elm、React.js、Vue 或其他任何基于响应式的 Web 框架之间做出选择。
架构师偶尔需要做出特定的技术决策，以保留特定的架构特性，如可扩展性、性能或可用性。</description>
      <content:encoded><![CDATA[<p>《软件架构基础（Fundamentals of Software Architecture）》被誉为和《设计数据密集型应用》一样经典的后端书籍，架构师的入门指南。本篇为该书第一章的读书笔记。</p>
<p><img loading="lazy" src="/media/images/20210107-fosa1/fosa.jpg" alt=""  />
</p>
<p>如今，全球范围内“架构师”这一头衔炒得十分火热，但没有真正的指南来帮助开发人员成为软件架构师。</p>
<p>这本书主要有三部分内容：基础、架构风格、技术和软技能。基础部分是关于软件体系结构的一般概念；架构风格部分介绍了不同的架构风格，并以一些架构特征标准进行评价；技术和软技能部分涵盖了很多好的概念，包括做出健康的架构决策、风险分析技术、演讲能力、管理团队关系、谈判、架构师职业规划等。</p>
<blockquote>
<p>架构就是关于重要的东西&hellip;&hellip;不管那是什么。—— Ralph Johnson</p>
</blockquote>
<h2 id="1-什么是软件架构">1. 什么是软件架构</h2>
<p>学习架构就像学习艺术一样，读者必须要在特定的背景下去理解它。</p>
<p>在一个动态系统中，不存在一劳永逸的解决方案。</p>
<p>学习架构时，必须放在上下文中理解。架构师做的许多决定都是基于他们所处的实际情况。</p>
<blockquote>
<p>例如，在 20 世纪末的主要目标是有效地利用共享资源，因为当时所有的基础设施都是昂贵的商业化产品：操作系统、服务器和数据库等等。如果你在 2002 年告诉主管，“我有一个革命性的架构好主意，每个服务都运行在自己隔离的机器上，有自己的专用数据库……（即描述今天的微服务架构）所以，我需要 50 个 Windows 的许可证，另外 30 个服务器许可证，以及至少 50 个数据库许可证。”在 2002 年想构建这样的微服务架构成本之高难以想象。然而这几年，随着开源运动的兴起，以及 DevOps 的出现，我们可以合理地构建一个如上所述的架构。</p>
</blockquote>
<p>整个行业都在努力精确定义“软件架构”，有些称为系统的蓝图，有些定义为开发的路线图。本书关于架构的定义主要从四个方面：</p>
<ul>
<li>系统的结构（Structure）</li>
<li>系统所支持的架构特性、能力（Architecture characteristics）</li>
<li>架构决策（Architecture decisions）</li>
<li>设计原则（Design principles）</li>
</ul>
<h4 id="系统的结构指的是系统实现架构风格的类型如微服务分层或微内核但仅仅通过结构来描述一个架构并不能完全阐明一个架构">系统的结构指的是系统实现架构风格的类型（如微服务、分层或微内核）。但仅仅通过结构来描述一个架构，并不能完全阐明一个架构。</h4>
<p><img loading="lazy" src="/media/images/20210107-fosa1/structure.jpg" alt=""  />
</p>
<h4 id="架构特性多以--ility-结尾例如-availabilityscalability">架构特性多以 &ldquo;<em>-ility</em>&rdquo; 结尾（例如 Availability、Scalability）</h4>
<p><img loading="lazy" src="/media/images/20210107-fosa1/Architecture-characteristics.jpg" alt=""  />
</p>
<h4 id="架构决策定义了系统应该如何构建的规则例如架构师可能会做出一个架构决策即在分层架构中只有业务层和服务层可以访问数据库见图限制表现层直接调用数据库架构决策形成了系统的约束并指导开发团队什么是允许的什么是不允许的">架构决策定义了系统应该如何构建的规则。例如，架构师可能会做出一个架构决策，即在分层架构中只有业务层和服务层可以访问数据库（见图），限制表现层直接调用数据库。架构决策形成了系统的约束，并指导开发团队什么是允许的，什么是不允许的。</h4>
<p><img loading="lazy" src="/media/images/20210107-fosa1/Architecture-decisions.jpg" alt=""  />
</p>
<h4 id="设计原则与架构决策的不同之处在于设计原则是一个指导方针而不是一个硬性规定例如图示的设计原则指出开发团队应该在微服务架构中的服务之间传递异步消息来提高性能一个架构决策永远不可能涵盖服务之间通信的每一个条件和选项设计原则为首选方法在本例中异步消息传递提供指导允许开发人员在特定情况下选择更合适的通信协议如-rest-或-grpc">设计原则与架构决策的不同之处在于，设计原则是一个指导方针，而不是一个硬性规定。例如，图示的设计原则指出，开发团队应该在微服务架构中的服务之间传递异步消息来提高性能。一个架构决策永远不可能涵盖服务之间通信的每一个条件和选项，设计原则为首选方法（在本例中，异步消息传递）提供指导，允许开发人员在特定情况下选择更合适的通信协议（如 REST 或 gRPC）。</h4>
<p><img loading="lazy" src="/media/images/20210107-fosa1/Design-principles.jpg" alt=""  />
</p>
<h2 id="2-对架构师的-8-个期待">2. 对架构师的 8 个期待</h2>
<h3 id="21-做出架构决定">2.1 做出架构决定</h3>
<p>架构师应确定架构和设计原则，用于指导团队、部门或整个企业的技术决策。</p>
<p><strong>架构师应该指导而不是指定技术选择</strong>。例如，架构师应该决定开发团队使用基于响应式 (Reactive) 的框架进行开发，从而指导开发团队在 Angular、Elm、React.js、Vue 或其他任何基于响应式的 Web 框架之间做出选择。</p>
<p>架构师偶尔需要做出特定的技术决策，以保留特定的架构特性，如可扩展性、性能或可用性。</p>
<p>架构师经常为找到正确的界线而苦恼。</p>
<h3 id="22-持续分析架构">2.2 持续分析架构</h3>
<p>多数架构都会经历结构性衰变，当开发人员进行编码或设计变更时，会影响到所需的架构特性，如性能、可用性和可扩展性。架构师需要评估三年或更长时间前定义的架构在今天的可行性。</p>
<p>另一方面，架构师还常常忘记测试和发布环境。敏捷性有很大的好处，如果团队需要几周的时间来测试变更，而发布又需要几个月的时间，那么架构师就无法实现整体架构的敏捷性。</p>
<h3 id="23-紧跟最新趋势">2.3 紧跟最新趋势</h3>
<p><strong>架构师要跟上最新的技术和行业趋势。</strong></p>
<p>开发人员必须掌握他们每天使用的最新技术，以保持代码能力(并保住一份工作！)。架构师有一个更关键的要求，就是要掌握最新的技术和行业趋势。架构师所做的决定往往是长期的，难以改变的，了解和跟踪关键趋势有助于架构师为未来做好准备，做出正确的决定。</p>
<h3 id="24-确保遵守各项决定">2.4 确保遵守各项决定</h3>
<p>架构师要不断验证开发团队是否遵循架构师定义、记录和传达的架构决策和设计原则。</p>
<blockquote>
<p>考虑这样的场景：架构师做出一个决定，在分层架构中限制对数据库的访问，只限于业务层和服务层（而不是表现层）。这意味着表现层必须经过架构的所有层才能进行最简单的数据库调用。用户界面开发人员可能不同意这个决定，出于性能考虑而直接访问数据库。然而，架构师做出这个架构决策是有特定原因的：控制变化。通过保持各层独立，可以在不影响表现层的情况下进行数据库变更。如果不确保架构决策的合规性，就会发生类似这样的违规行为，架构将无法满足所需的架构特性，应用程序或系统将无法按预期工作。</p>
</blockquote>
<h3 id="25-多样化的接触和经验">2.5 多样化的接触和经验</h3>
<p>架构师要接触多种多样的技术、框架、平台和环境。</p>
<p>现在的大多数环境都是异构的，一个架构师至少应该知道如何与多个系统和服务对接，不管这些系统或服务是用什么语言、平台和技术编写的。</p>
<p>最好方法之一是让架构师延伸自己的舒适区，只关注单一技术或平台是一个安全的避风港，一个好的软件架构师应该积极寻找机会，以获得多种语言、平台和技术的经验，关注技术广度而不只是技术深度。</p>
<h3 id="26-具备业务领域知识">2.6 具备业务领域知识</h3>
<p>一个架构师要有一定的业务领域专业知识。</p>
<p>有效的软件架构师不仅了解技术，还了解业务问题。<strong>如果没有业务领域的知识，就很难理解业务问题、目标和需求，很难设计出满足业务需求的有效架构。</strong></p>
<p>最成功的架构师是那些拥有广泛的、实践性的技术知识，再加上对某一特定领域的深刻了解的人。这些软件架构师能够使用这些利益相关者所能理解的领域知识和语言，与主管和业务用户进行有效的沟通。</p>
<h3 id="27-具备人际交往能力">2.7 具备人际交往能力</h3>
<p>架构师应具备卓越的人际交往能力，包括团队合作、促进和领导能力。</p>
<p><strong>拥有卓越的领导力和人际交往能力是大多数开发人员和架构师难以企及的期望</strong>。作为技术专家，开发人员和架构师喜欢解决技术问题，而不是人的问题。</p>
<p>架构师不仅要为团队提供技术指导，还要带领开发团队完成架构的实施。无论架构师的角色和头衔是什么，领导能力是成为一个软件架构师不可或缺的。</p>
<h3 id="28-理解和驾驭企业政治">2.8 理解和驾驭企业政治</h3>
<p><strong>架构师要了解企业的政治氛围，并能驾驭政治。</strong></p>
<p>在一本关于软件架构的书中谈论谈判和驾驭办公室政治，可能看起来比较奇怪。主要的一点是，<strong>几乎架构师的每一个决策都会受到挑战</strong>。由于涉及到成本或工作量（时间）的增加，架构决策会受到产品、项目经理、开发和业务利益相关者的挑战，因为他们觉得自己的方法更好。无论在哪种情况下，架构师都必须驾驭公司的政治，并应用基本的谈判技巧来获得批准。</p>
<p>架构师不像开发，可以自行设计代码结构、类、设计模式甚至是语言而不需要批准，架构师做出广泛而重要的决策，必须为几乎每一个决策进行论证和争取。</p>
<h2 id="3-架构师和其它的交集">3. 架构师和其它的交集</h2>
<h3 id="31-工程实践">3.1 工程实践</h3>
<p>将软件开发过程与软件工程实践分开是有益的。所谓过程，我们指的是如何组建和管理团队，如何进行会议以及工作流组织，指的是人们如何组织和互动的机制。而**软件工程实践则是指那些已经说明了的、可重复效益的与过程无关的实践。**例如，持续集成是一种经过验证的工程实践，它不依赖于特定的过程。</p>
<p>注重工程实践很重要：</p>
<ul>
<li>首先，软件开发缺乏许多比较成熟的工程学科的特点。例如，土木工程可以比软件工程更准确地预测结构变化。</li>
<li>其次，**软件开发的一个致命弱点是估算&ndash;多少时间，多少资源，多少钱？**这种困难一部分在于陈旧的会计无法适应软件开发的探索性；但另一部分是因为我们传统上不擅长估算，部分原因是因为 unknown unknowns。</li>
</ul>
<p>unknown unknowns 是软件系统的克星：没有人知道会出现的东西，却又意外地出现了。例如：某个意外的 bug 出现。</p>
<blockquote>
<p>所有的架构都会因为 unknown unknowns 而变成迭代式的，敏捷只是认识到了这一点，并且更早去做了。（All architectures become iterative because of unknown unknowns, Agile just recognizes this and does it sooner.）</p>
</blockquote>
<p>迭代流程更符合软件架构的本质，试图使用像瀑布这样的陈旧流程来构建微服务这样的现代系统的团队会发现，一个陈旧的流程忽视了软件如何结合在一起的现实，会产生大量的摩擦。</p>
<p><img loading="lazy" src="/media/images/20210107-fosa1/requirements.jpg" alt=""  />
</p>
<p>如图所示，<strong>软件系统的架构由需求和所有其他架构特征组成</strong>。</p>
<p>采用敏捷工程实践，如持续集成、自动机器供应和类似的实践，使构建弹性架构变得更容易。这也说明了架构与工程实践是如何相互交织在一起的。</p>
<h3 id="32-运维devops">3.2 运维/DevOps</h3>
<p>架构和相关领域之间最近最明显的交集发生在 DevOps 的出现。许多公司认为运维是与软件开发是分离的，在 20 世纪 90 年代和 2000 年代设计的架构都假设架构师无法控制运维，架构师们被迫围绕引入的限制进行防御性设计。因此，他们构建了能够在内部处理规模、性能、弹性和其他一系列能力的架构。这种设计的副作用是大大增加了架构的复杂性。</p>
<p>微服务风格架构的构建者们意识到，通过在架构和运维之间建立一个联络点，架构师可以简化设计，依靠运维来处理他们最擅长的事情。因此，意识到资源的挪用导致了意外的复杂性，架构师和运维合作创建了微服务。</p>
<h3 id="33-流程">3.3 流程</h3>
<p>软件架构与软件开发过程大多是正交的（相互不可替代的），大多数关于软件架构的书籍都忽略了软件开发过程。例如，在过去的几十年里，由于软件的性质，许多公司都采用了敏捷开发方法。架构师在敏捷项目中得到更快的反馈，这使得架构师可以更积极地进行实验。</p>
<p>所有的架构都会变成迭代式的，这只是时间问题。为此，我们要在整个过程中假设敏捷方法论的基线，并允许适当的例外。例如，许多单体架构因为年龄、政治或其他与软件无关的因素而使用旧流程的情况还是很常见的。</p>
<h3 id="34-数据">3.4 数据</h3>
<p>很大一部分严肃的应用程序开发包括外部数据存储，通常采用关系型(或越来越多的 NoSQL)数据库的形式。然而，许多关于软件架构的书籍只对架构的这一重要方面进行了轻描淡写的处理。代码和数据具有共生关系：两者缺一不可。</p>
<h2 id="4-软件架构法则">4. 软件架构法则</h2>
<p>软件架构第一定律：
<strong>软件架构中的所有东西都是一种权衡。(Everything in software architecture is a trade-off.)</strong></p>
<p>我们对软件架构的定义超越了结构的范畴，包含了原则、特性等，架构的范围比单纯的结构更广，体现在我们的软件架构第二定律中：
<strong>为什么比怎么做更重要。（Why is more important than how.）</strong></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
