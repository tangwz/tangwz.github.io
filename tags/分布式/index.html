<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>分布式 | 多颗糖</title>
<meta name="keywords" content="" />
<meta name="description" content="多颗糖 - 一名系统研究者的攀登之路">
<meta name="author" content="多颗糖">
<link rel="canonical" href="https://tangwz.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://tangwz.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tangwz.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tangwz.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tangwz.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://tangwz.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.4" />
<link rel="alternate" type="application/rss+xml" href="https://tangwz.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-72128068-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="分布式" />
<meta property="og:description" content="多颗糖 - 一名系统研究者的攀登之路" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://tangwz.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" /><meta property="og:image" content="https://tangwz.com/"/>

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://tangwz.com/"/>

<meta name="twitter:title" content="分布式"/>
<meta name="twitter:description" content="多颗糖 - 一名系统研究者的攀登之路"/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tangwz.com/" accesskey="h" title="多颗糖 (Alt + H)">多颗糖</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tangwz.com/page/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://tangwz.com/">Home</a>&nbsp;»&nbsp;<a href="https://tangwz.com/tags/">Tags</a></div>
  <h1>分布式</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>条分缕析 Raft 算法(续)：日志压缩和性能优化
    </h2>
  </header>
  <section class="entry-content">
    <p>在上篇《条分缕析 Raft 算法》中推导和梳理了 Raft 算法，但仍有一些细节没有包含到，这篇文章作为补充。
1 日志压缩 随着时间推移，存储的日志会越来越多，不但占据很多磁盘空间，服务器重启做日志重放也需要更多的时间。如果没有办法来压缩日志，将会导致可用性问题：要么磁盘空间被耗尽，要么花费太长时间启动。所以日志压缩是必要的。
日志压缩的一般思路是，日志中的许多信息随着时间推移会变成过时的，可以丢弃。例如：一个将 x 设置为 2 的操作，如果在未来将 x 设置为了 3，那么 x=2 这个操作就过时了，可以丢弃。
一旦日志记录被提交并应用于状态机，那么用于到达当前状态的中间状态和操作就不再需要了，它们可以被压缩掉。
和配置变化不同，不同的系统有不同的日志压缩方式，取决于你的性能考量，以及基于硬盘还是基于内存。日志压缩的大部分责任都落在状态机上。
不同的压缩方法有几个核心的共同点：
 不将压缩决定集中在 Leader 上，每个服务器独立地压缩其已提交的日志。这就避免了 Leader 将日志传递给已有该日志的 Follower，同时也增强了模块化，减少交互，将整个系统的复杂性最小化。（对于非常小的状态机，基于 Leader 的日志压缩也许更好。） 将之前的 log 的维护责任从 Raft 转移到状态机。Raft 要保存最后被丢弃的记录的index和term，用于 AppendEntries RPC 一致性检查。同时，也需要保存最新的配置信息：成员变更失败需要回退配置，最近的配置必须保存。 一旦丢弃了前面部分的日志，状态机就承担两个新的责任：1. 如果服务器重启了，需要将最新的快照加载到状态机后再接受 log；此外，2. 需要向较慢的 follower(日志远落后于 Leader)发送一致的状态镜像。  1.1 基于内存的状态机的快照 状态机的数据集小于 10GB 的时候选择 memory-based 状态机是合理的。
上图显示了 memory-based 状态机的基本想法：对内存的数据结构(树形或哈希等)进行序列化并存储，同时存储 Raft 重启需要的状态：最后一条记录的 index 和 term 以及该索引处的最新配置，然后这个 index 之前的日志和快照都可以丢弃了。
memory-based 状态机的快照的大部分工作是序列化内存中的数据结构。
通过上面的介绍，Leader 可能偶尔需要把它的状态发送给慢 Followers 或新加入集群的服务器。快照信息通过 InstallSnapshot RPC 来传输。你肯定在论文中看过下图：...</p>
  </section>
  <footer class="entry-footer"><span title='2021-02-19 00:00:00 +0000 UTC'>February 19, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;多颗糖</footer>
  <a class="entry-link" aria-label="post link to 条分缕析 Raft 算法(续)：日志压缩和性能优化" href="https://tangwz.com/post/raft-extension/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>条分缕析 Raft 算法
    </h2>
  </header>
  <section class="entry-content">
    <p>本文整理自 Ongaro 在 Youtube 上的视频。
目标 Raft 的目标（或者说是分布式共识算法的目标）是：保证 log 完全相同地复制到多台服务器上。
只要每台服务器的日志相同，那么，在不同服务器上的状态机以相同顺序从日志中执行相同的命令，将会产生相同的结果。
共识算法的工作就是管理这些日志。
系统模型 我们假设：
 服务器可能会宕机、会停止运行过段时间再恢复，但是非拜占庭的（即它的行为是非恶意的，不会篡改数据等）； 网络通信会中断，消息可能会丢失、延迟或乱序；可能会网络分区；  Raft 是基于 Leader 的共识算法，故主要考虑：
 Leader 正常运行 Leader 故障，必须选出新的 Leader  优点：只有一个 Leader，简单。
难点：Leader 发生改变时，可能会使系统处于不一致的状态，因此，下一任 Leader 必须进行清理；
我们将从 6 个部分解释 Raft：
 Leader 选举； 正常运行：日志复制（最简单的部分）； Leader 变更时的安全性和一致性（最棘手、最关键的部分）； 处理旧 Leader：旧的 Leader 并没有真的下线怎么办？ 客户端交互：实现线性化语义(linearizable semantics)； 配置变更：如何在集群中增加或删除节点；  开始之前 开始之前需要了解 Raft 的一些术语。
服务器状态 服务器在任意时间只能处于以下三种状态之一：
 Leader：处理所有客户端请求、日志复制。同一时刻最多只能有一个可行的 Leader； Follower：完全被动的（不发送 RPC，只响应收到的 RPC）——大多数服务器在大多数情况下处于此状态； Candidate：用来选举新的 Leader，处于 Leader 和 Follower 之间的暂时状态；  系统正常运行时，只有一个 Leader，其余都是 Followers....</p>
  </section>
  <footer class="entry-footer"><span title='2021-02-01 00:00:00 +0000 UTC'>February 1, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;多颗糖</footer>
  <a class="entry-link" aria-label="post link to 条分缕析 Raft 算法" href="https://tangwz.com/post/raft/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Golang 实现 Paxos 分布式共识算法
    </h2>
  </header>
  <section class="entry-content">
    <p>前文《理解 Paxos》只包含伪代码，帮助了理解但又不够爽，既然现在都讲究 Talk is cheap. Show me the code. 这次就把文章中的伪代码用 Go 语言实现出来，希望能帮助各位朋友更直观的感受 Paxos 论文中的细节。
但我们需要对算法做一些简化，有多简单呢？我们不持久化存储任何变量，并且用 chan 直接代替 RPC 调用。
代码地址：https://github.com/tangwz/paxos/tree/naive
记得切换到 naive 分支。
定义相关结构体 我们定义 Proposer 如下：
type proposer struct { // server id 	id int // the largest round number the server has seen 	round int // proposal number = (round number, serverID) 	number int // proposal value 	value string acceptors map[int]bool net network } 这些结构体成员都很容易理解，其中 acceptors 我们主要用来存储 Acceptors 的地址，以及记录我们收到 Acceptor 的成功/失败响应。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-12-13 00:00:00 +0000 UTC'>December 13, 2020</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;多颗糖</footer>
  <a class="entry-link" aria-label="post link to Golang 实现 Paxos 分布式共识算法" href="https://tangwz.com/post/impl-basic-paxos/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>用 Raft 的方式理解 Multi-Paxos
    </h2>
  </header>
  <section class="entry-content">
    <p>Multi-Paxos 在文献中并没有准确的实现细节，这里提供一个相对完整的规范，保持接近 Leslie Lamport 在 “The Part-Time Parliament.” 中给出的算法。
这里描述的 Multi-Paxos 尚未经过实践证明其正确性。
众所周知 Raft 是更易理解的，所以我参照 Raft 的风格，将 Paxos 转换成了下图。
1. 基础  提案编号 n = (round number, server ID) T： 固定的超时时间，用于选举算法 α：并发限制，用于配置变更  1.1 Leader 选举算法  每个节点每隔 T（ms） 向其它服务器发送心跳 如果一个节点在 2（Tms） 时间内没有收到比自己 server ID 更大的心跳，那它自己就转为 Leader  2. 持久化 2.1 Acceptor 上的持久化状态  lastLogIndex：已经接受的最大的日志index minProposal：已经接收提案中的最小提案编号，如果还未收到 Prepare 请求，则为 0  每个 Acceptor 上还会存储一个日志，日志索引 i ∈ [1, lastLogIndex]，每条日志记录包含以下内容：
 acceptedProposal[i]：第 i 条日志最后接受的提案编号。初始化时为 0；如果提案被 chosen，则 acceptedProposal[i] = 无穷大 acceptedValue[i]：第 i 条日志最后接受的 value，初始化时为 null firstUnchosenIndex：i &gt; 0 且 acceptedProposal[i] &lt; ∞ 的最小日志 index  2....</p>
  </section>
  <footer class="entry-footer"><span title='2020-11-15 00:00:00 +0000 UTC'>November 15, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;多颗糖</footer>
  <a class="entry-link" aria-label="post link to 用 Raft 的方式理解 Multi-Paxos" href="https://tangwz.com/post/understanding-multi-paxos/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Raft 作者亲自出的 Raft 试题，你能做对几道？
    </h2>
  </header>
  <section class="entry-content">
    <p>试题 1. （4 分）下面的每张图都显示了一台 Raft 服务器上可能存储的日志（日志内容未显示，只显示日志的 index 和任期号）。考虑每份日志都是独立的，下面的日志可能发生在 Raft 中吗？如果不能，请解释原因。
a. b. c. d. 2. （6 分）下图显示了一个 5 台服务器集群中的日志（日志内容未显示）。哪些日志记录可以安全地应用到状态机？请解释你的答案。
3. （10 分）考虑下图，它显示了一个 6 台服务器集群中的日志，此时刚刚选出任期 7 的新 Leader（日志内容未显示，只显示日志的 index 和任期号）。对于图中每一个 Follower，给定的日志是否可能在一个正常运行的 Raft 系统中存在？如果是，请描述该情况如何发生的；如果不是，解释为什么。
4. （5 分）假设硬件或软件错误破坏了 Leader 为某个特定 Follower 存储的 nextIndex 值。这是否会影响系统的安全？请简要解释你的答案。
5. （5 分）假设你实现了 Raft，并将它部署在同一个数据中心的所有服务器上。现在假设你要将系统部署到分布在世界各地的不同数据中心的每台服务器，与单数据中心版本相比，多数据中心的 Raft 需要做哪些更改？为什么？
6. （10 分）每个 Follower 都在其磁盘上存储了 3 个信息：当前任期（currentTerm）、最近的投票（votedFor）、以及所有接受的日志记录（log[]）。 a. 假设 Follower 崩溃了，并且当它重启时，它最近的投票信息已丢失。该 Follower 重新加入集群是否安全（假设未对算法做任何修改）？解释一下你的答案。 b. 现在，假设崩溃期间 Follower 的日志被截断（truncated）了，日志丢失了最后的一些记录。该 Follower 重新加入集群是否安全（假设未对算法做任何修改）？解释一下你的答案。
7. （10 分）如视频中所述，即使其它服务器认为 Leader 崩溃并选出了新的 Leader 后，（老的）Leader 依然可能继续运行。新的 Leader 将与集群中的多数派联系并更新它们的任期，因此，老的 Leader 将在与多数派中的任何一台服务器通信后立即下台。然而，与此期间，它也可以继续充当 Leader，并向尚未被新 Leader 联系到的 Follower 发出请求；此外，客户端可以继续向老的 Leader 发送请求。我们知道，在选举结束后，老的 Leader 不能提交（commit）任何新的日志记录，因为这样做需要联系选举多数派中的至少一台服务器。但是，老的 Leader 是否有可能执行一个成功 AppendEntries RPC，从而完成在选举开始前收到的旧日志记录的提交？如果可以，请解释这种情况是如何发生的，并讨论这是否会给 Raft 协议带来问题。如果不能发生这种情况，请说明原因。...</p>
  </section>
  <footer class="entry-footer"><span title='2020-10-26 00:00:00 +0000 UTC'>October 26, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;多颗糖</footer>
  <a class="entry-link" aria-label="post link to Raft 作者亲自出的 Raft 试题，你能做对几道？" href="https://tangwz.com/post/raft-exam/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://tangwz.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/page/2/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://tangwz.com/">多颗糖</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
