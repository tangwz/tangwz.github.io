<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Leveldb 基本介绍和使用指南 | 多颗糖</title>
<meta name="keywords" content="分布式存储" />
<meta name="description" content="leveldb 是一个持久化的 key/value 存储，key 和 value 都是任意的字节数组(byte arrays)，并且在存储时，key 值根据用户指定的 comparator 函数进行排序。
作者是大名鼎鼎的 Jeff Dean 和 Sanjay Ghemawat.
基本介绍 特性  keys 和 values 是任意的字节数组。 数据按 key 值排序存储。 调用者可以提供一个自定义的比较函数来重写排序顺序。 提供基本的 Put(key,value)，Get(key)，Delete(key) 操作。 多个更改可以在一个原子批处理中生效。 用户可以创建一个瞬时快照(snapshot)，以获得数据的一致性视图。 在数据上支持向前和向后迭代。 使用 Snappy 压缩库对数据进行自动压缩 与外部交互的操作都被抽象成了接口(如文件系统操作等)，因此用户可以根据接口自定义的操作系统交互。  局限性  这不是一个 SQL 数据库，它没有关系数据模型，不支持 SQL 查询，也不支持索引。 同时只能有一个进程(可能是具有多线程的进程)访问一个特定的数据库。 该程序库没有内置的 client-server 支持，有需要的用户必须自己封装。  性能 下面是运行 db_bench 程序的性能报告。结果有一些噪声(noisy)，但足以得到一个大概的性能估计。
配置 我们使用的是一个有一百万个条目的数据库，其中每个条目的 key 是 16 字节，value 是 100 字节，value 压缩后大约是原始大小的一半，测试配置如下:
LevelDB: version 1.1 Date: Sun May 1 12:11:26 2011 CPU: 4 x Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.">
<meta name="author" content="多颗糖">
<link rel="canonical" href="https://tangwz.com/post/leveldb-index/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://tangwz.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tangwz.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tangwz.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tangwz.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://tangwz.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.4" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-72128068-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="Leveldb 基本介绍和使用指南" />
<meta property="og:description" content="leveldb 是一个持久化的 key/value 存储，key 和 value 都是任意的字节数组(byte arrays)，并且在存储时，key 值根据用户指定的 comparator 函数进行排序。
作者是大名鼎鼎的 Jeff Dean 和 Sanjay Ghemawat.
基本介绍 特性  keys 和 values 是任意的字节数组。 数据按 key 值排序存储。 调用者可以提供一个自定义的比较函数来重写排序顺序。 提供基本的 Put(key,value)，Get(key)，Delete(key) 操作。 多个更改可以在一个原子批处理中生效。 用户可以创建一个瞬时快照(snapshot)，以获得数据的一致性视图。 在数据上支持向前和向后迭代。 使用 Snappy 压缩库对数据进行自动压缩 与外部交互的操作都被抽象成了接口(如文件系统操作等)，因此用户可以根据接口自定义的操作系统交互。  局限性  这不是一个 SQL 数据库，它没有关系数据模型，不支持 SQL 查询，也不支持索引。 同时只能有一个进程(可能是具有多线程的进程)访问一个特定的数据库。 该程序库没有内置的 client-server 支持，有需要的用户必须自己封装。  性能 下面是运行 db_bench 程序的性能报告。结果有一些噪声(noisy)，但足以得到一个大概的性能估计。
配置 我们使用的是一个有一百万个条目的数据库，其中每个条目的 key 是 16 字节，value 是 100 字节，value 压缩后大约是原始大小的一半，测试配置如下:
LevelDB: version 1.1 Date: Sun May 1 12:11:26 2011 CPU: 4 x Intel(R) Core(TM)2 Quad CPU Q6600 @ 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tangwz.com/post/leveldb-index/" /><meta property="og:image" content="https://tangwz.com/"/><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-30T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-11-30T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://tangwz.com/"/>

<meta name="twitter:title" content="Leveldb 基本介绍和使用指南"/>
<meta name="twitter:description" content="leveldb 是一个持久化的 key/value 存储，key 和 value 都是任意的字节数组(byte arrays)，并且在存储时，key 值根据用户指定的 comparator 函数进行排序。
作者是大名鼎鼎的 Jeff Dean 和 Sanjay Ghemawat.
基本介绍 特性  keys 和 values 是任意的字节数组。 数据按 key 值排序存储。 调用者可以提供一个自定义的比较函数来重写排序顺序。 提供基本的 Put(key,value)，Get(key)，Delete(key) 操作。 多个更改可以在一个原子批处理中生效。 用户可以创建一个瞬时快照(snapshot)，以获得数据的一致性视图。 在数据上支持向前和向后迭代。 使用 Snappy 压缩库对数据进行自动压缩 与外部交互的操作都被抽象成了接口(如文件系统操作等)，因此用户可以根据接口自定义的操作系统交互。  局限性  这不是一个 SQL 数据库，它没有关系数据模型，不支持 SQL 查询，也不支持索引。 同时只能有一个进程(可能是具有多线程的进程)访问一个特定的数据库。 该程序库没有内置的 client-server 支持，有需要的用户必须自己封装。  性能 下面是运行 db_bench 程序的性能报告。结果有一些噪声(noisy)，但足以得到一个大概的性能估计。
配置 我们使用的是一个有一百万个条目的数据库，其中每个条目的 key 是 16 字节，value 是 100 字节，value 压缩后大约是原始大小的一半，测试配置如下:
LevelDB: version 1.1 Date: Sun May 1 12:11:26 2011 CPU: 4 x Intel(R) Core(TM)2 Quad CPU Q6600 @ 2."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tangwz.com/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Leveldb 基本介绍和使用指南",
      "item": "https://tangwz.com/post/leveldb-index/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Leveldb 基本介绍和使用指南",
  "name": "Leveldb 基本介绍和使用指南",
  "description": "leveldb 是一个持久化的 key/value 存储，key 和 value 都是任意的字节数组(byte arrays)，并且在存储时，key 值根据用户指定的 comparator 函数进行排序。\n作者是大名鼎鼎的 Jeff Dean 和 Sanjay Ghemawat.\n基本介绍 特性  keys 和 values 是任意的字节数组。 数据按 key 值排序存储。 调用者可以提供一个自定义的比较函数来重写排序顺序。 提供基本的 Put(key,value)，Get(key)，Delete(key) 操作。 多个更改可以在一个原子批处理中生效。 用户可以创建一个瞬时快照(snapshot)，以获得数据的一致性视图。 在数据上支持向前和向后迭代。 使用 Snappy 压缩库对数据进行自动压缩 与外部交互的操作都被抽象成了接口(如文件系统操作等)，因此用户可以根据接口自定\u0010义的操作系统交互。  局限性  这不是一个 SQL 数据库，它没有关系数据模型，不支持 SQL 查询，也不支持索引。 同时只能有一个进程(可能是具有多线程的进程)访问一个特定的数据库。 该程序库没有内置的 client-server 支持，有需要的用户必须自己封装。  性能 下面是运行 db_bench 程序的性能报告。结果有一些噪声(noisy)，但足以得到一个大概的性能估计。\n配置 我们使用的是一个有一百万个条目的数据库，其中每个条目的 key 是 16 字节，value 是 100 字节，value 压缩后大约是原始大小的一半，测试配置如下:\nLevelDB: version 1.1 Date: Sun May 1 12:11:26 2011 CPU: 4 x Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.",
  "keywords": [
    "分布式存储"
  ],
  "articleBody": "leveldb 是一个持久化的 key/value 存储，key 和 value 都是任意的字节数组(byte arrays)，并且在存储时，key 值根据用户指定的 comparator 函数进行排序。\n作者是大名鼎鼎的 Jeff Dean 和 Sanjay Ghemawat.\n基本介绍 特性  keys 和 values 是任意的字节数组。 数据按 key 值排序存储。 调用者可以提供一个自定义的比较函数来重写排序顺序。 提供基本的 Put(key,value)，Get(key)，Delete(key) 操作。 多个更改可以在一个原子批处理中生效。 用户可以创建一个瞬时快照(snapshot)，以获得数据的一致性视图。 在数据上支持向前和向后迭代。 使用 Snappy 压缩库对数据进行自动压缩 与外部交互的操作都被抽象成了接口(如文件系统操作等)，因此用户可以根据接口自定\u0010义的操作系统交互。  局限性  这不是一个 SQL 数据库，它没有关系数据模型，不支持 SQL 查询，也不支持索引。 同时只能有一个进程(可能是具有多线程的进程)访问一个特定的数据库。 该程序库没有内置的 client-server 支持，有需要的用户必须自己封装。  性能 下面是运行 db_bench 程序的性能报告。结果有一些噪声(noisy)，但足以得到一个大概的性能估计。\n配置 我们使用的是一个有一百万个条目的数据库，其中每个条目的 key 是 16 字节，value 是 100 字节，value 压缩后大约是原始大小的一半，测试配置如下:\nLevelDB: version 1.1 Date: Sun May 1 12:11:26 2011 CPU: 4 x Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.40GHz CPUCache: 4096 KB Keys: 16 bytes each Values: 100 bytes each (50 bytes after compression) Entries: 1000000 Raw Size: 110.6 MB (estimated) File Size: 62.9 MB (estimated) 具体 benchmark 源码见：https://github.com/google/leveldb/blob/master/benchmarks/db_bench.cc\n写性能 “fill” 基准测试创建了一个全新的数据库，以顺序(下面的 “fillseq”)或者随机(下面的 “fillrandom”)方式写入。\n“fillsync” 基准测试每次写操作都将数据从操作系统刷到磁盘; 其它的操作会将数据保存在系统中一段时间。\n“overwrite” 基准测试做随机写，会更新数据库中已有的 key。\nfillseq : 1.765 micros/op; 62.7 MB/s fillsync : 268.409 micros/op; 0.4 MB/s (10000 ops) fillrandom : 2.460 micros/op; 45.0 MB/s overwrite : 2.380 micros/op; 46.5 MB/s 上述每个 “op” 对应一个 key/value 对的写操作。即，一个随机写基准测试每秒约四十万次写操作(1,000,000/2.46)。\n每个 “fillsync” 操作耗时(大约 0.3 毫秒)少于一次磁盘搜索(大约 10 毫秒)。我们怀疑这是因为磁盘本身将更新操作缓存到了内存，并在数据落盘之前返回响应。这可能是安全的，也可能是不安全的，取决于硬盘是否有足够的电力在断电时保存其内存。\n读性能 我们列出了正向顺序读、反向顺序读以及随机查询的性能。注意，基础测试创建的数据库很小，因此该性能报告描述的是 leveldb 的全部数据集能放入到内存的场景，如果数据不在操作系统缓存中，读取的性能消耗主要在于一到两次的磁盘搜索，写性能基本不会受数据集是否能放入内存的影响。\nreadrandom : 16.677 micros/op; (approximately 60,000 reads per second) readseq : 0.476 micros/op; 232.3 MB/s readreverse : 0.724 micros/op; 152.9 MB/s leveldb 会在后台 compact 其底层存储的数据来改善读性能。上面列出的结果是在大量随机写操作后得出的，经过 compact 后的性能指标（通常是指动出发的）会更好：\nreadrandom : 11.602 micros/op; (approximately 85,000 reads per second) readseq : 0.423 micros/op; 261.8 MB/s readreverse : 0.663 micros/op; 166.9 MB/s 读操作消耗高的成本一部分来自于重复解压从磁盘读取的数据库，如果我们能够提供足够的缓存给 leveldb 来将解压后的数据保存在内存中，读性能会进一步改善：\nreadrandom : 9.775 micros/op; (approximately 100,000 reads per second before compaction) readrandom : 5.215 micros/op; (approximately 190,000 reads per second after compaction) 编译 项目支持 Cmake 开箱即用。编译非常简单：\ngit clone --recurse-submodules https://github.com/google/leveldb.git mkdir -p build \u0026\u0026 cd build cmake -DCMAKE_BUILD_TYPE=Release .. \u0026\u0026 cmake --build . 头文件介绍 leveldb 对外暴露的接口都在 include/*.h 中，用户不应该依赖任何其它目录下的头文件，这些内部 API 可能会在没有警告的情况下被改变。\n include/leveldb/db.h：主要的 DB 接口，从这开始。 include/leveldb/options.h： 控制数据库的行为，也控制当个读和写的行为。 include/leveldb/comparator.h： 比较函数的抽象。如果你只想对 key 逐字节比较，可以直接使用默认的比较器。如果你想要自定义排序（例如处理不同的字符编码、解码等），可以实现自己的比较器。 include/leveldb/iterator.h：迭代数据的接口，你可以从一个 DB 对象获取到一个迭代器。 include/leveldb/write_batch.h：原子地将多个操作应用到数据库。 include/leveldb/slice.h：类似 string，维护着指向字节数组的指针和对应的长度。 include/leveldb/status.h：许多公共接口都会返回 Status，用于报告成功或各种错误。 include/leveldb/env.h：操作系统环境的抽象，该接口的 posix 实现位于 util/env_posix.cc 中. include/leveldb/table.h, include/leveldb/table_builder.h：底层的模块，大多数用户可能不会直接用到。  使用 编译以后我们可以使用 cmake 来小试牛刀，首先在 leveldb 目录创建文件夹 app/ 来单独存放我们的练习文件，然后创建一个文件例如：main.cc，接着我们修改 CMakeLists.txt 文件，增加一行：\n 347 if(NOT BUILD_SHARED_LIBS) + 348 leveldb_test(\"app/main.cc\") 349 leveldb_test(\"db/autocompact_test.cc\") 编写完代码后，只需回到 build/ 目录执行：\ncmake .. \u0026\u0026 cmake --build . 即可编译出 main 可执行文件。\n打开一个数据库 leveldb 数据库都有一个名字，该名字对应文件系统上的一个目录，该数据库内容全都存在该目录下。下面的例子显示了如何打开一个数据库，必要时创建数据库：\n#include #include \"leveldb/db.h\" int main() { leveldb::DB* db; leveldb::Options options; options.create_if_missing = true; leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", \u0026db); assert(status.ok()); } 如果你想在数据库已存在的时候触发一个异常，将下面这行配置加到 leveldb::DB::Open 调用之前：\noptions.error_if_exists = true; Status 你也许注意到上面的 leveldb::Status 返回类型，leveldb 中大部分方法在遇到错误的时候会返回该类型的值，你可以检查它是否 ok，然后打印相关的错误信息：\nleveldb::Status s = ...; if (!s.ok()) cerr  s.ToString()  endl; 尝试输出数据库已存在的错误信息吧！\n关闭数据库 当数据库不再使用的时候，像下面这样直接删除数据库对象就可以了：\ndelete db; 是不是很简单？后面我们具体源码分析时会看到，DB 类是基于 RAII 实现的，在 delete 时会触发析构函数自动清理。\n数据库读写 leveldb 提供了 Put、Delete 和 Get 方法来修改/查询数据库，下面的代码展示了将 key1 对应的 value 移动到 key2 下。\nstd::string value; leveldb::Status s = db-Get(leveldb::ReadOptions(), key1, \u0026value); if (s.ok()) s = db-Put(leveldb::WriteOptions(), key2, value); if (s.ok()) s = db-Delete(leveldb::WriteOptions(), key1); 原子更新 需要注意的是，在上一小节中如果进程在 Put key2 后 Delete key1 之前挂了，那么同样的 value 将被存储在多个 key 下。可以通过使用 WriteBatch 原子地应用一组操作来避免类似的问题。\n#include \"leveldb/write_batch.h\"... std::string value; leveldb::Status s = db-Get(leveldb::ReadOptions(), key1, \u0026value); if (s.ok()) { leveldb::WriteBatch batch; batch.Delete(key1); batch.Put(key2, value); s = db-Write(leveldb::WriteOptions(), \u0026batch); } WriteBatch 保存着一系列将被应用到数据库的操作，这些操作会按照添加的顺序依次被执行。注意，我们先执行 Delete 后执行 Put，这样如果 key1 和 key2 一样的情况下我们也不会错误地丢失数据。\n除了原子性，WriteBatch 也能加速更新过程，因为可以把一大批独立的操作添加到同一个 batch 中然后一次性执行。\n同步写操作 默认情况下，leveldb 每个写操作都是异步的：进程把要写的内容丢给操作系统后立即返回，从操作系统内存到底层持久化存储的传输是异步进行的。\n可以为某个特定的写操作打开同步标识：write_options.sync = true，以等到数据真正被记录到持久化存储后再返回（在 Posix 系统上，这是通过在写操作返回前调用 fsync(...) 或 fdatasync(...) 或 msync(..., MS_SYNC) 来实现的）。\nleveldb::WriteOptions write_options; write_options.sync = true; db-Put(write_options, ...); **异步写通常比同步写快 1000 倍。**异步写的缺点是，一旦机器崩溃可能会导致最后几个更新操作丢失。注意，仅仅是写进程崩溃（而非机器重启）不会造成任何损失，因为哪怕 sync 标识为 false，在进程退出之前，写操作也已经从进程内存推到了操作系统。\n异步写通常可以安全使用。比如你要将大量的数据写入数据库，如果丢失了最后几个更新操作，也可以重做整个写过程。如果数据量非常大，一个优化点是采用混合方案，每进行 N 个异步写操作则进行一次同步写，如果期间发生了崩溃，重启从上一个成功的同步写操作开始即可。（同步写操作可以同时更新一个标识，描述崩溃时重启的位置）\nWriteBatch 可以作为异步写操作的替代品，多个更新操作可以放到同一个 WriteBatch 中然后通过一次同步写(即 write_options.sync = true)一起落盘。\n并发 一个数据库同时只能被一个进程打开。leveldb 会从操作系统获取一把锁来防止多进程同时打开同一个数据库。在单个进程中，同一个 leveldb::DB 对象可以被多个并发线程安全地使用，也就是说，不同的线程可以在不需要任何外部同步原语的情况下，写入、获取迭代器或者调用 Get（leveldb 实现会确保所需的同步）。但是其它对象，比如 Iterator 或者 WriteBatch 需要外部自己提供同步保证，如果两个线程共享此类对象，需要使用自己的锁进行互斥访问。具体见对应的头文件。\n迭代数据库 下面的用例展示了如何打印数据库中全部的 (key, value) 对。\nleveldb::Iterator* it = db-NewIterator(leveldb::ReadOptions()); for (it-SeekToFirst(); it-Valid(); it-Next()) { cout  it-key().ToString()  \": \"  it-value().ToString()  endl; } assert(it-status().ok()); // Check for any errors found during the scan delete it; 下面的用例展示了如何打印 [start, limit) 范围内的数据：\nfor (it-Seek(start); it-Valid() \u0026\u0026 it-key().ToString()  limit; it-Next()) { ... } 当然你也可以反向遍历（注意，反向遍历可能要比正向遍历慢一些，具体见前面的读性能基准测试）：\nfor (it-SeekToLast(); it-Valid(); it-Prev()) { ... } 快照 快照提供了针对整个 KV 存储的一致性只读视图（consistent read-only views）。ReadOptions::snapshot 不为 null 表示读操作应该作用在 DB 的某个特定版本上；若为 null，则读操作将会作用在当前版本的一个隐式的快照上。\n快照通过调用 DB::GetSnapshot() 方法创建：\nleveldb::ReadOptions options; options.snapshot = db-GetSnapshot(); ... apply some updates to db ... leveldb::Iterator* iter = db-NewIterator(options); ... read using iter to view the state when the snapshot was created ... delete iter; db-ReleaseSnapshot(options.snapshot); 注意，当一个快照不再使用的时候，应该通过 DB::ReleaseSnapshot 接口进行释放。\nSlice it-key() 和 it-value() 调用返回的值是 leveldb::Slice 类型。熟悉 Go 的同学应该对 Slice 不陌生。Slice 是一个简单的数据结构，包含一个长度和一个指向外部字节数组的指针，返回一个 Slice 比返回一个 std::string 更高效，因为不需要隐式地拷贝大量的 keys 和 values。另外，leveldb 方法不返回 \\0 截止符结尾的 C 风格字符串，因为 leveldb 的 keys 和 values 允许包含 \\0 字节。\nC++ 风格的 string 和 C 风格的空字符结尾的字符串很容易转换为一个 Slice：\nleveldb::Slice s1 = \"hello\"; std::string str(\"world\"); leveldb::Slice s2 = str; 一个 Slice 也很容易转换回 C++ 风格的字符串：\nstd::string str = s1.ToString(); assert(str == std::string(\"hello\")); 在使用 Slice 时要小心，要由调用者来确保 Slice 指向的外部字节数组有效。例如，下面的代码就有 bug ：\nleveldb::Slice slice; if (...) { std::string str = ...; slice = str; } Use(slice); 当 if 语句结束的时候，str 将会被销毁，Slice 的指向也随之消失，后面再用就会出问题。\n比较器（Comparator） 前面的例子中用的都是默认的比较函数，即逐字节按字典序比较。你可以自定义比较函数，然后在打开数据库的时候传入，只需要继承 leveldb::Comparator 然后定义相关逻辑即可，下面是一个例子：\nclass TwoPartComparator : public leveldb::Comparator { public: // Three-way comparison function:  // if a  // if a  b: positive result  // else: zero result  int Compare(const leveldb::Slice\u0026 a, const leveldb::Slice\u0026 b) const { int a1, a2, b1, b2; ParseKey(a, \u0026a1, \u0026a2); ParseKey(b, \u0026b1, \u0026b2); if (a1  b1) return -1; if (a1  b1) return +1; if (a2  b2) return -1; if (a2  b2) return +1; return 0; } // Ignore the following methods for now:  const char* Name() const { return \"TwoPartComparator\"; } void FindShortestSeparator(std::string*, const leveldb::Slice\u0026) const {} void FindShortSuccessor(std::string*) const {} }; 在打开数据库的时候，传入上面定义的比较器：\n// 实例化比较器 TwoPartComparator cmp; leveldb::DB* db; leveldb::Options options; options.create_if_missing = true; // 将比较器赋值给 options.comparator options.comparator = \u0026cmp; // 打开数据库 leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", \u0026db); ... 向后兼容性 比较器 Name() 方法返回的结果在创建数据库时会被绑定到数据库上，后续每次打开都会进行检查，如果名称改了，对 leveldb::DB::Open 的调用就会失败。因此，当且仅当在新的 key 格式和比较函数与已有的数据库不兼容而且已有数据不再被需要的时候再修改比较器名称。总而言之，一个数据库只能对应一个比较器，而且比较器由名字唯一确定，一旦修改名称或比较器逻辑，数据库的操作逻辑统统会出错，毕竟 leveldb 是一个有序的 KV 存储。\n如果非要修改比较逻辑呢？你可以根据预先规划一点一点的演进你的 key 格式，注意，事先的演进规划非常重要。比如，你可以在每个 key 的结尾存储一个版本号（大多数场景，一个字节足矣），当你想要切换到新的 key 格式的时候（比如上面的例子 TwoPartComparator 处理的 keys 中），那么需要做的是：\n 保持相同的比较器名称 递增新 keys 的版本号 修改比较器函数以让其使用版本号来决定如何进行排序  性能调优 通过修改 include/leveldb/options.h 中定义的类型的默认值来对 leveldb 的性能进行调优。\nBlock 大小 leveldb 把相邻的 keys 组织在同一个 block 中(具体见后续文章针对 sstable 文件格式的描述)，block 是数据在内存和持久化存储传输之间的基本单位。默认的未压缩 block 大小大约为 4KB，经常批量扫描大量数据的应用可能希望把这个值调大，而针对数据只做“点读”的应用则可能希望这个值小一些。但是，没有证据表明该值小于 1KB 或者大于几个 MB 的时候性能会表现得更好。另外要注意的是，使用较大的 block size，压缩效率会更高效。\n压缩 每个 block 在写入持久化存储之前都会被单独压缩。压缩默认是开启的，因为默认的压缩算法非常快，而且对于不可压缩的数据会自动关闭压缩功能，极少有场景会让用户想要完全关闭压缩功能，除非基准测试显示关闭压缩会显著改善性能。按照下面方式即可关闭压缩功能：\nleveldb::Options options; options.compression = leveldb::kNoCompression; ... leveldb::DB::Open(options, name, ...) .... 缓存 数据库的内容存储在文件系统中的一组文件中，每个文件都存储了一系列压缩后的 blocks，如果 options.block_cache 是非 NULL，则用于缓存经常使用的已解压缩 block 内容。\n#include \"leveldb/cache.h\" leveldb::Options options; options.block_cache = leveldb::NewLRUCache(100 * 1048576); // 100MB cache leveldb::DB* db; leveldb::DB::Open(options, name, \u0026db); ... use the db ... delete db delete options.block_cache; 注意 cache 保存的是未压缩的数据，因此应该根据应用程序所需的数据大小来设置它的大小。（已压缩数据的缓存工作交给操作系统的 buffer cache 或者用户自定义的 Env 实现去干。）\n当执行一个大块数据读操作时，应用程序可能想要取消缓存功能，这样读进来的大块数据就不会导致当前 cache 中的大部分数据被置换出去，我们可以为它提供一个单独的 iterator 来达到该目的：\nleveldb::ReadOptions options; options.fill_cache = false; leveldb::Iterator* it = db-NewIterator(options); for (it-SeekToFirst(); it-Valid(); it-Next()) { ... } Key 的布局 注意，磁盘传输和缓存的单位都是一个 block，相邻的 keys（已排序）总在同一个 block 中，因此应用可以通过把需要一起访问的 keys 放在一起，同时把不经常使用的 keys 放到一个独立的键空间区域来提升性能。\n举个例子，假设我们正基于 leveldb 实现一个简单的文件系统。我们打算存储到这个文件系统的数据类型如下：\nfilename - permission-bits, length, list of file_block_ids file_block_id - data 我们可以给上面表示 filename 的 key 增加一个字符前缀，例如 ‘/'，然后给表示 file_block_id 的 key 增加另一个不同的前缀，例如 ‘0’，这样这些不同用途的 key 就具有了各自独立的键空间区域，扫描元数据的时候我们就不用读取和缓存大块文件内容数据了。\n过滤器 鉴于 leveldb 数据在磁盘上的组织形式，一次 Get() 调用可能涉及多次磁盘读操作，可配置的 FilterPolicy 机制可以用来大幅减少磁盘读次数。\nleveldb::Options options; // 设置启用基于布隆过滤器的过滤策略 options.filter_policy = NewBloomFilterPolicy(10); leveldb::DB* db; // 用该设置打开数据库 leveldb::DB::Open(options, \"/tmp/testdb\", \u0026db); ... use the database ... delete db; delete options.filter_policy; 上述代码将一个基于布隆过滤器的过滤策略与数据库进行了关联，基于布隆过滤器的过滤方式依赖于如下事实，在内存中保存每个 key 的部分位（在上面例子中是 10 位，因为我们传给 NewBloomFilterPolicy 的参数是 10），这个过滤器将会使得 Get() 调用中非必须的磁盘读操作大约减少 100 倍，每个 key 用于过滤器的位数增加将会进一步减少读磁盘次数，当然也会占用更多内存空间。我们推荐数据集无法全部放入内存同时又存在大量随机读的应用设置一个过滤器策略。\n如果你在使用自定义的比较器，应该确保你在用的过滤器策略与你的比较器兼容。举个例子，如果一个比较器在比较 key 的时候忽略结尾的空格，那么 NewBloomFilterPolicy 一定不能与此比较器共存。相反，应用应该提供一个自定义的过滤器策略，而且它也应该忽略 key 的尾部空格，示例如下：\nclass CustomFilterPolicy : public leveldb::FilterPolicy { private: FilterPolicy* builtin_policy_; public: CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(10)) {} ~CustomFilterPolicy() { delete builtin_policy_; } const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; } void CreateFilter(const Slice* keys, int n, std::string* dst) const { // Use builtin bloom filter code after removing trailing spaces  std::vectorSlice trimmed(n); for (int i = 0; i  n; i++) { trimmed[i] = RemoveTrailingSpaces(keys[i]); } return builtin_policy_-CreateFilter(\u0026trimmed[i], n, dst); } }; 当然也可以自己提供非基于布隆过滤器的过滤器策略，具体见 leveldb/filter_policy.h。\n校验和（Checksums） leveldb 将校验和与它存储在文件系统中的所有数据进行关联，对于这些校验和，有两个独立的控制：\nReadOptions::verify_checksums 可以设置为 true，以强制对所有从文件系统读取的数据进行校验。默认为 false，即，不会进行这样的校验。\nOptions::paranoid_checks 在数据库打开之前设置为 true ，以使得数据库一旦检测到数据损毁立即报错。根据数据库损坏的部位，报错可能是在打开数据库后，也可能是在后续执行某个操作的时候。该配置默认是关闭状态，即，持久化存储部分损坏数据库也能继续使用。\n如果数据库损坏了(当开启 Options::paranoid_checks 的时候可能就打不开了)，leveldb::RepairDB() 函数可以用于对尽可能多的数据进行修复。\n近似空间大小 GetApproximateSizes 方法用于获取一个或多个键区间占据的文件系统近似大小(单位, 字节)\nleveldb::Range ranges[2]; ranges[0] = leveldb::Range(\"a\", \"c\"); ranges[1] = leveldb::Range(\"x\", \"z\"); uint64_t sizes[2]; db-GetApproximateSizes(ranges, 2, sizes); 上述代码结果是，size[0] 保存 [a..c) 区间对应的文件系统大致字节数。size[1] 保存 [x..z) 键区间对应的文件系统大致字节数。\n环境变量 由 leveldb 发起的全部文件操作以及其它的操作系统调用最后都会被路由给一个 leveldb::Env 对象。用户也可以提供自己的 Env 实现以达到更好的控制。比如，如果应用程序想要针对 leveldb 的文件 IO 引入一个人工延迟以限制 leveldb 对同一个系统中其它应用的影响：\n// 定制自己的 Env class SlowEnv : public leveldb::Env { ... implementation of the Env interface ... }; SlowEnv env; leveldb::Options options; // 用定制的 Env 打开数据库 options.env = \u0026env; Status s = leveldb::DB::Open(options, ...); 可移植 如果某个特定平台提供 leveldb/port/port.h 导出的类型/方法/函数实现，那么 leveldb 可以被移植到该平台上，更多细节见 leveldb/port/port_example.h。\n另外，新平台可能还需要一个新的默认的 leveldb::Env 实现。具体可参考 leveldb/util/env_posix.h 实现。\n",
  "wordCount" : "1231",
  "inLanguage": "en",
  "datePublished": "2020-11-30T00:00:00Z",
  "dateModified": "2020-11-30T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "多颗糖"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tangwz.com/post/leveldb-index/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "多颗糖",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tangwz.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tangwz.com/" accesskey="h" title="多颗糖 (Alt + H)">多颗糖</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tangwz.com/page/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tangwz.com/">Home</a>&nbsp;»&nbsp;<a href="https://tangwz.com/post/">Posts</a></div>
    <h1 class="post-title">
      Leveldb 基本介绍和使用指南
    </h1>
    <div class="post-meta"><span title='2020-11-30 00:00:00 +0000 UTC'>November 30, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;多颗糖&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/post/leveldb-index.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" aria-label="基本介绍">基本介绍</a><ul>
                        
                <li>
                    <a href="#%e7%89%b9%e6%80%a7" aria-label="特性">特性</a></li>
                <li>
                    <a href="#%e5%b1%80%e9%99%90%e6%80%a7" aria-label="局限性">局限性</a></li>
                <li>
                    <a href="#%e6%80%a7%e8%83%bd" aria-label="性能">性能</a><ul>
                        
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae" aria-label="配置">配置</a></li>
                <li>
                    <a href="#%e5%86%99%e6%80%a7%e8%83%bd" aria-label="写性能">写性能</a></li>
                <li>
                    <a href="#%e8%af%bb%e6%80%a7%e8%83%bd" aria-label="读性能">读性能</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bc%96%e8%af%91" aria-label="编译">编译</a></li>
                <li>
                    <a href="#%e5%a4%b4%e6%96%87%e4%bb%b6%e4%bb%8b%e7%bb%8d" aria-label="头文件介绍">头文件介绍</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8" aria-label="使用">使用</a><ul>
                        
                <li>
                    <a href="#%e6%89%93%e5%bc%80%e4%b8%80%e4%b8%aa%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="打开一个数据库">打开一个数据库</a></li>
                <li>
                    <a href="#status" aria-label="Status">Status</a></li>
                <li>
                    <a href="#%e5%85%b3%e9%97%ad%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="关闭数据库">关闭数据库</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%af%bb%e5%86%99" aria-label="数据库读写">数据库读写</a></li>
                <li>
                    <a href="#%e5%8e%9f%e5%ad%90%e6%9b%b4%e6%96%b0" aria-label="原子更新">原子更新</a></li>
                <li>
                    <a href="#%e5%90%8c%e6%ad%a5%e5%86%99%e6%93%8d%e4%bd%9c" aria-label="同步写操作">同步写操作</a></li>
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91" aria-label="并发">并发</a></li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="迭代数据库">迭代数据库</a></li>
                <li>
                    <a href="#%e5%bf%ab%e7%85%a7" aria-label="快照">快照</a></li>
                <li>
                    <a href="#slice" aria-label="Slice">Slice</a></li>
                <li>
                    <a href="#%e6%af%94%e8%be%83%e5%99%a8comparator" aria-label="比较器（Comparator）">比较器（Comparator）</a><ul>
                        
                <li>
                    <a href="#%e5%90%91%e5%90%8e%e5%85%bc%e5%ae%b9%e6%80%a7" aria-label="向后兼容性">向后兼容性</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%a7%e8%83%bd%e8%b0%83%e4%bc%98" aria-label="性能调优">性能调优</a><ul>
                        
                <li>
                    <a href="#block-%e5%a4%a7%e5%b0%8f" aria-label="Block 大小">Block 大小</a></li>
                <li>
                    <a href="#%e5%8e%8b%e7%bc%a9" aria-label="压缩">压缩</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98" aria-label="缓存">缓存</a></li>
                <li>
                    <a href="#key-%e7%9a%84%e5%b8%83%e5%b1%80" aria-label="Key 的布局">Key 的布局</a></li>
                <li>
                    <a href="#%e8%bf%87%e6%bb%a4%e5%99%a8" aria-label="过滤器">过滤器</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a0%a1%e9%aa%8c%e5%92%8cchecksums" aria-label="校验和（Checksums）">校验和（Checksums）</a></li>
                <li>
                    <a href="#%e8%bf%91%e4%bc%bc%e7%a9%ba%e9%97%b4%e5%a4%a7%e5%b0%8f" aria-label="近似空间大小">近似空间大小</a></li>
                <li>
                    <a href="#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" aria-label="环境变量">环境变量</a></li>
                <li>
                    <a href="#%e5%8f%af%e7%a7%bb%e6%a4%8d" aria-label="可移植">可移植</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>leveldb 是一个持久化的 key/value 存储，key 和 value 都是任意的字节数组(byte arrays)，并且在存储时，key 值根据用户指定的 comparator 函数进行排序。</p>
<p>作者是大名鼎鼎的 Jeff Dean 和 Sanjay Ghemawat.</p>
<h1 id="基本介绍">基本介绍<a hidden class="anchor" aria-hidden="true" href="#基本介绍">#</a></h1>
<h2 id="特性">特性<a hidden class="anchor" aria-hidden="true" href="#特性">#</a></h2>
<ul>
<li>keys 和 values 是任意的字节数组。</li>
<li>数据按 key 值排序存储。</li>
<li>调用者可以提供一个自定义的比较函数来重写排序顺序。</li>
<li>提供基本的 <code>Put(key,value)</code>，<code>Get(key)</code>，<code>Delete(key)</code> 操作。</li>
<li>多个更改可以在一个原子批处理中生效。</li>
<li>用户可以创建一个瞬时快照(snapshot)，以获得数据的一致性视图。</li>
<li>在数据上支持向前和向后迭代。</li>
<li>使用 Snappy 压缩库对数据进行自动压缩</li>
<li>与外部交互的操作都被抽象成了接口(如文件系统操作等)，因此用户可以根据接口自定义的操作系统交互。</li>
</ul>
<h2 id="局限性">局限性<a hidden class="anchor" aria-hidden="true" href="#局限性">#</a></h2>
<ul>
<li>这不是一个 SQL 数据库，它没有关系数据模型，不支持 SQL 查询，也不支持索引。</li>
<li>同时只能有一个进程(可能是具有多线程的进程)访问一个特定的数据库。</li>
<li>该程序库没有内置的 client-server 支持，有需要的用户必须自己封装。</li>
</ul>
<h2 id="性能">性能<a hidden class="anchor" aria-hidden="true" href="#性能">#</a></h2>
<p>下面是运行 db_bench 程序的性能报告。结果有一些噪声(noisy)，但足以得到一个大概的性能估计。</p>
<h3 id="配置">配置<a hidden class="anchor" aria-hidden="true" href="#配置">#</a></h3>
<p>我们使用的是一个有一百万个条目的数据库，其中每个条目的 key 是 16 字节，value 是 100 字节，value 压缩后大约是原始大小的一半，测试配置如下:</p>
<pre tabindex="0"><code>LevelDB:    version 1.1
Date:       Sun May  1 12:11:26 2011
CPU:        4 x Intel(R) Core(TM)2 Quad CPU    Q6600  @ 2.40GHz
CPUCache:   4096 KB
Keys:       16 bytes each
Values:     100 bytes each (50 bytes after compression)
Entries:    1000000
Raw Size:   110.6 MB (estimated)
File Size:  62.9 MB (estimated)
</code></pre><p>具体 benchmark 源码见：https://github.com/google/leveldb/blob/master/benchmarks/db_bench.cc</p>
<h3 id="写性能">写性能<a hidden class="anchor" aria-hidden="true" href="#写性能">#</a></h3>
<p>“fill” 基准测试创建了一个全新的数据库，以顺序(下面的 “fillseq”)或者随机(下面的 “fillrandom”)方式写入。</p>
<p>“fillsync” 基准测试每次写操作都将数据从操作系统刷到磁盘; 其它的操作会将数据保存在系统中一段时间。</p>
<p>“overwrite” 基准测试做随机写，会更新数据库中已有的 key。</p>
<pre tabindex="0"><code>fillseq      :       1.765 micros/op;   62.7 MB/s
fillsync     :     268.409 micros/op;    0.4 MB/s (10000 ops)
fillrandom   :       2.460 micros/op;   45.0 MB/s
overwrite    :       2.380 micros/op;   46.5 MB/s
</code></pre><p>上述每个 “op” 对应一个 key/value 对的写操作。即，一个随机写基准测试<strong>每秒约四十万次</strong>写操作(1,000,000/2.46)。</p>
<p>每个 “fillsync” 操作耗时(大约 0.3 毫秒)少于一次磁盘搜索(大约 10 毫秒)。我们怀疑这是因为磁盘本身将更新操作缓存到了内存，并在数据落盘之前返回响应。这可能是安全的，也可能是不安全的，取决于硬盘是否有足够的电力在断电时保存其内存。</p>
<h3 id="读性能">读性能<a hidden class="anchor" aria-hidden="true" href="#读性能">#</a></h3>
<p>我们列出了正向顺序读、反向顺序读以及随机查询的性能。注意，基础测试创建的数据库很小，因此该性能报告描述的是 leveldb 的全部数据集能放入到内存的场景，如果数据不在操作系统缓存中，读取的性能消耗主要在于一到两次的磁盘搜索，写性能基本不会受数据集是否能放入内存的影响。</p>
<pre tabindex="0"><code>readrandom  : 16.677 micros/op;  (approximately 60,000 reads per second)
readseq     :  0.476 micros/op;  232.3 MB/s
readreverse :  0.724 micros/op;  152.9 MB/s
</code></pre><p>leveldb 会在后台 compact 其底层存储的数据来改善读性能。上面列出的结果是在大量随机写操作后得出的，经过 compact 后的性能指标（通常是指动出发的）会更好：</p>
<pre tabindex="0"><code>readrandom  : 11.602 micros/op;  (approximately 85,000 reads per second)
readseq     :  0.423 micros/op;  261.8 MB/s
readreverse :  0.663 micros/op;  166.9 MB/s
</code></pre><p>读操作消耗高的成本一部分来自于重复解压从磁盘读取的数据库，如果我们能够提供足够的缓存给 leveldb 来将解压后的数据保存在内存中，读性能会进一步改善：</p>
<pre tabindex="0"><code>readrandom  : 9.775 micros/op;  (approximately 100,000 reads per second before compaction)
readrandom  : 5.215 micros/op;  (approximately 190,000 reads per second after compaction)
</code></pre><h2 id="编译">编译<a hidden class="anchor" aria-hidden="true" href="#编译">#</a></h2>
<p>项目支持 Cmake 开箱即用。编译非常简单：</p>
<pre tabindex="0"><code>git clone --recurse-submodules https://github.com/google/leveldb.git
mkdir -p build &amp;&amp; cd build
cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .
</code></pre><h2 id="头文件介绍">头文件介绍<a hidden class="anchor" aria-hidden="true" href="#头文件介绍">#</a></h2>
<p>leveldb 对外暴露的接口都在 <code>include/*.h</code> 中，用户不应该依赖任何其它目录下的头文件，这些内部 API 可能会在没有警告的情况下被改变。</p>
<ul>
<li><code>include/leveldb/db.h</code>：主要的 DB 接口，从这开始。</li>
<li><code>include/leveldb/options.h</code>： 控制数据库的行为，也控制当个读和写的行为。</li>
<li><code>include/leveldb/comparator.h</code>： 比较函数的抽象。如果你只想对 key 逐字节比较，可以直接使用默认的比较器。如果你想要自定义排序（例如处理不同的字符编码、解码等），可以实现自己的比较器。</li>
<li><code>include/leveldb/iterator.h</code>：迭代数据的接口，你可以从一个 DB 对象获取到一个迭代器。</li>
<li><code>include/leveldb/write_batch.h</code>：原子地将多个操作应用到数据库。</li>
<li><code>include/leveldb/slice.h</code>：类似 string，维护着指向字节数组的指针和对应的长度。</li>
<li><code>include/leveldb/status.h</code>：许多公共接口都会返回 <code>Status</code>，用于报告成功或各种错误。</li>
<li><code>include/leveldb/env.h</code>：操作系统环境的抽象，该接口的 posix 实现位于 <code>util/env_posix.cc</code> 中.</li>
<li><code>include/leveldb/table.h, include/leveldb/table_builder.h</code>：底层的模块，大多数用户可能不会直接用到。</li>
</ul>
<h1 id="使用">使用<a hidden class="anchor" aria-hidden="true" href="#使用">#</a></h1>
<p>编译以后我们可以使用 cmake 来小试牛刀，首先在 leveldb 目录创建文件夹 <code>app/</code> 来单独存放我们的练习文件，然后创建一个文件例如：<code>main.cc</code>，接着我们修改 <code>CMakeLists.txt</code> 文件，增加一行：</p>
<pre tabindex="0"><code>  347   if(NOT BUILD_SHARED_LIBS)
+ 348     leveldb_test(&quot;app/main.cc&quot;)
  349     leveldb_test(&quot;db/autocompact_test.cc&quot;)
</code></pre><p>编写完代码后，只需回到 <code>build/</code> 目录执行：</p>
<pre tabindex="0"><code>cmake .. &amp;&amp; cmake --build .
</code></pre><p>即可编译出 <code>main</code> 可执行文件。</p>
<h2 id="打开一个数据库">打开一个数据库<a hidden class="anchor" aria-hidden="true" href="#打开一个数据库">#</a></h2>
<p>leveldb 数据库都有一个名字，该名字对应文件系统上的一个目录，该数据库内容全都存在该目录下。下面的例子显示了如何打开一个数据库，必要时创建数据库：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cassert&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;leveldb/db.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    leveldb<span style="color:#f92672">::</span>DB<span style="color:#f92672">*</span> db;
    leveldb<span style="color:#f92672">::</span>Options options;
    options.create_if_missing <span style="color:#f92672">=</span> true;
    leveldb<span style="color:#f92672">::</span>Status status <span style="color:#f92672">=</span> leveldb<span style="color:#f92672">::</span>DB<span style="color:#f92672">::</span>Open(options, <span style="color:#e6db74">&#34;/tmp/testdb&#34;</span>, <span style="color:#f92672">&amp;</span>db);
    assert(status.ok());
}
</code></pre></div><p>如果你想在数据库已存在的时候触发一个异常，将下面这行配置加到 <code>leveldb::DB::Open</code> 调用之前：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">options.error_if_exists <span style="color:#f92672">=</span> true;
</code></pre></div><h2 id="status">Status<a hidden class="anchor" aria-hidden="true" href="#status">#</a></h2>
<p>你也许注意到上面的 <code>leveldb::Status</code> 返回类型，leveldb 中大部分方法在遇到错误的时候会返回该类型的值，你可以检查它是否 ok，然后打印相关的错误信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">leveldb<span style="color:#f92672">::</span>Status s <span style="color:#f92672">=</span> ...;
<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>s.ok()) cerr <span style="color:#f92672">&lt;&lt;</span> s.ToString() <span style="color:#f92672">&lt;&lt;</span> endl;
</code></pre></div><p><em>尝试输出数据库已存在的错误信息吧！</em></p>
<h2 id="关闭数据库">关闭数据库<a hidden class="anchor" aria-hidden="true" href="#关闭数据库">#</a></h2>
<p>当数据库不再使用的时候，像下面这样直接删除数据库对象就可以了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">delete</span> db;
</code></pre></div><p>是不是很简单？后面我们具体源码分析时会看到，<code>DB</code> 类是基于 RAII 实现的，在 delete 时会触发析构函数自动清理。</p>
<h2 id="数据库读写">数据库读写<a hidden class="anchor" aria-hidden="true" href="#数据库读写">#</a></h2>
<p>leveldb 提供了 <code>Put</code>、<code>Delete</code> 和 <code>Get</code> 方法来修改/查询数据库，下面的代码展示了将 key1 对应的 value 移动到 key2 下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>string value;
leveldb<span style="color:#f92672">::</span>Status s <span style="color:#f92672">=</span> db<span style="color:#f92672">-&gt;</span>Get(leveldb<span style="color:#f92672">::</span>ReadOptions(), key1, <span style="color:#f92672">&amp;</span>value);
<span style="color:#66d9ef">if</span> (s.ok()) s <span style="color:#f92672">=</span> db<span style="color:#f92672">-&gt;</span>Put(leveldb<span style="color:#f92672">::</span>WriteOptions(), key2, value);
<span style="color:#66d9ef">if</span> (s.ok()) s <span style="color:#f92672">=</span> db<span style="color:#f92672">-&gt;</span>Delete(leveldb<span style="color:#f92672">::</span>WriteOptions(), key1);
</code></pre></div><h2 id="原子更新">原子更新<a hidden class="anchor" aria-hidden="true" href="#原子更新">#</a></h2>
<p>需要注意的是，在上一小节中如果进程在 <code>Put</code> key2 后 <code>Delete</code> key1 之前挂了，那么同样的 value 将被存储在多个 key 下。可以通过使用 <code>WriteBatch</code> 原子地应用一组操作来避免类似的问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;leveldb/write_batch.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>...
std<span style="color:#f92672">::</span>string value;
leveldb<span style="color:#f92672">::</span>Status s <span style="color:#f92672">=</span> db<span style="color:#f92672">-&gt;</span>Get(leveldb<span style="color:#f92672">::</span>ReadOptions(), key1, <span style="color:#f92672">&amp;</span>value);
<span style="color:#66d9ef">if</span> (s.ok()) {
  leveldb<span style="color:#f92672">::</span>WriteBatch batch;
  batch.Delete(key1);
  batch.Put(key2, value);
  s <span style="color:#f92672">=</span> db<span style="color:#f92672">-&gt;</span>Write(leveldb<span style="color:#f92672">::</span>WriteOptions(), <span style="color:#f92672">&amp;</span>batch);
}
</code></pre></div><p><code>WriteBatch</code> 保存着一系列将被应用到数据库的操作，这些操作会按照添加的顺序依次被执行。注意，我们先执行 <code>Delete</code> 后执行 <code>Put</code>，这样如果 key1 和 key2 一样的情况下我们也不会错误地丢失数据。</p>
<p>除了原子性，<code>WriteBatch</code> 也能加速更新过程，因为可以把一大批独立的操作添加到同一个 batch 中然后一次性执行。</p>
<h2 id="同步写操作">同步写操作<a hidden class="anchor" aria-hidden="true" href="#同步写操作">#</a></h2>
<p>默认情况下，leveldb 每个写操作都是异步的：进程把要写的内容丢给操作系统后立即返回，从操作系统内存到底层持久化存储的传输是异步进行的。</p>
<p>可以为某个特定的写操作打开同步标识：<code>write_options.sync = true</code>，以等到数据真正被记录到持久化存储后再返回（在 Posix 系统上，这是通过在写操作返回前调用 <code>fsync(...)</code> 或 <code>fdatasync(...)</code> 或 <code>msync(..., MS_SYNC)</code> 来实现的）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">leveldb<span style="color:#f92672">::</span>WriteOptions write_options;
write_options.sync <span style="color:#f92672">=</span> true;
db<span style="color:#f92672">-&gt;</span>Put(write_options, ...);
</code></pre></div><p>**异步写通常比同步写快 1000 倍。**异步写的缺点是，一旦机器崩溃可能会导致最后几个更新操作丢失。注意，仅仅是写进程崩溃（而非机器重启）不会造成任何损失，因为哪怕 sync 标识为 false，在进程退出之前，写操作也已经从进程内存推到了操作系统。</p>
<p>异步写通常可以安全使用。比如你要将大量的数据写入数据库，如果丢失了最后几个更新操作，也可以重做整个写过程。如果数据量非常大，一个优化点是采用混合方案，每进行 N 个异步写操作则进行一次同步写，如果期间发生了崩溃，重启从上一个成功的同步写操作开始即可。（同步写操作可以同时更新一个标识，描述崩溃时重启的位置）</p>
<p><code>WriteBatch</code> 可以作为异步写操作的替代品，多个更新操作可以放到同一个 <code>WriteBatch</code> 中然后通过一次同步写(即 <code>write_options.sync = true</code>)一起落盘。</p>
<h2 id="并发">并发<a hidden class="anchor" aria-hidden="true" href="#并发">#</a></h2>
<p>一个数据库同时只能被一个进程打开。leveldb 会从操作系统获取一把锁来防止多进程同时打开同一个数据库。在单个进程中，同一个 leveldb::DB 对象可以被多个并发线程安全地使用，也就是说，不同的线程可以在不需要任何外部同步原语的情况下，写入、获取迭代器或者调用 <code>Get</code>（leveldb 实现会确保所需的同步）。但是其它对象，比如 <code>Iterator</code> 或者 <code>WriteBatch</code> 需要外部自己提供同步保证，如果两个线程共享此类对象，需要使用自己的锁进行互斥访问。具体见对应的头文件。</p>
<h2 id="迭代数据库">迭代数据库<a hidden class="anchor" aria-hidden="true" href="#迭代数据库">#</a></h2>
<p>下面的用例展示了如何打印数据库中全部的 (key, value) 对。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">leveldb<span style="color:#f92672">::</span>Iterator<span style="color:#f92672">*</span> it <span style="color:#f92672">=</span> db<span style="color:#f92672">-&gt;</span>NewIterator(leveldb<span style="color:#f92672">::</span>ReadOptions());
<span style="color:#66d9ef">for</span> (it<span style="color:#f92672">-&gt;</span>SeekToFirst(); it<span style="color:#f92672">-&gt;</span>Valid(); it<span style="color:#f92672">-&gt;</span>Next()) {
  cout <span style="color:#f92672">&lt;&lt;</span> it<span style="color:#f92672">-&gt;</span>key().ToString() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;: &#34;</span>  <span style="color:#f92672">&lt;&lt;</span> it<span style="color:#f92672">-&gt;</span>value().ToString() <span style="color:#f92672">&lt;&lt;</span> endl;
}
assert(it<span style="color:#f92672">-&gt;</span>status().ok());  <span style="color:#75715e">// Check for any errors found during the scan
</span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> it;
</code></pre></div><p>下面的用例展示了如何打印 <code>[start, limit)</code> 范围内的数据：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">for</span> (it<span style="color:#f92672">-&gt;</span>Seek(start);
   it<span style="color:#f92672">-&gt;</span>Valid() <span style="color:#f92672">&amp;&amp;</span> it<span style="color:#f92672">-&gt;</span>key().ToString() <span style="color:#f92672">&lt;</span> limit;
   it<span style="color:#f92672">-&gt;</span>Next()) {
  ...
}
</code></pre></div><p>当然你也可以反向遍历（注意，反向遍历可能要比正向遍历慢一些，具体见前面的读性能基准测试）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">for</span> (it<span style="color:#f92672">-&gt;</span>SeekToLast(); it<span style="color:#f92672">-&gt;</span>Valid(); it<span style="color:#f92672">-&gt;</span>Prev()) {
  ...
}
</code></pre></div><h2 id="快照">快照<a hidden class="anchor" aria-hidden="true" href="#快照">#</a></h2>
<p>快照提供了针对整个 KV 存储的一致性只读视图（consistent read-only views）。ReadOptions::snapshot 不为 null 表示读操作应该作用在 DB 的某个特定版本上；若为 null，则读操作将会作用在当前版本的一个隐式的快照上。</p>
<p>快照通过调用 <code>DB::GetSnapshot()</code> 方法创建：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">leveldb<span style="color:#f92672">::</span>ReadOptions options;
options.snapshot <span style="color:#f92672">=</span> db<span style="color:#f92672">-&gt;</span>GetSnapshot();
... apply some updates to db ...
leveldb<span style="color:#f92672">::</span>Iterator<span style="color:#f92672">*</span> iter <span style="color:#f92672">=</span> db<span style="color:#f92672">-&gt;</span>NewIterator(options);
... read <span style="color:#66d9ef">using</span> iter to view the state when the snapshot was created ...
<span style="color:#66d9ef">delete</span> iter;
db<span style="color:#f92672">-&gt;</span>ReleaseSnapshot(options.snapshot);
</code></pre></div><p>注意，当一个快照不再使用的时候，应该通过 <code>DB::ReleaseSnapshot</code> 接口进行释放。</p>
<h2 id="slice">Slice<a hidden class="anchor" aria-hidden="true" href="#slice">#</a></h2>
<p><code>it-&gt;key()</code> 和 <code>it-&gt;value()</code> 调用返回的值是 <code>leveldb::Slice</code> 类型。熟悉 Go 的同学应该对 Slice 不陌生。Slice 是一个简单的数据结构，包含一个长度和一个指向外部字节数组的指针，返回一个 Slice 比返回一个 <code>std::string</code> 更高效，因为不需要隐式地拷贝大量的 keys 和 values。另外，leveldb 方法不返回 <code>\0</code> 截止符结尾的 C 风格字符串，因为 leveldb 的 keys 和 values 允许包含 <code>\0</code> 字节。</p>
<p>C++ 风格的 string 和 C 风格的空字符结尾的字符串很容易转换为一个 Slice：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">leveldb<span style="color:#f92672">::</span>Slice s1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;

std<span style="color:#f92672">::</span>string str(<span style="color:#e6db74">&#34;world&#34;</span>);
leveldb<span style="color:#f92672">::</span>Slice s2 <span style="color:#f92672">=</span> str;
</code></pre></div><p>一个 Slice 也很容易转换回 C++ 风格的字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>string str <span style="color:#f92672">=</span> s1.ToString();
assert(str <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>string(<span style="color:#e6db74">&#34;hello&#34;</span>));
</code></pre></div><p>在使用 Slice 时要小心，<strong>要由调用者来确保 Slice 指向的外部字节数组有效</strong>。例如，下面的代码就有 bug ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">leveldb<span style="color:#f92672">::</span>Slice slice;
<span style="color:#66d9ef">if</span> (...) {
  std<span style="color:#f92672">::</span>string str <span style="color:#f92672">=</span> ...;
  slice <span style="color:#f92672">=</span> str;
}
Use(slice);
</code></pre></div><p>当 if 语句结束的时候，str 将会被销毁，Slice 的指向也随之消失，后面再用就会出问题。</p>
<h2 id="比较器comparator">比较器（Comparator）<a hidden class="anchor" aria-hidden="true" href="#比较器comparator">#</a></h2>
<p>前面的例子中用的都是默认的比较函数，即逐字节按字典序比较。你可以自定义比较函数，然后在打开数据库的时候传入，只需要继承 <code>leveldb::Comparator</code> 然后定义相关逻辑即可，下面是一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TwoPartComparator</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> leveldb<span style="color:#f92672">::</span>Comparator {
 <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#75715e">// Three-way comparison function:
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   if a &lt; b: negative result
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   if a &gt; b: positive result
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   else: zero result
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> Compare(<span style="color:#66d9ef">const</span> leveldb<span style="color:#f92672">::</span>Slice<span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> leveldb<span style="color:#f92672">::</span>Slice<span style="color:#f92672">&amp;</span> b) <span style="color:#66d9ef">const</span> {
    <span style="color:#66d9ef">int</span> a1, a2, b1, b2;
    ParseKey(a, <span style="color:#f92672">&amp;</span>a1, <span style="color:#f92672">&amp;</span>a2);
    ParseKey(b, <span style="color:#f92672">&amp;</span>b1, <span style="color:#f92672">&amp;</span>b2);
    <span style="color:#66d9ef">if</span> (a1 <span style="color:#f92672">&lt;</span> b1) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span> (a1 <span style="color:#f92672">&gt;</span> b1) <span style="color:#66d9ef">return</span> <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span> (a2 <span style="color:#f92672">&lt;</span> b2) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span> (a2 <span style="color:#f92672">&gt;</span> b2) <span style="color:#66d9ef">return</span> <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
  }

  <span style="color:#75715e">// Ignore the following methods for now:
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;TwoPartComparator&#34;</span>; }
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FindShortestSeparator</span>(std<span style="color:#f92672">::</span>string<span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> leveldb<span style="color:#f92672">::</span>Slice<span style="color:#f92672">&amp;</span>) <span style="color:#66d9ef">const</span> {}
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FindShortSuccessor</span>(std<span style="color:#f92672">::</span>string<span style="color:#f92672">*</span>) <span style="color:#66d9ef">const</span> {}
};
</code></pre></div><p>在打开数据库的时候，传入上面定义的比较器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 实例化比较器
</span><span style="color:#75715e"></span>TwoPartComparator cmp;
leveldb<span style="color:#f92672">::</span>DB<span style="color:#f92672">*</span> db;
leveldb<span style="color:#f92672">::</span>Options options;
options.create_if_missing <span style="color:#f92672">=</span> true;
<span style="color:#75715e">// 将比较器赋值给 options.comparator
</span><span style="color:#75715e"></span>options.comparator <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>cmp;
<span style="color:#75715e">// 打开数据库
</span><span style="color:#75715e"></span>leveldb<span style="color:#f92672">::</span>Status status <span style="color:#f92672">=</span> leveldb<span style="color:#f92672">::</span>DB<span style="color:#f92672">::</span>Open(options, <span style="color:#e6db74">&#34;/tmp/testdb&#34;</span>, <span style="color:#f92672">&amp;</span>db);
...
</code></pre></div><h3 id="向后兼容性">向后兼容性<a hidden class="anchor" aria-hidden="true" href="#向后兼容性">#</a></h3>
<p>比较器 <code>Name()</code> 方法返回的结果在创建数据库时会被绑定到数据库上，后续每次打开都会进行检查，如果名称改了，对 <code>leveldb::DB::Open</code> 的调用就会失败。因此，当且仅当在新的 key 格式和比较函数与已有的数据库不兼容而且已有数据不再被需要的时候再修改比较器名称。总而言之，一个数据库只能对应一个比较器，而且比较器由名字唯一确定，一旦修改名称或比较器逻辑，数据库的操作逻辑统统会出错，毕竟 leveldb 是一个有序的 KV 存储。</p>
<p>如果非要修改比较逻辑呢？你可以根据预先规划一点一点的演进你的 key 格式，注意，事先的演进规划非常重要。比如，你可以在每个 key 的结尾存储一个版本号（大多数场景，一个字节足矣），当你想要切换到新的 key 格式的时候（比如上面的例子 <code>TwoPartComparator</code> 处理的 keys 中），那么需要做的是：</p>
<ol>
<li>保持相同的比较器名称</li>
<li>递增新 keys 的版本号</li>
<li>修改比较器函数以让其使用版本号来决定如何进行排序</li>
</ol>
<h2 id="性能调优">性能调优<a hidden class="anchor" aria-hidden="true" href="#性能调优">#</a></h2>
<p>通过修改 <code>include/leveldb/options.h</code> 中定义的类型的默认值来对 leveldb 的性能进行调优。</p>
<h3 id="block-大小">Block 大小<a hidden class="anchor" aria-hidden="true" href="#block-大小">#</a></h3>
<p>leveldb 把相邻的 keys 组织在同一个 block 中(具体见后续文章针对 sstable 文件格式的描述)，block 是数据在内存和持久化存储传输之间的基本单位。默认的未压缩 block 大小大约为 4KB，经常批量扫描大量数据的应用可能希望把这个值调大，而针对数据只做“点读”的应用则可能希望这个值小一些。但是，没有证据表明该值小于 1KB 或者大于几个 MB 的时候性能会表现得更好。另外要注意的是，使用较大的 block size，压缩效率会更高效。</p>
<h3 id="压缩">压缩<a hidden class="anchor" aria-hidden="true" href="#压缩">#</a></h3>
<p>每个 block 在写入持久化存储之前都会被单独压缩。压缩默认是开启的，因为默认的压缩算法非常快，而且对于不可压缩的数据会自动关闭压缩功能，极少有场景会让用户想要完全关闭压缩功能，除非基准测试显示关闭压缩会显著改善性能。按照下面方式即可关闭压缩功能：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">leveldb<span style="color:#f92672">::</span>Options options;
options.compression <span style="color:#f92672">=</span> leveldb<span style="color:#f92672">::</span>kNoCompression;
... leveldb<span style="color:#f92672">::</span>DB<span style="color:#f92672">::</span>Open(options, name, ...) ....
</code></pre></div><h3 id="缓存">缓存<a hidden class="anchor" aria-hidden="true" href="#缓存">#</a></h3>
<p>数据库的内容存储在文件系统中的一组文件中，每个文件都存储了一系列压缩后的 blocks，如果 <code>options.block_cache</code> 是非 NULL，则用于缓存经常使用的已解压缩 block 内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;leveldb/cache.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
leveldb<span style="color:#f92672">::</span>Options options;
options.block_cache <span style="color:#f92672">=</span> leveldb<span style="color:#f92672">::</span>NewLRUCache(<span style="color:#ae81ff">100</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1048576</span>);  <span style="color:#75715e">// 100MB cache
</span><span style="color:#75715e"></span>leveldb<span style="color:#f92672">::</span>DB<span style="color:#f92672">*</span> db;
leveldb<span style="color:#f92672">::</span>DB<span style="color:#f92672">::</span>Open(options, name, <span style="color:#f92672">&amp;</span>db);
... use the db ...
<span style="color:#66d9ef">delete</span> db
<span style="color:#66d9ef">delete</span> options.block_cache;
</code></pre></div><p>注意 cache 保存的是未压缩的数据，因此应该根据应用程序所需的数据大小来设置它的大小。（已压缩数据的缓存工作交给操作系统的 buffer cache 或者用户自定义的 <code>Env</code> 实现去干。）</p>
<p>当执行一个大块数据读操作时，应用程序可能想要取消缓存功能，这样读进来的大块数据就不会导致当前 cache 中的大部分数据被置换出去，我们可以为它提供一个单独的 iterator 来达到该目的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">leveldb<span style="color:#f92672">::</span>ReadOptions options;
options.fill_cache <span style="color:#f92672">=</span> false;
leveldb<span style="color:#f92672">::</span>Iterator<span style="color:#f92672">*</span> it <span style="color:#f92672">=</span> db<span style="color:#f92672">-&gt;</span>NewIterator(options);
<span style="color:#66d9ef">for</span> (it<span style="color:#f92672">-&gt;</span>SeekToFirst(); it<span style="color:#f92672">-&gt;</span>Valid(); it<span style="color:#f92672">-&gt;</span>Next()) {
  ...
}
</code></pre></div><h3 id="key-的布局">Key 的布局<a hidden class="anchor" aria-hidden="true" href="#key-的布局">#</a></h3>
<p>注意，磁盘传输和缓存的单位都是一个 block，相邻的 keys（已排序）总在同一个 block 中，因此应用可以通过把需要一起访问的 keys 放在一起，同时把不经常使用的 keys 放到一个独立的键空间区域来提升性能。</p>
<p>举个例子，假设我们正基于 leveldb 实现一个简单的文件系统。我们打算存储到这个文件系统的数据类型如下：</p>
<pre tabindex="0"><code>filename -&gt; permission-bits, length, list of file_block_ids
file_block_id -&gt; data
</code></pre><p>我们可以给上面表示 filename 的 key 增加一个字符前缀，例如 &lsquo;/'，然后给表示 file_block_id 的 key 增加另一个不同的前缀，例如 &lsquo;0&rsquo;，这样这些不同用途的 key 就具有了各自独立的键空间区域，扫描元数据的时候我们就不用读取和缓存大块文件内容数据了。</p>
<h3 id="过滤器">过滤器<a hidden class="anchor" aria-hidden="true" href="#过滤器">#</a></h3>
<p>鉴于 leveldb 数据在磁盘上的组织形式，一次 <code>Get()</code> 调用可能涉及多次磁盘读操作，可配置的 FilterPolicy 机制可以用来大幅减少磁盘读次数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">leveldb<span style="color:#f92672">::</span>Options options;
<span style="color:#75715e">// 设置启用基于布隆过滤器的过滤策略
</span><span style="color:#75715e"></span>options.filter_policy <span style="color:#f92672">=</span> NewBloomFilterPolicy(<span style="color:#ae81ff">10</span>);
leveldb<span style="color:#f92672">::</span>DB<span style="color:#f92672">*</span> db;
<span style="color:#75715e">// 用该设置打开数据库
</span><span style="color:#75715e"></span>leveldb<span style="color:#f92672">::</span>DB<span style="color:#f92672">::</span>Open(options, <span style="color:#e6db74">&#34;/tmp/testdb&#34;</span>, <span style="color:#f92672">&amp;</span>db);
... use the database ...
<span style="color:#66d9ef">delete</span> db;
<span style="color:#66d9ef">delete</span> options.filter_policy;
</code></pre></div><p>上述代码将一个基于布隆过滤器的过滤策略与数据库进行了关联，基于布隆过滤器的过滤方式依赖于如下事实，在内存中保存每个 key 的部分位（在上面例子中是 10 位，因为我们传给 <code>NewBloomFilterPolicy</code> 的参数是 10），这个过滤器将会使得 Get() 调用中非必须的磁盘读操作大约减少 100 倍，每个 key 用于过滤器的位数增加将会进一步减少读磁盘次数，当然也会占用更多内存空间。<strong>我们推荐数据集无法全部放入内存同时又存在大量随机读的应用设置一个过滤器策略。</strong></p>
<p>如果你在使用自定义的比较器，应该确保你在用的过滤器策略与你的比较器兼容。举个例子，如果一个比较器在比较 key 的时候忽略结尾的空格，那么 <code>NewBloomFilterPolicy</code> 一定不能与此比较器共存。相反，应用应该提供一个自定义的过滤器策略，而且它也应该忽略 key 的尾部空格，示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomFilterPolicy</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> leveldb<span style="color:#f92672">::</span>FilterPolicy {
 <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  FilterPolicy<span style="color:#f92672">*</span> builtin_policy_;

 <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  CustomFilterPolicy() <span style="color:#f92672">:</span> builtin_policy_(NewBloomFilterPolicy(<span style="color:#ae81ff">10</span>)) {}
  <span style="color:#f92672">~</span>CustomFilterPolicy() { <span style="color:#66d9ef">delete</span> builtin_policy_; }

  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;IgnoreTrailingSpacesFilter&#34;</span>; }

  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">CreateFilter</span>(<span style="color:#66d9ef">const</span> Slice<span style="color:#f92672">*</span> keys, <span style="color:#66d9ef">int</span> n, std<span style="color:#f92672">::</span>string<span style="color:#f92672">*</span> dst) <span style="color:#66d9ef">const</span> {
    <span style="color:#75715e">// Use builtin bloom filter code after removing trailing spaces
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Slice<span style="color:#f92672">&gt;</span> trimmed(n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
      trimmed[i] <span style="color:#f92672">=</span> RemoveTrailingSpaces(keys[i]);
    }
    <span style="color:#66d9ef">return</span> builtin_policy_<span style="color:#f92672">-&gt;</span>CreateFilter(<span style="color:#f92672">&amp;</span>trimmed[i], n, dst);
  }
};
</code></pre></div><p>当然也可以自己提供非基于布隆过滤器的过滤器策略，具体见 <code>leveldb/filter_policy.h</code>。</p>
<h2 id="校验和checksums">校验和（Checksums）<a hidden class="anchor" aria-hidden="true" href="#校验和checksums">#</a></h2>
<p>leveldb 将校验和与它存储在文件系统中的所有数据进行关联，对于这些校验和，有两个独立的控制：</p>
<p><code>ReadOptions::verify_checksums</code> 可以设置为 true，以强制对所有从文件系统读取的数据进行校验。默认为 false，即，不会进行这样的校验。</p>
<p><code>Options::paranoid_checks</code> 在数据库打开之前设置为 true ，以使得数据库一旦检测到数据损毁立即报错。根据数据库损坏的部位，报错可能是在打开数据库后，也可能是在后续执行某个操作的时候。该配置默认是关闭状态，即，持久化存储部分损坏数据库也能继续使用。</p>
<p>如果数据库损坏了(当开启 Options::paranoid_checks 的时候可能就打不开了)，<code>leveldb::RepairDB()</code> 函数可以用于对尽可能多的数据进行修复。</p>
<h2 id="近似空间大小">近似空间大小<a hidden class="anchor" aria-hidden="true" href="#近似空间大小">#</a></h2>
<p><code>GetApproximateSizes</code> 方法用于获取一个或多个键区间占据的文件系统近似大小(单位, 字节)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">leveldb<span style="color:#f92672">::</span>Range ranges[<span style="color:#ae81ff">2</span>];
ranges[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> leveldb<span style="color:#f92672">::</span>Range(<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;c&#34;</span>);
ranges[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> leveldb<span style="color:#f92672">::</span>Range(<span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#e6db74">&#34;z&#34;</span>);
<span style="color:#66d9ef">uint64_t</span> sizes[<span style="color:#ae81ff">2</span>];
db<span style="color:#f92672">-&gt;</span>GetApproximateSizes(ranges, <span style="color:#ae81ff">2</span>, sizes);
</code></pre></div><p>上述代码结果是，size[0] 保存 [a..c) 区间对应的文件系统大致字节数。size[1] 保存 [x..z) 键区间对应的文件系统大致字节数。</p>
<h2 id="环境变量">环境变量<a hidden class="anchor" aria-hidden="true" href="#环境变量">#</a></h2>
<p>由 leveldb 发起的全部文件操作以及其它的操作系统调用最后都会被路由给一个 <code>leveldb::Env</code> 对象。用户也可以提供自己的 Env 实现以达到更好的控制。比如，如果应用程序想要针对 leveldb 的文件 IO 引入一个人工延迟以限制 leveldb 对同一个系统中其它应用的影响：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 定制自己的 Env 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SlowEnv</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> leveldb<span style="color:#f92672">::</span>Env {
  ... implementation of the Env interface ...
};

SlowEnv env;
leveldb<span style="color:#f92672">::</span>Options options;
<span style="color:#75715e">// 用定制的 Env 打开数据库
</span><span style="color:#75715e"></span>options.env <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>env;
Status s <span style="color:#f92672">=</span> leveldb<span style="color:#f92672">::</span>DB<span style="color:#f92672">::</span>Open(options, ...);
</code></pre></div><h2 id="可移植">可移植<a hidden class="anchor" aria-hidden="true" href="#可移植">#</a></h2>
<p>如果某个特定平台提供 <code>leveldb/port/port.h</code> 导出的类型/方法/函数实现，那么 leveldb 可以被移植到该平台上，更多细节见 <code>leveldb/port/port_example.h</code>。</p>
<p>另外，新平台可能还需要一个新的默认的 leveldb::Env 实现。具体可参考 <code>leveldb/util/env_posix.h</code> 实现。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tangwz.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/">分布式存储</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://tangwz.com/post/impl-basic-paxos/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Golang 实现 Paxos 分布式共识算法</span>
  </a>
  <a class="next" href="https://tangwz.com/post/disk/">
    <span class="title">Next Page »</span>
    <br>
    <span>系统设计那些事儿：硬盘 I/O</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Leveldb 基本介绍和使用指南 on twitter"
        href="https://twitter.com/intent/tweet/?text=Leveldb%20%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d%e5%92%8c%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fleveldb-index%2f&amp;hashtags=%e5%88%86%e5%b8%83%e5%bc%8f%e5%ad%98%e5%82%a8">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Leveldb 基本介绍和使用指南 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fleveldb-index%2f&amp;title=Leveldb%20%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d%e5%92%8c%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97&amp;summary=Leveldb%20%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d%e5%92%8c%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97&amp;source=https%3a%2f%2ftangwz.com%2fpost%2fleveldb-index%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Leveldb 基本介绍和使用指南 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ftangwz.com%2fpost%2fleveldb-index%2f&title=Leveldb%20%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d%e5%92%8c%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Leveldb 基本介绍和使用指南 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftangwz.com%2fpost%2fleveldb-index%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Leveldb 基本介绍和使用指南 on whatsapp"
        href="https://api.whatsapp.com/send?text=Leveldb%20%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d%e5%92%8c%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97%20-%20https%3a%2f%2ftangwz.com%2fpost%2fleveldb-index%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Leveldb 基本介绍和使用指南 on telegram"
        href="https://telegram.me/share/url?text=Leveldb%20%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d%e5%92%8c%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fleveldb-index%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://tangwz.com/">多颗糖</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
