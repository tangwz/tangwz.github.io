<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>分布式系统的核心：共识问题 | 多颗糖</title>
<meta name="keywords" content="分布式" />
<meta name="description" content="混乱的“一致性”问题 Consensus != Consistency
受翻译影响，网上很多讨论 paxos 或 raft 的博客使用“分布式一致性协议”或者“分布式一致性算法”这样的字眼，虽然在汉语中“达成共识”和“达成一致”是一个意思，但是必须要说明在这里讨论的是 consensus 问题，使用“共识”来表达更清晰一些。而 CAP 定理中的 C 和数据库 ACID 的 C 才是真正的“一致性”—— consistency 问题，尽管这两个 C 讨论的也不是同一个问题，但在这里不展开。
为了规范和清晰表达，在讨论 consensus 问题的时候统一使用“共识”一词。
注：在早些的文献中，共识（consensus）也叫做协商（agreement）。
共识问题 那么共识问题到底是什么呢？举个生活中的例子，小明和小王出去聚会，小明问：“小王，我们喝点什么吧？” 小王：“喝咖啡怎么样？” 小明：“好啊，那就来杯咖啡。”
在上面的场景中，小王提议喝一杯咖啡，小明表示同意，两人就“喝杯咖啡”这个问题达成共识，并根据这个结果采取行动。这就是生活中的共识。
在分布式系统中，共识就是系统中的多个节点对某个值达成一致。共识问题可以用数学语言来描述：一个分布式系统包含 n 个进程 {0, 1, 2,&hellip;, n-1}，每个进程都有一个初值，进程之间互相通信，设计一种算法使得尽管出现故障，进程们仍协商出某个不可撤销的最终决定值，且每次执行都满足以下三个性质：
 终止性（Termination）：所有正确的进程最终都会认同某一个值。 协定性（Agreement）：所有正确的进程认同的值都是同一个值。 完整性（Integrity），也称作有效性（Validity）：如果正确的进程都提议同一个值，那么所有处于认同状态的正确进程都选择该值。  完整性可以有一些变化，例如，一种较弱的完整性是认定值等于某些正确经常提议的值，而不必是所有进程提议的值。完整性也隐含了，最终被认同的值必定是某个节点提出过的。
为什么要达成共识？ 我们首先介绍分布式系统达成共识的动机。
在前文中，我们已经了解到分布式系统的几个主要难题：
 网络问题 时钟问题 节点故障问题  第一篇提到共识问题的文献1 来自于 lamport 的 &ldquo;Time, Clocks and the Ordering of Events in a Distributed System2&quot;，尽管它并没有明确的提出共识(consensus)或者协商(agreement)的概念。论文阐述了在分布式系统中，你无法判断事件 A 是否发生在事件 B 之前，除非 A 和 B 存在某种依赖关系。由此还引出了分布式状态机的概念。">
<meta name="author" content="多颗糖">
<link rel="canonical" href="https://tangwz.com/post/consensus/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://tangwz.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tangwz.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tangwz.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tangwz.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://tangwz.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.4" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-72128068-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="分布式系统的核心：共识问题" />
<meta property="og:description" content="混乱的“一致性”问题 Consensus != Consistency
受翻译影响，网上很多讨论 paxos 或 raft 的博客使用“分布式一致性协议”或者“分布式一致性算法”这样的字眼，虽然在汉语中“达成共识”和“达成一致”是一个意思，但是必须要说明在这里讨论的是 consensus 问题，使用“共识”来表达更清晰一些。而 CAP 定理中的 C 和数据库 ACID 的 C 才是真正的“一致性”—— consistency 问题，尽管这两个 C 讨论的也不是同一个问题，但在这里不展开。
为了规范和清晰表达，在讨论 consensus 问题的时候统一使用“共识”一词。
注：在早些的文献中，共识（consensus）也叫做协商（agreement）。
共识问题 那么共识问题到底是什么呢？举个生活中的例子，小明和小王出去聚会，小明问：“小王，我们喝点什么吧？” 小王：“喝咖啡怎么样？” 小明：“好啊，那就来杯咖啡。”
在上面的场景中，小王提议喝一杯咖啡，小明表示同意，两人就“喝杯咖啡”这个问题达成共识，并根据这个结果采取行动。这就是生活中的共识。
在分布式系统中，共识就是系统中的多个节点对某个值达成一致。共识问题可以用数学语言来描述：一个分布式系统包含 n 个进程 {0, 1, 2,&hellip;, n-1}，每个进程都有一个初值，进程之间互相通信，设计一种算法使得尽管出现故障，进程们仍协商出某个不可撤销的最终决定值，且每次执行都满足以下三个性质：
 终止性（Termination）：所有正确的进程最终都会认同某一个值。 协定性（Agreement）：所有正确的进程认同的值都是同一个值。 完整性（Integrity），也称作有效性（Validity）：如果正确的进程都提议同一个值，那么所有处于认同状态的正确进程都选择该值。  完整性可以有一些变化，例如，一种较弱的完整性是认定值等于某些正确经常提议的值，而不必是所有进程提议的值。完整性也隐含了，最终被认同的值必定是某个节点提出过的。
为什么要达成共识？ 我们首先介绍分布式系统达成共识的动机。
在前文中，我们已经了解到分布式系统的几个主要难题：
 网络问题 时钟问题 节点故障问题  第一篇提到共识问题的文献1 来自于 lamport 的 &ldquo;Time, Clocks and the Ordering of Events in a Distributed System2&quot;，尽管它并没有明确的提出共识(consensus)或者协商(agreement)的概念。论文阐述了在分布式系统中，你无法判断事件 A 是否发生在事件 B 之前，除非 A 和 B 存在某种依赖关系。由此还引出了分布式状态机的概念。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tangwz.com/post/consensus/" /><meta property="og:image" content="https://tangwz.com/"/><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-09-06T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-09-06T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://tangwz.com/"/>

<meta name="twitter:title" content="分布式系统的核心：共识问题"/>
<meta name="twitter:description" content="混乱的“一致性”问题 Consensus != Consistency
受翻译影响，网上很多讨论 paxos 或 raft 的博客使用“分布式一致性协议”或者“分布式一致性算法”这样的字眼，虽然在汉语中“达成共识”和“达成一致”是一个意思，但是必须要说明在这里讨论的是 consensus 问题，使用“共识”来表达更清晰一些。而 CAP 定理中的 C 和数据库 ACID 的 C 才是真正的“一致性”—— consistency 问题，尽管这两个 C 讨论的也不是同一个问题，但在这里不展开。
为了规范和清晰表达，在讨论 consensus 问题的时候统一使用“共识”一词。
注：在早些的文献中，共识（consensus）也叫做协商（agreement）。
共识问题 那么共识问题到底是什么呢？举个生活中的例子，小明和小王出去聚会，小明问：“小王，我们喝点什么吧？” 小王：“喝咖啡怎么样？” 小明：“好啊，那就来杯咖啡。”
在上面的场景中，小王提议喝一杯咖啡，小明表示同意，两人就“喝杯咖啡”这个问题达成共识，并根据这个结果采取行动。这就是生活中的共识。
在分布式系统中，共识就是系统中的多个节点对某个值达成一致。共识问题可以用数学语言来描述：一个分布式系统包含 n 个进程 {0, 1, 2,&hellip;, n-1}，每个进程都有一个初值，进程之间互相通信，设计一种算法使得尽管出现故障，进程们仍协商出某个不可撤销的最终决定值，且每次执行都满足以下三个性质：
 终止性（Termination）：所有正确的进程最终都会认同某一个值。 协定性（Agreement）：所有正确的进程认同的值都是同一个值。 完整性（Integrity），也称作有效性（Validity）：如果正确的进程都提议同一个值，那么所有处于认同状态的正确进程都选择该值。  完整性可以有一些变化，例如，一种较弱的完整性是认定值等于某些正确经常提议的值，而不必是所有进程提议的值。完整性也隐含了，最终被认同的值必定是某个节点提出过的。
为什么要达成共识？ 我们首先介绍分布式系统达成共识的动机。
在前文中，我们已经了解到分布式系统的几个主要难题：
 网络问题 时钟问题 节点故障问题  第一篇提到共识问题的文献1 来自于 lamport 的 &ldquo;Time, Clocks and the Ordering of Events in a Distributed System2&quot;，尽管它并没有明确的提出共识(consensus)或者协商(agreement)的概念。论文阐述了在分布式系统中，你无法判断事件 A 是否发生在事件 B 之前，除非 A 和 B 存在某种依赖关系。由此还引出了分布式状态机的概念。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tangwz.com/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "分布式系统的核心：共识问题",
      "item": "https://tangwz.com/post/consensus/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "分布式系统的核心：共识问题",
  "name": "分布式系统的核心：共识问题",
  "description": "混乱的“一致性”问题 Consensus != Consistency\n受翻译影响，网上很多讨论 paxos 或 raft 的博客使用“分布式一致性协议”或者“分布式一致性算法”这样的字眼，虽然在汉语中“达成共识”和“达成一致”是一个意思，但是必须要说明在这里讨论的是 consensus 问题，使用“共识”来表达更清晰一些。而 CAP 定理中的 C 和数据库 ACID 的 C 才是真正的“一致性”—— consistency 问题，尽管这两个 C 讨论的也不是同一个问题，但在这里不展开。\n为了规范和清晰表达，在讨论 consensus 问题的时候统一使用“共识”一词。\n注：在早些的文献中，共识（consensus）也叫做协商（agreement）。\n共识问题 那么共识问题到底是什么呢？举个生活中的例子，小明和小王出去聚会，小明问：“小王，我们喝点什么吧？” 小王：“喝咖啡怎么样？” 小明：“好啊，那就来杯咖啡。”\n在上面的场景中，小王提议喝一杯咖啡，小明表示同意，两人就“喝杯咖啡”这个问题达成共识，并根据这个结果采取行动。这就是生活中的共识。\n在分布式系统中，共识就是系统中的多个节点对某个值达成一致。共识问题可以用数学语言来描述：一个分布式系统包含 n 个进程 {0, 1, 2,\u0026hellip;, n-1}，每个进程都有一个初值，进程之间互相通信，设计一种算法使得尽管出现故障，进程们仍协商出某个不可撤销的最终决定值，且每次执行都满足以下三个性质：\n 终止性（Termination）：所有正确的进程最终都会认同某一个值。 协定性（Agreement）：所有正确的进程认同的值都是同一个值。 完整性（Integrity），也称作有效性（Validity）：如果正确的进程都提议同一个值，那么所有处于认同状态的正确进程都选择该值。  完整性可以有一些变化，例如，一种较弱的完整性是认定值等于某些正确经常提议的值，而不必是所有进程提议的值。完整性也隐含了，最终被认同的值必定是某个节点提出过的。\n为什么要达成共识？ 我们首先介绍分布式系统达成共识的动机。\n在前文中，我们已经了解到分布式系统的几个主要难题：\n 网络问题 时钟问题 节点故障问题  第一篇提到共识问题的文献1 来自于 lamport 的 \u0026ldquo;Time, Clocks and the Ordering of Events in a Distributed System2\u0026quot;，尽管它并没有明确的提出共识(consensus)或者协商(agreement)的概念。论文阐述了在分布式系统中，你无法判断事件 A 是否发生在事件 B 之前，除非 A 和 B 存在某种依赖关系。由此还引出了分布式状态机的概念。",
  "keywords": [
    "分布式"
  ],
  "articleBody": "混乱的“一致性”问题 Consensus != Consistency\n受翻译影响，网上很多讨论 paxos 或 raft 的博客使用“分布式一致性协议”或者“分布式一致性算法”这样的字眼，虽然在汉语中“达成共识”和“达成一致”是一个意思，但是必须要说明在这里讨论的是 consensus 问题，使用“共识”来表达更清晰一些。而 CAP 定理中的 C 和数据库 ACID 的 C 才是真正的“一致性”—— consistency 问题，尽管这两个 C 讨论的也不是同一个问题，但在这里不展开。\n为了规范和清晰表达，在讨论 consensus 问题的时候统一使用“共识”一词。\n注：在早些的文献中，共识（consensus）也叫做协商（agreement）。\n共识问题 那么共识问题到底是什么呢？举个生活中的例子，小明和小王出去聚会，小明问：“小王，我们喝点什么吧？” 小王：“喝咖啡怎么样？” 小明：“好啊，那就来杯咖啡。”\n在上面的场景中，小王提议喝一杯咖啡，小明表示同意，两人就“喝杯咖啡”这个问题达成共识，并根据这个结果采取行动。这就是生活中的共识。\n在分布式系统中，共识就是系统中的多个节点对某个值达成一致。共识问题可以用数学语言来描述：一个分布式系统包含 n 个进程 {0, 1, 2,…, n-1}，每个进程都有一个初值，进程之间互相通信，设计一种算法使得尽管出现故障，进程们仍协商出某个不可撤销的最终决定值，且每次执行都满足以下三个性质：\n 终止性（Termination）：所有正确的进程最终都会认同某一个值。 协定性（Agreement）：所有正确的进程认同的值都是同一个值。 完整性（Integrity），也称作有效性（Validity）：如果正确的进程都提议同一个值，那么所有处于认同状态的正确进程都选择该值。  完整性可以有一些变化，例如，一种较弱的完整性是认定值等于某些正确经常提议的值，而不必是所有进程提议的值。完整性也隐含了，最终被认同的值必定是某个节点提出过的。\n为什么要达成共识？ 我们首先介绍分布式系统达成共识的动机。\n在前文中，我们已经了解到分布式系统的几个主要难题：\n 网络问题 时钟问题 节点故障问题  第一篇提到共识问题的文献1 来自于 lamport 的 “Time, Clocks and the Ordering of Events in a Distributed System2\"，尽管它并没有明确的提出共识(consensus)或者协商(agreement)的概念。论文阐述了在分布式系统中，你无法判断事件 A 是否发生在事件 B 之前，除非 A 和 B 存在某种依赖关系。由此还引出了分布式状态机的概念。\n在分布式系统中，共识就常常应用在这种多副本状态机（Replicated state machines），状态机在每台节点上都存有副本，这些状态机都有相同的初始状态，每次状态转变、下个状态是什么都由相关进程共同决定，每一台节点的日志的值和顺序都相同。每个状态机在“哪个状态是下一个需要处理的状态”这个问题上达成共识，这就是一个共识问题。\n最终，这些节点看起来就像一个单独的、高可靠的状态机。Raft 的论文3提到，使用状态机我们就能克服上述三个问题：\n 满足在所有非拜占庭条件下确保安全（不会返回错误结果），包括网络延迟、分区、丢包、重复和重排序。 不依赖于时序。 高可用。只要集群中的大部分节点正常运行，并能够互相通信且可以同客户端通信，这个集群就完全可用。因此，拥有5个节点的集群可以容忍其中的2个节点失败。假使通过停掉某些节点使其失败，稍后它们会从持久化存储的状态进行恢复，并重新加入到集群中。  不仅如此，达成共识还可以解决分布式系统中的以下经典问题：\n 互斥（Mutual exclusion）：哪个进程进入临界区访问资源？分布式锁？ 选主（Leader election）：在单主复制的数据库，需要所有节点就哪个节点是领导者达成共识。如果一些由于网络故障而无法与其他节点通信，可能会产生两个领导者，它们都会接受写入，数据就可能会产生分歧，从而导致数据不一致或丢失。 原子提交（Atomic commit）：跨多节点或跨多分区事务的数据库中，一个事务可能在某些节点上失败，但在其他节点上成功。如果我们想要维护这种事务的原子性，必须让所有节点对事务的结果达成共识：要么全部提交，要么全部中止/回滚。  总而言之，在共识的帮助下，分布式系统就可以像单一节点一样工作——所以共识问题是分布式系统最基本的问题。\n系统模型 在考虑如何达成共识之前，需要考虑分布式系统中有哪些可供选择的计算模型。主要有以下几个方面：\n网络模型：\n 同步（Synchronous）：响应时间是在一个固定且已知的有限范围内。 异步（Asynchronous）：响应时间是无限的。  故障类型：\n Fail-stop failures：节点突然宕机并停止响应其它节点。 Byzantine failures：源自“拜占庭将军问题” ，是指节点响应的数据会产生无法预料的结果，可能会互相矛盾或完全没有意义，这个节点甚至是在“说谎”，例如一个被黑客入侵的节点。  消息模型：\n 口头消息(oral messages)：消息被转述的时候是可能被篡改的。 签名消息(signed messages)：消息被发出来之后是无法伪造的，只要被篡改就会被发现。  作为最常见的，我们将分别讨论在同步系统和异步系统中的共识。在同步通信系统中达成共识是可行的(下文将会谈论这点)，但是，在实际的分布式系统中同步通信是不切实际的，我们不知道消息是故障了还是延迟了。异步与同步相比是一种更通用的情况。一个适用于异步系统的算法，也能被用于同步系统，但是反过来并不成立。\n让我们先从异步的情况开始。\n异步系统中的共识 FLP 不可能（FLP Impossibility） 早在 1985 年，Fischer、Lynch 和 Paterson （FLP）在 “Impossibility of Distributed Consensus with One Faulty Process\"4 证明了：在一个异步系统中，即使只有一个进程出现了故障，也没有算法能保证达成共识。\n简单来说，因为在一个异步系统中，进程可以随时发出响应，所以没有办法分辨一个进程是速度很慢还是已经崩溃，这不满足终止性（Termination）。详细的证明已经超出本文范围，不在细述5。\n此时，人们意识到一个分布式共识算法需要具有的两个属性：安全性(safety)和活性(liveness)。安全性意味着所有正确的进程都认同同一个值，活性意味着分布式系统最终会认同某一个值。每个共识算法要么牺牲掉一个属性，要么放宽对网络异步的假设。\n虽然 FLP 不可能定理听着让人望而生畏，但也给后来的人们提供了研究的思路——不再尝试寻找异步通信系统中共识问题完全正确的解法。FLP 不可能是指无法确保达成共识，并不是说如果有一个进程出错，就永远无法达成共识。这种不可能的结果来自于算法流程中最坏的结果：\n 一个完全异步的系统 发生了故障 最后，不可能有一个确定的共识算法。  针对这些最坏的情况，可以找到一些方法，尽可能去绕过 FLP 不可能，能满足大部分情况下都能达成共识。《分布式系统：概念与设计》提到一般有三种办法：\n 故障屏蔽（Fault masking） 使用故障检测器（Failure detectors） 使用随机性算法（Non-Determinism）  1、故障屏蔽（Fault masking） 既然异步系统中无法证明能够达成共识，我们可以将异步系统转换为同步系统，故障屏蔽就是第一种方法。故障屏蔽假设故障的进程最终会恢复，并找到一种重新加入分布式系统的方式。如果没有收到来自某个进程的消息，就一直等待直到收到预期的消息。\n例如，两阶段提交事务使用持久存储，能够从崩溃中恢复。如果一个进程崩溃，它会被重启（自动重启或由管理员重启）。进程在程序的关键点的持久存储中保留了足够多的信息，以便在崩溃和重启时能够利用这些数据继续工作。换句话说故障程序也能够像正确的进程一样工作，只是它有时候需要很长时间来执行一个恢复处理。\n故障屏蔽被应用在各种系统设计中。\n2、使用故障检测器（Failure detectors） 将异步系统转换为同步系统的第二个办法就是引入故障检测器，进程可以认为在超过一定时间没有响应的进程已经故障。一种很常见的故障检测器的实现：超时（timeout）。\n但是，这种办法要求故障检测器是精确的。如果故障器不精确的话，系统可能放弃一个正常的进程；如果超时时间设定得很长，进程就需要等待（并且不能执行任何工作）较长的时间才能得出出错的结论。这个方法甚至有可能导致网络分区。\n解决办法是使用“不完美”的故障检测器。Chanadra 和 Toueg 在 “The weakest failure detector for solving consensus6” 中分析了一个故障检测器必须拥有的两个属性：\n 完全性（Completeness）：每一个故障的进程都会被每一个正确的进程怀疑。 精确性（Accuracy）：正确的进程没有被怀疑。  同时，他们还证明了，即使是使用不可靠的故障检测器，只要通信可靠，崩溃的进程不超过 N/2，那么共识问题是可以解决的。我们不需要实现 Strong Completeness 和 Strong Accuracy，只需要一个最终弱故障检测器（eventually weakly failure detector），该检测器具有如下性质：\n 最终弱完全性（eventually weakly complete）：每一个错误进程最终常常被一些正确进程怀疑； 最终弱精确性（eventually weakly accurate）：经过某个时刻后，至少一个正确的进程从来没有被其它正确进程怀疑。  该论文还证明了，在异步系统中，我们不能只依靠消息来实现一个最终弱故障检测器。但是，实际的故障检测器能够根据观察到的响应时间调节它的超时值。如果一个进程或者一个到检测器的连接很慢，那么超时值就会增加，那么错误地怀疑一个进程的情况将变得很少。从实用目的来看，这样的弱故障检测器与理想的最终弱故障检测器十分接近。\n3、使用随机性算法(Non-Determinism) 这种解决不可能性的技术是引入一个随机算法，随机算法的输出不仅取决于外部的输入，还取决于执行过程中的随机概率。因此，给定两个完全相同的输入，该算法可能会输出两个不同的值。随机性算法使得“敌人”不能有效地阻碍达成共识。\n和传统选出领导、节点再协作的模式不同，像区块链这类共识是基于哪个节点最快计算出难题来达成的。区块链中每一个新区块都由本轮最快计算出数学难题的节点添加，整个分布式网络持续不断地建设这条有时间戳的区块链，而承载了最多计算量的区块链正是达成了共识的主链（即累积计算难度最大）。\n比特币使用了 PoW（Proof of Work）来维持共识，一些其它加密货币（如 DASH、NEO）使用 PoS（Proof of Stake），还有一些（如 Ripple）使用分布式账本（ledger）。\n但是，这些随机性算法都无法严格满足安全性(safety)。攻击者可以囤积巨量算力，从而控制或影响网络的大量正常节点，例如控制 50% 以上网络算力即可以对 PoW 发起女巫攻击（Sybil Attack）。只不过前提是攻击者需要付出一大笔资金来囤积算力，实际中这种风险性很低，如果有这么强的算力还不如直接挖矿赚取收益。\n同步系统中的共识 上述的方法 1 和 2，都想办法让系统比较“同步”。我们熟知的 Paxos 在异步系统中，由于活锁的存在，并没有完全解决共识问题（liveness不满足）。但 Paxos 被广泛应用在各种分布式系统中，就是因为在达成共识之前，系统并没有那么“异步”，还是有极大概率达成共识的。\nDolev 和 Strong 在 “Authenticated Algorithms for Byzantine Agreement7” 证明了：同步系统中，如果 N 个进程中最多有 f 个会出现崩溃故障，那么经过 f + 1 轮消息传递后即可达成共识。\nFischer 和 Lynch 的 “A lower bound for the time to assure interactive consistency8” 证明了，该结论同样适用于拜占庭故障。\n基于此，大多数实际应用都依赖于同步系统或部分同步系统的假设。\n同步系统中的拜占庭将军问题 Leslie Lamport、Robert Shostak 和 Marshall Pease 在 “拜占庭将军问题（The Byzantine General’s Problem)9” 论文中讨论了 3 个进程互相发送未签名（口头的）的消息，并证明了只要有一个进程出现故障，就无法满足拜占庭将军的条件。但如果使用签名的消息，那么 3 个将军中有一个出现故障，也能实现拜占庭共识。\nPease 将这种情况推广到了 N 个进程，也就是在一个有 f 个拜占庭故障节点的系统中，必须总共至少有 3f + 1 个节点才能够达成共识。即 N = 3f + 1。\n虽然同步系统下拜占庭将军问题的确存在解，但是代价很高，需要 O(N^f+1 ) 的信息交换量，只有在那些安全威胁很严重的地方使用（例如：航天工业）。\nPBFT 算法 PBFT(Practical Byzantine Fault Tolerance) 10 算法顾名思义是一种实用的拜占庭容错算法，由 Miguel Castro 和 Barbara Liskov 发表于 1999 年。\n算法的主要细节不再展开。PBFT 也是通过使用同步假设保证活性来绕过 FLP 不可能。PBFT 算法容错数量同样也是 N = 3f + 1，但只需要 O(n^2 ) 信息交换量，即每台计算机都需要与网络中其他所有计算机通讯。\n虽然 PBFT 已经有了一定的改进，但在大量参与者的场景还是不够实用，不过在拜占庭容错上已经作出很重要的突破，一些重要的思想也被后面的共识算法所借鉴。\n结语 本文参考了很多资料文献，对“共识问题”的研究历史做一些基础概述，希望能对你带来一点帮助。\n本文提到的论文，很多直接谈论结果，忽略了其中的数学证明，一是本文只是提纲挈领的讨论共识问题，建立一个知识框架，后续方便往里面填充内容；二是考虑到大部分读者对数学证明过程并不敢兴趣，也不想本文变成一本书那么长。本文也遗漏许多重要算法，后续如有必要会继续补充。\n限于本人能力，恳请读者们对本文存在的错误和不足之处，欢迎留言或私信告诉我。\n下篇我们将会讨论 Paxos 算法。\nReference   Mark Mc Keown: “A brief history of Consensus, 2PC and Transaction” ↩︎\n Leslie Lamport: “Time, Clocks and the Ordering of Events in a Distributed System” ↩︎\n Diego Ongaro and John Ousterhout: “In Search of an Understandable Consensus Algorithm” ↩︎\n Fischer、Lynch and Paterson; “Impossibility of Distributed Consensus with One Faulty Process” ↩︎\n A Brief Tour of FLP Impossibility ↩︎\n Chanadra and Toueg: “The weakest failure detector for solving consensus” ↩︎\n Authenticated Algorithms for Byzantine Agreement ↩︎\n A lower bound for the time to assure interactive consistency ↩︎\n Leslie Lamport, Robert Shostak, and Marshall Pease: “The Byzantine General’s Problem” ↩︎\n Practical Byzantine Fault Tolerance ↩︎\n   ",
  "wordCount" : "412",
  "inLanguage": "en",
  "datePublished": "2020-09-06T00:00:00Z",
  "dateModified": "2020-09-06T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "多颗糖"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tangwz.com/post/consensus/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "多颗糖",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tangwz.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tangwz.com/" accesskey="h" title="多颗糖 (Alt + H)">多颗糖</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tangwz.com/page/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tangwz.com/">Home</a>&nbsp;»&nbsp;<a href="https://tangwz.com/post/">Posts</a></div>
    <h1 class="post-title">
      分布式系统的核心：共识问题
    </h1>
    <div class="post-meta"><span title='2020-09-06 00:00:00 +0000 UTC'>September 6, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;多颗糖&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/post/consensus.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%b7%b7%e4%b9%b1%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98" aria-label="混乱的“一致性”问题">混乱的“一致性”问题</a></li>
                <li>
                    <a href="#%e5%85%b1%e8%af%86%e9%97%ae%e9%a2%98" aria-label="共识问题">共识问题</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%be%be%e6%88%90%e5%85%b1%e8%af%86" aria-label="为什么要达成共识？">为什么要达成共识？</a></li>
                <li>
                    <a href="#%e7%b3%bb%e7%bb%9f%e6%a8%a1%e5%9e%8b" aria-label="系统模型">系统模型</a></li>
                <li>
                    <a href="#%e5%bc%82%e6%ad%a5%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e5%85%b1%e8%af%86" aria-label="异步系统中的共识">异步系统中的共识</a><ul>
                        
                <li>
                    <a href="#flp-%e4%b8%8d%e5%8f%af%e8%83%bdflp-impossibility" aria-label="FLP 不可能（FLP Impossibility）">FLP 不可能（FLP Impossibility）</a></li>
                <li>
                    <a href="#1%e6%95%85%e9%9a%9c%e5%b1%8f%e8%94%bdfault-masking" aria-label="1、故障屏蔽（Fault masking）">1、故障屏蔽（Fault masking）</a></li>
                <li>
                    <a href="#2%e4%bd%bf%e7%94%a8%e6%95%85%e9%9a%9c%e6%a3%80%e6%b5%8b%e5%99%a8failure-detectors" aria-label="2、使用故障检测器（Failure detectors）">2、使用故障检测器（Failure detectors）</a></li>
                <li>
                    <a href="#3%e4%bd%bf%e7%94%a8%e9%9a%8f%e6%9c%ba%e6%80%a7%e7%ae%97%e6%b3%95non-determinism" aria-label="3、使用随机性算法(Non-Determinism)">3、使用随机性算法(Non-Determinism)</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%90%8c%e6%ad%a5%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e5%85%b1%e8%af%86" aria-label="同步系统中的共识">同步系统中的共识</a><ul>
                        
                <li>
                    <a href="#%e5%90%8c%e6%ad%a5%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e6%8b%9c%e5%8d%a0%e5%ba%ad%e5%b0%86%e5%86%9b%e9%97%ae%e9%a2%98" aria-label="同步系统中的拜占庭将军问题">同步系统中的拜占庭将军问题</a><ul>
                        
                <li>
                    <a href="#pbft-%e7%ae%97%e6%b3%95" aria-label="PBFT 算法">PBFT 算法</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%bb%93%e8%af%ad" aria-label="结语">结语</a></li>
                <li>
                    <a href="#reference" aria-label="Reference">Reference</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="混乱的一致性问题">混乱的“一致性”问题<a hidden class="anchor" aria-hidden="true" href="#混乱的一致性问题">#</a></h2>
<p>Consensus != Consistency</p>
<p>受翻译影响，网上很多讨论 paxos 或 raft 的博客使用“分布式一致性协议”或者“分布式一致性算法”这样的字眼，虽然在汉语中“达成共识”和“达成一致”是一个意思，但是必须要说明在这里讨论的是 consensus 问题，使用“共识”来表达更清晰一些。而 CAP 定理中的 C 和数据库 ACID 的 C 才是真正的“一致性”—— consistency 问题，尽管这两个 C 讨论的也不是同一个问题，但在这里不展开。</p>
<p>为了规范和清晰表达，在讨论 consensus 问题的时候统一使用“共识”一词。</p>
<p><img loading="lazy" src="/media/images/20200906-consensus/timeline.jpg" alt="时间线"  />
</p>
<p>注：在早些的文献中，共识（consensus）也叫做协商（agreement）。</p>
<h2 id="共识问题">共识问题<a hidden class="anchor" aria-hidden="true" href="#共识问题">#</a></h2>
<p>那么共识问题到底是什么呢？举个生活中的例子，小明和小王出去聚会，小明问：“小王，我们喝点什么吧？”
小王：“喝咖啡怎么样？”
小明：“好啊，那就来杯咖啡。”</p>
<p>在上面的场景中，小王<strong>提议</strong>喝一杯咖啡，小明表示<strong>同意</strong>，两人就“喝杯咖啡”这个问题达成共识，并根据这个结果采取行动。这就是生活中的共识。</p>
<p>在分布式系统中，<strong>共识</strong>就是系统中的多个节点对某个值达成一致。共识问题可以用数学语言来描述：一个分布式系统包含 n 个进程 {0, 1, 2,&hellip;, n-1}，每个进程都有一个初值，进程之间互相通信，设计一种算法使得尽管出现故障，进程们仍协商出某个不可撤销的最终决定值，且每次执行都满足以下三个性质：</p>
<ul>
<li>终止性（Termination）：所有正确的进程最终都会认同某一个值。</li>
<li>协定性（Agreement）：所有正确的进程认同的值都是同一个值。</li>
<li>完整性（Integrity），也称作有效性（Validity）：如果正确的进程都提议同一个值，那么所有处于认同状态的正确进程都选择该值。</li>
</ul>
<p>完整性可以有一些变化，例如，一种较弱的完整性是认定值等于某些正确经常提议的值，而不必是所有进程提议的值。完整性也隐含了，最终被认同的值必定是某个节点提出过的。</p>
<h2 id="为什么要达成共识">为什么要达成共识？<a hidden class="anchor" aria-hidden="true" href="#为什么要达成共识">#</a></h2>
<p>我们首先介绍分布式系统达成共识的动机。</p>
<p>在<a href="http://tangwz.com/post/intro-distributed-system/">前文</a>中，我们已经了解到分布式系统的几个主要难题：</p>
<ul>
<li>网络问题</li>
<li>时钟问题</li>
<li>节点故障问题</li>
</ul>
<p><a href="http://betathoughts.blogspot.com/2007/06/brief-history-of-consensus-2pc-and.html">第一篇提到共识问题的文献</a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> 来自于 lamport 的 &ldquo;<a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf">Time, Clocks and the Ordering of Events in a Distributed System</a><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>&quot;，尽管它并没有明确的提出共识(consensus)或者协商(agreement)的概念。论文阐述了在分布式系统中，你无法判断事件 A 是否发生在事件 B 之前，除非 A 和 B 存在某种依赖关系。由此还引出了分布式<strong>状态机</strong>的概念。</p>
<p>在分布式系统中，共识就常常应用在这种多副本状态机（Replicated state machines），状态机在每台节点上都存有副本，这些状态机都有相同的初始状态，每次状态转变、下个状态是什么都由相关进程共同决定，每一台节点的日志的值和顺序都相同。每个状态机在“哪个状态是下一个需要处理的状态”这个问题上达成共识，这就是一个共识问题。</p>
<p><img loading="lazy" src="/media/images/20200906-consensus/replicated-state-machine.jpg" alt="Raft 算法的状态机"  />
</p>
<p>最终，这些节点看起来就像一个单独的、高可靠的状态机。<a href="https://www.usenix.org/system/files/conference/atc14/atc14-paper-ongaro.pdf">Raft 的论文</a><sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>提到，使用状态机我们就能克服上述三个问题：</p>
<ul>
<li>满足在所有非拜占庭条件下确保安全（不会返回错误结果），包括网络延迟、分区、丢包、重复和重排序。</li>
<li>不依赖于时序。</li>
<li>高可用。只要集群中的大部分节点正常运行，并能够互相通信且可以同客户端通信，这个集群就完全可用。因此，拥有5个节点的集群可以容忍其中的2个节点失败。假使通过停掉某些节点使其失败，稍后它们会从持久化存储的状态进行恢复，并重新加入到集群中。</li>
</ul>
<p>不仅如此，达成共识还可以解决分布式系统中的以下经典问题：</p>
<ul>
<li>互斥（Mutual exclusion）：哪个进程进入临界区访问资源？分布式锁？</li>
<li>选主（Leader election）：在单主复制的数据库，需要所有节点就哪个节点是领导者达成共识。如果一些由于网络故障而无法与其他节点通信，可能会产生两个领导者，它们都会接受写入，数据就可能会产生分歧，从而导致数据不一致或丢失。</li>
<li>原子提交（Atomic commit）：跨多节点或跨多分区事务的数据库中，一个事务可能在某些节点上失败，但在其他节点上成功。如果我们想要维护这种事务的原子性，必须让所有节点对事务的结果达成共识：要么全部提交，要么全部中止/回滚。</li>
</ul>
<p>总而言之，在共识的帮助下，分布式系统就可以像单一节点一样工作——所以共识问题是分布式系统最基本的问题。</p>
<h2 id="系统模型">系统模型<a hidden class="anchor" aria-hidden="true" href="#系统模型">#</a></h2>
<p>在考虑如何达成共识之前，需要考虑分布式系统中有哪些可供选择的计算模型。主要有以下几个方面：</p>
<p>网络模型：</p>
<ul>
<li>同步（Synchronous）：响应时间是在一个固定且已知的有限范围内。</li>
<li>异步（Asynchronous）：响应时间是无限的。</li>
</ul>
<p>故障类型：</p>
<ul>
<li>Fail-stop failures：节点突然宕机并停止响应其它节点。</li>
<li><a href="https://en.wikipedia.org/wiki/Byzantine_fault">Byzantine failures</a>：源自“拜占庭将军问题” ，是指节点响应的数据会产生无法预料的结果，可能会互相矛盾或完全没有意义，这个节点甚至是在“说谎”，例如一个被黑客入侵的节点。</li>
</ul>
<p>消息模型：</p>
<ul>
<li>口头消息(oral messages)：消息被转述的时候是可能被篡改的。</li>
<li>签名消息(signed messages)：消息被发出来之后是无法伪造的，只要被篡改就会被发现。</li>
</ul>
<p>作为最常见的，我们将分别讨论在同步系统和异步系统中的共识。在同步通信系统中达成共识是可行的(下文将会谈论这点)，但是，在实际的分布式系统中同步通信是不切实际的，我们不知道消息是故障了还是延迟了。异步与同步相比是一种更通用的情况。一个适用于异步系统的算法，也能被用于同步系统，但是反过来并不成立。</p>
<p><img loading="lazy" src="/media/images/20200906-consensus/asynchronous-system.jpg" alt="异步与同步相比是一种更通用的情况"  />
</p>
<p>让我们先从异步的情况开始。</p>
<h2 id="异步系统中的共识">异步系统中的共识<a hidden class="anchor" aria-hidden="true" href="#异步系统中的共识">#</a></h2>
<h3 id="flp-不可能flp-impossibility">FLP 不可能（FLP Impossibility）<a hidden class="anchor" aria-hidden="true" href="#flp-不可能flp-impossibility">#</a></h3>
<p>早在 1985 年，Fischer、Lynch 和 Paterson （FLP）在 &ldquo;<a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf">Impossibility of Distributed Consensus with One Faulty Process</a>&quot;<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> 证明了：在一个<strong>异步</strong>系统中，即使只有一个进程出现了故障，也没有算法能<strong>保证</strong>达成共识。</p>
<p><img loading="lazy" src="/media/images/20200906-consensus/flp.jpg" alt="FLP 不可能（FLP Impossibility）"  />
</p>
<p>简单来说，因为在一个异步系统中，进程可以随时发出响应，所以没有办法分辨一个进程是速度很慢还是已经崩溃，这不满足终止性（Termination）。详细的证明已经超出本文范围，不在细述<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>。</p>
<p>此时，人们意识到一个分布式共识算法需要具有的两个属性：<strong>安全性(safety)<strong>和</strong>活性(liveness)</strong>。安全性意味着所有正确的进程都认同同一个值，活性意味着分布式系统最终会认同某一个值。每个共识算法要么牺牲掉一个属性，要么放宽对网络异步的假设。</p>
<p>虽然 FLP 不可能定理听着让人望而生畏，但也给后来的人们提供了研究的思路——不再尝试寻找异步通信系统中共识问题完全正确的解法。FLP 不可能是指无法确保达成共识，并不是说如果有一个进程出错，就永远无法达成共识。<strong>这种不可能的结果来自于算法流程中最坏的结果</strong>：</p>
<ul>
<li>一个完全异步的系统</li>
<li>发生了故障</li>
<li>最后，不可能有一个确定的共识算法。</li>
</ul>
<p>针对这些最坏的情况，可以找到一些方法，尽可能去绕过 FLP 不可能，能满足大部分情况下都能达成共识。<a href="https://book.douban.com/subject/21624776/">《分布式系统：概念与设计》</a>提到一般有三种办法：</p>
<ol>
<li>故障屏蔽（Fault masking）</li>
<li>使用故障检测器（Failure detectors）</li>
<li>使用随机性算法（Non-Determinism）</li>
</ol>
<h3 id="1故障屏蔽fault-masking">1、故障屏蔽（Fault masking）<a hidden class="anchor" aria-hidden="true" href="#1故障屏蔽fault-masking">#</a></h3>
<p>既然异步系统中无法证明能够达成共识，我们可以将异步系统转换为同步系统，故障屏蔽就是第一种方法。故障屏蔽假设故障的进程最终会恢复，并找到一种重新加入分布式系统的方式。如果没有收到来自某个进程的消息，就一直等待直到收到预期的消息。</p>
<p>例如，两阶段提交事务使用持久存储，能够从崩溃中恢复。如果一个进程崩溃，它会被重启（自动重启或由管理员重启）。进程在程序的关键点的持久存储中保留了足够多的信息，以便在崩溃和重启时能够利用这些数据继续工作。换句话说故障程序也能够像正确的进程一样工作，只是它有时候需要很长时间来执行一个恢复处理。</p>
<p>故障屏蔽被应用在各种系统设计中。</p>
<h3 id="2使用故障检测器failure-detectors">2、使用故障检测器（Failure detectors）<a hidden class="anchor" aria-hidden="true" href="#2使用故障检测器failure-detectors">#</a></h3>
<p>将异步系统转换为同步系统的第二个办法就是引入故障检测器，进程可以认为在超过一定时间没有响应的进程已经故障。一种很常见的故障检测器的实现：超时（timeout）。</p>
<p>但是，这种办法要求故障检测器是精确的。如果故障器不精确的话，系统可能放弃一个正常的进程；如果超时时间设定得很长，进程就需要等待（并且不能执行任何工作）较长的时间才能得出出错的结论。这个方法甚至有可能导致网络分区。</p>
<p>解决办法是使用“不完美”的故障检测器。Chanadra 和 Toueg 在 &ldquo;<a href="https://dl.acm.org/doi/10.1145/234533.234549">The weakest failure detector for solving consensus</a><sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>&rdquo; 中分析了一个故障检测器必须拥有的两个属性：</p>
<ul>
<li>完全性（Completeness）：每一个故障的进程都会被每一个正确的进程怀疑。</li>
<li>精确性（Accuracy）：正确的进程没有被怀疑。</li>
</ul>
<p>同时，他们还证明了，即使是使用不可靠的故障检测器，只要通信可靠，崩溃的进程不超过 N/2，那么共识问题是可以解决的。我们不需要实现 Strong Completeness 和 Strong Accuracy，只需要一个最终弱故障检测器（eventually weakly failure detector），该检测器具有如下性质：</p>
<ul>
<li>最终弱完全性（eventually weakly complete）：每一个错误进程最终常常被一些正确进程怀疑；</li>
<li>最终弱精确性（eventually weakly accurate）：经过某个时刻后，至少一个正确的进程从来没有被其它正确进程怀疑。</li>
</ul>
<p><img loading="lazy" src="/media/images/20200906-consensus/failure-detectors.jpg" alt="故障检测器（Failure detectors）"  />
</p>
<p>该论文还证明了，在异步系统中，我们不能只依靠消息来实现一个最终弱故障检测器。但是，实际的故障检测器能够根据观察到的响应时间调节它的超时值。如果一个进程或者一个到检测器的连接很慢，那么超时值就会增加，那么错误地怀疑一个进程的情况将变得很少。从实用目的来看，这样的弱故障检测器与理想的最终弱故障检测器十分接近。</p>
<h3 id="3使用随机性算法non-determinism">3、使用随机性算法(Non-Determinism)<a hidden class="anchor" aria-hidden="true" href="#3使用随机性算法non-determinism">#</a></h3>
<p>这种解决不可能性的技术是引入一个随机算法，随机算法的输出不仅取决于外部的输入，还取决于执行过程中的随机概率。因此，给定两个完全相同的输入，该算法可能会输出两个不同的值。随机性算法使得“敌人”不能有效地阻碍达成共识。</p>
<p>和传统选出领导、节点再协作的模式不同，像区块链这类共识是基于哪个节点最快计算出难题来达成的。区块链中每一个新区块都由本轮最快计算出数学难题的节点添加，整个分布式网络持续不断地建设这条有时间戳的区块链，而承载了最多计算量的区块链正是达成了共识的主链（即累积计算难度最大）。</p>
<p>比特币使用了 PoW（Proof of Work）来维持共识，一些其它加密货币（如 DASH、NEO）使用 PoS（Proof of Stake），还有一些（如 Ripple）使用分布式账本（ledger）。</p>
<p>但是，这些随机性算法都无法<strong>严格</strong>满足安全性(safety)。攻击者可以囤积巨量算力，从而控制或影响网络的大量正常节点，例如控制 50% 以上网络算力即可以对 PoW 发起<a href="https://en.wikipedia.org/wiki/Sybil_attack">女巫攻击（Sybil Attack）</a>。只不过前提是攻击者需要付出一大笔资金来囤积算力，实际中这种风险性很低，如果有这么强的算力还不如直接挖矿赚取收益。</p>
<h2 id="同步系统中的共识">同步系统中的共识<a hidden class="anchor" aria-hidden="true" href="#同步系统中的共识">#</a></h2>
<p>上述的方法 1 和 2，都想办法让系统比较“同步”。我们熟知的 Paxos 在异步系统中，由于活锁的存在，并没有完全解决共识问题（liveness不满足）。但 Paxos 被广泛应用在各种分布式系统中，就是因为在达成共识之前，系统并没有那么“异步”，还是有极大概率达成共识的。</p>
<p>Dolev 和 Strong 在 &ldquo;<a href="https://epubs.siam.org/doi/abs/10.1137/0212045?journalCode=smjcat">Authenticated Algorithms for Byzantine Agreement</a><sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>&rdquo; 证明了：<strong>同步系统中，如果 N 个进程中最多有 f 个会出现崩溃故障，那么经过 f + 1 轮消息传递后即可达成共识。</strong></p>
<p>Fischer 和 Lynch 的 &ldquo;<a href="https://www.sciencedirect.com/science/article/abs/pii/0020019082900333">A lower bound for the time to assure interactive consistency</a><sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup>&rdquo; 证明了，<strong>该结论同样适用于拜占庭故障</strong>。</p>
<p>基于此，大多数实际应用都依赖于同步系统或部分同步系统的假设。</p>
<h3 id="同步系统中的拜占庭将军问题">同步系统中的拜占庭将军问题<a hidden class="anchor" aria-hidden="true" href="#同步系统中的拜占庭将军问题">#</a></h3>
<p>Leslie Lamport、Robert Shostak 和 Marshall Pease 在 &ldquo;<a href="http://people.cs.uchicago.edu/~shanlu/teaching/33100_wi15/papers/byz.pdf">拜占庭将军问题（The Byzantine General’s Problem)</a><sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup>&rdquo; 论文中讨论了 3 个进程互相发送未签名（口头的）的消息，并证明了只要有一个进程出现故障，就无法满足拜占庭将军的条件。但如果使用签名的消息，那么 3 个将军中有一个出现故障，也能实现拜占庭共识。</p>
<p>Pease 将这种情况推广到了 N 个进程，也就是在一个有 f 个拜占庭故障节点的系统中，必须总共至少有 3f + 1 个节点才能够达成共识。即 N &gt;= 3f + 1。</p>
<p>虽然同步系统下拜占庭将军问题的确存在解，但是代价很高，需要 O(N^f+1 ) 的信息交换量，只有在那些安全威胁很严重的地方使用（例如：航天工业）。</p>
<h4 id="pbft-算法">PBFT 算法<a hidden class="anchor" aria-hidden="true" href="#pbft-算法">#</a></h4>
<p><a href="http://pmg.csail.mit.edu/papers/osdi99.pdf">PBFT(Practical Byzantine Fault Tolerance)</a> <sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup> 算法顾名思义是一种实用的拜占庭容错算法，由 Miguel Castro 和 Barbara Liskov 发表于 1999 年。</p>
<p>算法的主要细节不再展开。PBFT 也是通过使用同步假设保证活性来绕过 FLP 不可能。PBFT 算法容错数量同样也是 N &gt;= 3f + 1，但只需要  O(n^2 ) 信息交换量，即每台计算机都需要与网络中其他所有计算机通讯。</p>
<p>虽然 PBFT 已经有了一定的改进，但在大量参与者的场景还是不够实用，不过在拜占庭容错上已经作出很重要的突破，一些重要的思想也被后面的共识算法所借鉴。</p>
<h2 id="结语">结语<a hidden class="anchor" aria-hidden="true" href="#结语">#</a></h2>
<p>本文参考了很多资料文献，对“共识问题”的研究历史做一些基础概述，希望能对你带来一点帮助。</p>
<p>本文提到的论文，很多直接谈论结果，忽略了其中的数学证明，一是本文只是提纲挈领的讨论共识问题，建立一个知识框架，后续方便往里面填充内容；二是考虑到大部分读者对数学证明过程并不敢兴趣，也不想本文变成一本书那么长。本文也遗漏许多重要算法，后续如有必要会继续补充。</p>
<p>限于本人能力，恳请读者们对本文存在的错误和不足之处，欢迎留言或私信告诉我。</p>
<p>下篇我们将会讨论 Paxos 算法。</p>
<h2 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h2>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Mark Mc Keown: &ldquo;<a href="http://betathoughts.blogspot.com/2007/06/brief-history-of-consensus-2pc-and.html">A brief history of Consensus, 2PC and Transaction</a>&rdquo;&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Leslie Lamport: &ldquo;<a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf">Time, Clocks and the Ordering of Events in a Distributed System</a>&rdquo;&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Diego Ongaro and John Ousterhout: &ldquo;<a href="https://www.usenix.org/system/files/conference/atc14/atc14-paper-ongaro.pdf">In Search of an Understandable Consensus Algorithm</a>&rdquo;&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>Fischer、Lynch and Paterson; &ldquo;<a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf">Impossibility of Distributed Consensus with One Faulty Process</a>&rdquo;&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p><a href="http://the-paper-trail.org/blog/a-brief-tour-of-flp-impossibility/">A Brief Tour of FLP Impossibility</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>Chanadra and Toueg: &ldquo;<a href="https://dl.acm.org/doi/10.1145/234533.234549">The weakest failure detector for solving consensus</a>&rdquo;&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p><a href="https://epubs.siam.org/doi/abs/10.1137/0212045?journalCode=smjcat">Authenticated Algorithms for Byzantine Agreement</a>&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8" role="doc-endnote">
<p><a href="https://www.sciencedirect.com/science/article/abs/pii/0020019082900333">A lower bound for the time to assure interactive consistency</a>&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9" role="doc-endnote">
<p>Leslie Lamport, Robert Shostak, and Marshall Pease: &ldquo;<a href="http://people.cs.uchicago.edu/~shanlu/teaching/33100_wi15/papers/byz.pdf">The Byzantine General’s Problem</a>&rdquo;&#160;<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10" role="doc-endnote">
<p><a href="http://pmg.csail.mit.edu/papers/osdi99.pdf">Practical Byzantine Fault Tolerance</a>&#160;<a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tangwz.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://tangwz.com/post/git-merge-vs-rebase/">
    <span class="title">« Prev Page</span>
    <br>
    <span>同样更新分支，git merge 和 rebase 有什么区别？</span>
  </a>
  <a class="next" href="https://tangwz.com/post/intro-distributed-system/">
    <span class="title">Next Page »</span>
    <br>
    <span>认识分布式系统</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 分布式系统的核心：共识问题 on twitter"
        href="https://twitter.com/intent/tweet/?text=%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a0%b8%e5%bf%83%ef%bc%9a%e5%85%b1%e8%af%86%e9%97%ae%e9%a2%98&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fconsensus%2f&amp;hashtags=%e5%88%86%e5%b8%83%e5%bc%8f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 分布式系统的核心：共识问题 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fconsensus%2f&amp;title=%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a0%b8%e5%bf%83%ef%bc%9a%e5%85%b1%e8%af%86%e9%97%ae%e9%a2%98&amp;summary=%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a0%b8%e5%bf%83%ef%bc%9a%e5%85%b1%e8%af%86%e9%97%ae%e9%a2%98&amp;source=https%3a%2f%2ftangwz.com%2fpost%2fconsensus%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 分布式系统的核心：共识问题 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ftangwz.com%2fpost%2fconsensus%2f&title=%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a0%b8%e5%bf%83%ef%bc%9a%e5%85%b1%e8%af%86%e9%97%ae%e9%a2%98">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 分布式系统的核心：共识问题 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftangwz.com%2fpost%2fconsensus%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 分布式系统的核心：共识问题 on whatsapp"
        href="https://api.whatsapp.com/send?text=%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a0%b8%e5%bf%83%ef%bc%9a%e5%85%b1%e8%af%86%e9%97%ae%e9%a2%98%20-%20https%3a%2f%2ftangwz.com%2fpost%2fconsensus%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 分布式系统的核心：共识问题 on telegram"
        href="https://telegram.me/share/url?text=%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a0%b8%e5%bf%83%ef%bc%9a%e5%85%b1%e8%af%86%e9%97%ae%e9%a2%98&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fconsensus%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://tangwz.com/">多颗糖</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
