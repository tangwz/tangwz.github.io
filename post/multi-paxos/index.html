<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Paxos 的变种（一）：Multi-Paxos | 多颗糖</title>
<meta name="keywords" content="分布式" />
<meta name="description" content="分布式系统为了实现多副本状态机（Replicated state machine），常常需要一个多副本日志（Replicated log）系统，这个原理受到简单的经验常识启发：如果日志的内容和顺序都相同，多个进程从同一状态开始，并且以相同的顺序获得相同的输入，那么这些进程将会生成相同的输出，并且结束在相同的状态。
Replicated log =&gt; Replicated state machine
问题是：
 如何保证日志数据在每台机器上都一样？
 当然是一直在讨论的 Paxos。一次独立的 Paxos 代表日志中的一条记录，重复运行 Paxos 即可创建一个 Replicated log。
但是如果每一组提案值都通过一次 Paxos 算法实例来达成共识，每次都要两轮 RPC，会产生大量开销。所以需要对 Paxos 做一些调整解决更实际的问题，并提升性能。经过一系列优化后的 Paxos 我们称之为 Multi-Paxos。
 Multi-Paxos 的目标就是实现 Replicated log.
 下面我们从第一个问题开始。
如何确定是哪条日志记录？ 首先，Replicated log 类似一个数组，我们需要知道当次请求是在写日志的第几位。因此，Multi-Paxos 做的第一个调整就是要添加一个日志的 index 参数到 Prepare 和 Accept 阶段，表示这轮 Paxos 正在决策哪一条日志记录。
现在流程大致如下，当收到客户端带有提案值的请求时：
 找到第一个没有 chosen 的日志记录 运行 Basic Paxos，对这个 index 用客户端请求的提案值进行提案 Prepare 是否返回 acceptedValue？  是：用 acceptedValue 跑完这轮 Paxos，然后回到步骤 1 继续处理 否：chosen 客户端提案值    举个例子 如图所示，首先，服务器上的每条日志记录可能存在三种状态：">
<meta name="author" content="多颗糖">
<link rel="canonical" href="https://tangwz.com/post/multi-paxos/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://tangwz.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tangwz.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tangwz.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tangwz.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://tangwz.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.4" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-72128068-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="Paxos 的变种（一）：Multi-Paxos" />
<meta property="og:description" content="分布式系统为了实现多副本状态机（Replicated state machine），常常需要一个多副本日志（Replicated log）系统，这个原理受到简单的经验常识启发：如果日志的内容和顺序都相同，多个进程从同一状态开始，并且以相同的顺序获得相同的输入，那么这些进程将会生成相同的输出，并且结束在相同的状态。
Replicated log =&gt; Replicated state machine
问题是：
 如何保证日志数据在每台机器上都一样？
 当然是一直在讨论的 Paxos。一次独立的 Paxos 代表日志中的一条记录，重复运行 Paxos 即可创建一个 Replicated log。
但是如果每一组提案值都通过一次 Paxos 算法实例来达成共识，每次都要两轮 RPC，会产生大量开销。所以需要对 Paxos 做一些调整解决更实际的问题，并提升性能。经过一系列优化后的 Paxos 我们称之为 Multi-Paxos。
 Multi-Paxos 的目标就是实现 Replicated log.
 下面我们从第一个问题开始。
如何确定是哪条日志记录？ 首先，Replicated log 类似一个数组，我们需要知道当次请求是在写日志的第几位。因此，Multi-Paxos 做的第一个调整就是要添加一个日志的 index 参数到 Prepare 和 Accept 阶段，表示这轮 Paxos 正在决策哪一条日志记录。
现在流程大致如下，当收到客户端带有提案值的请求时：
 找到第一个没有 chosen 的日志记录 运行 Basic Paxos，对这个 index 用客户端请求的提案值进行提案 Prepare 是否返回 acceptedValue？  是：用 acceptedValue 跑完这轮 Paxos，然后回到步骤 1 继续处理 否：chosen 客户端提案值    举个例子 如图所示，首先，服务器上的每条日志记录可能存在三种状态：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tangwz.com/post/multi-paxos/" /><meta property="og:image" content="https://tangwz.com/"/><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-10-18T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-10-18T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://tangwz.com/"/>

<meta name="twitter:title" content="Paxos 的变种（一）：Multi-Paxos"/>
<meta name="twitter:description" content="分布式系统为了实现多副本状态机（Replicated state machine），常常需要一个多副本日志（Replicated log）系统，这个原理受到简单的经验常识启发：如果日志的内容和顺序都相同，多个进程从同一状态开始，并且以相同的顺序获得相同的输入，那么这些进程将会生成相同的输出，并且结束在相同的状态。
Replicated log =&gt; Replicated state machine
问题是：
 如何保证日志数据在每台机器上都一样？
 当然是一直在讨论的 Paxos。一次独立的 Paxos 代表日志中的一条记录，重复运行 Paxos 即可创建一个 Replicated log。
但是如果每一组提案值都通过一次 Paxos 算法实例来达成共识，每次都要两轮 RPC，会产生大量开销。所以需要对 Paxos 做一些调整解决更实际的问题，并提升性能。经过一系列优化后的 Paxos 我们称之为 Multi-Paxos。
 Multi-Paxos 的目标就是实现 Replicated log.
 下面我们从第一个问题开始。
如何确定是哪条日志记录？ 首先，Replicated log 类似一个数组，我们需要知道当次请求是在写日志的第几位。因此，Multi-Paxos 做的第一个调整就是要添加一个日志的 index 参数到 Prepare 和 Accept 阶段，表示这轮 Paxos 正在决策哪一条日志记录。
现在流程大致如下，当收到客户端带有提案值的请求时：
 找到第一个没有 chosen 的日志记录 运行 Basic Paxos，对这个 index 用客户端请求的提案值进行提案 Prepare 是否返回 acceptedValue？  是：用 acceptedValue 跑完这轮 Paxos，然后回到步骤 1 继续处理 否：chosen 客户端提案值    举个例子 如图所示，首先，服务器上的每条日志记录可能存在三种状态："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tangwz.com/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Paxos 的变种（一）：Multi-Paxos",
      "item": "https://tangwz.com/post/multi-paxos/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Paxos 的变种（一）：Multi-Paxos",
  "name": "Paxos 的变种（一）：Multi-Paxos",
  "description": "分布式系统为了实现多副本状态机（Replicated state machine），常常需要一个多副本日志（Replicated log）系统，这个原理受到简单的经验常识启发：如果日志的内容和顺序都相同，多个进程从同一状态开始，并且以相同的顺序获得相同的输入，那么这些进程将会生成相同的输出，并且结束在相同的状态。\nReplicated log =\u0026gt; Replicated state machine\n问题是：\n 如何保证日志数据在每台机器上都一样？\n 当然是一直在讨论的 Paxos。一次独立的 Paxos 代表日志中的一条记录，重复运行 Paxos 即可创建一个 Replicated log。\n但是如果每一组提案值都通过一次 Paxos 算法实例来达成共识，每次都要两轮 RPC，会产生大量开销。所以需要对 Paxos 做一些调整解决更实际的问题，并提升性能。经过一系列优化后的 Paxos 我们称之为 Multi-Paxos。\n Multi-Paxos 的目标就是实现 Replicated log.\n 下面我们从第一个问题开始。\n如何确定是哪条日志记录？ 首先，Replicated log 类似一个数组，我们需要知道当次请求是在写日志的第几位。因此，Multi-Paxos 做的第一个调整就是要添加一个日志的 index 参数到 Prepare 和 Accept 阶段，表示这轮 Paxos 正在决策哪一条日志记录。\n现在流程大致如下，当收到客户端带有提案值的请求时：\n 找到第一个没有 chosen 的日志记录 运行 Basic Paxos，对这个 index 用客户端请求的提案值进行提案 Prepare 是否返回 acceptedValue？  是：用 acceptedValue 跑完这轮 Paxos，然后回到步骤 1 继续处理 否：chosen 客户端提案值    举个例子 如图所示，首先，服务器上的每条日志记录可能存在三种状态：",
  "keywords": [
    "分布式"
  ],
  "articleBody": "分布式系统为了实现多副本状态机（Replicated state machine），常常需要一个多副本日志（Replicated log）系统，这个原理受到简单的经验常识启发：如果日志的内容和顺序都相同，多个进程从同一状态开始，并且以相同的顺序获得相同的输入，那么这些进程将会生成相同的输出，并且结束在相同的状态。\nReplicated log = Replicated state machine\n问题是：\n 如何保证日志数据在每台机器上都一样？\n 当然是一直在讨论的 Paxos。一次独立的 Paxos 代表日志中的一条记录，重复运行 Paxos 即可创建一个 Replicated log。\n但是如果每一组提案值都通过一次 Paxos 算法实例来达成共识，每次都要两轮 RPC，会产生大量开销。所以需要对 Paxos 做一些调整解决更实际的问题，并提升性能。经过一系列优化后的 Paxos 我们称之为 Multi-Paxos。\n Multi-Paxos 的目标就是实现 Replicated log.\n 下面我们从第一个问题开始。\n如何确定是哪条日志记录？ 首先，Replicated log 类似一个数组，我们需要知道当次请求是在写日志的第几位。因此，Multi-Paxos 做的第一个调整就是要添加一个日志的 index 参数到 Prepare 和 Accept 阶段，表示这轮 Paxos 正在决策哪一条日志记录。\n现在流程大致如下，当收到客户端带有提案值的请求时：\n 找到第一个没有 chosen 的日志记录 运行 Basic Paxos，对这个 index 用客户端请求的提案值进行提案 Prepare 是否返回 acceptedValue？  是：用 acceptedValue 跑完这轮 Paxos，然后回到步骤 1 继续处理 否：chosen 客户端提案值    举个例子 如图所示，首先，服务器上的每条日志记录可能存在三种状态：\n 已经保存并知道被 chosen 的日志记录，例如 S1 方框加粗的第 1、2、6 条记录（后面会介绍服务器如何知道这些记录已经被 chosen） 已经保存但不知道有没有被 chosen，例如 S1 第 3 条 cmp 命令。观察三台服务器上的日志，cmp 其实已经存在两台上达成了多数派，只是 S1 还不知道 空的记录，例如 S1 第 4、5 条记录，S1 在这个位置没有接受过值，但可能在其它服务器接受过：例如 S2 第 4 条接受了 sub，S3 第 5 条接受了 cmp  我们知道三台机可以容忍一台故障，为了更具体的分析，我们假设此时是 S3 宕机的情况。同时，这里的提案值是一条具体的命令。当 S1 收到客户端的请求命令 jmp 时，：\n 找到第一个没有 chosen 的日志记录：图示中是第 3 条 cmp 命令。 这时候 S1 会尝试让 jmp 作为第 3 条的 chosen 值，运行 Paxos。 因为 S1 的 Acceptor 已经接受了 cmp，所以在 Prepare 阶段会返回 cmp，接着用 cmp 作为提案值跑完这轮 Paxos，s2 也将接受 cmp 同时 S1 的 cmp 变为 chosen 状态，然后继续找下一个没有 chosen 的位置——也就是第 4 位。 S2 的第 4 个位置接受了 sub，所以在 Prepare 阶段会返回 sub，S1 的第 4 位会 chosen sub，接着往下找。 第 5 位 S1 和 S2 都为空，不会返回 acceptedValue，所以第 5 个位置就确定为 jmp 命令的位置，运行 Paxos，并返回请求。  值得注意的是，这个系统是可以并行处理多个客户端请求，比如 S1 知道 3、4、5、7 这几个位置都是未 chosen 的，就直接把收到的 4 个命令并行尝试写到这四个位置。但是，如果是状态机要执行日志时，必须是按照日志顺序逐一输入，如果第 3 条没有被 chosen，即便第 4 条已经 chosen 了，状态机也不能执行第 4 条命令。\n还记得我们之前文章里说的活锁。如果所有的 Proposer 都一起并行工作，因 Proposer 间大量的冲突而需要更多轮 RPC 才能达成共识的可能性就很大。另外，每个提案最优情况下还是需要两轮 RPC ！\n一般通过以下方式优化：\n 选择一个Leader，任意时刻只有它一个 Proposer，这样可以避免冲突 减少大部分 Prepare 请求，只需要对整个日志进行一次 Prepare，后面大部分日志可以通过一次 Accept 被 chosen  下面谈谈这两个优化。\nLeader 选举 有很多办法可以进行选举，Lamport 提出了一种简单的方式：让 server_id 最大的节点成为Leader（在上篇说到提案编号由自增 id 和 server_id 组成，就是这个 server_id）。\n 既然每台服务器都有一个 server_id，我们就直接让 server_id 最大的服务器成为 Leader，这意味着每台服务器需要知道其它服务器的 server_id 为此，每个节点每隔 Tms 向其它服务器发送心跳 如果一个节点在 2Tms 时间内没有收到比自己 server_id 更大的心跳，那它自己就转为 Leader，意味着：  该节点处理客户端请求 该节点同时担任 Proposer 和 Acceptor   如果一个节点收到比自己 server_id 更大的服务器的心跳，那么它就不能成为 Leader，意味着：  该节点拒绝掉客户端请求，或者将请求重定向到 Leader 该节点只能担任 Acceptor    值得注意的是，这是非常简单的策略，这种方式系统中同时有两个 Leader 的概率是较小的。即使是系统中有两个 Leader，Paxos 也是能正常工作的，只是冲突的概率就大了很多，效率也会降低。\n有一些基于租约的策略显得更为稳定，也更复杂，在此不表。\n减少 Prepare 请求 在讨论如何减少 Prepare 请求之前，先讨论下 Prepare 阶段的作用，需要 Prepare 有两个原因：\n 屏蔽老的提案：但 Basic-Paxos 只作用在日志的一条记录 检查可能已经被 chosen 的 value 来代替原本的提案值：多个 Proposer 并发进行提案的时候，新的 Proposal 要确保提案的值相同  我们依然是需要 Prepare 的。我们要做的是减少大部分 Prepare 请求，首先要搞定这两个功能。\n对于 1，我们不再让提案编号只屏蔽一个 index 位置，而是让它变成全局的，即屏蔽整个日志。一旦 Prepare 成功，整个日志都会阻塞（值得注意的是，Accept 阶段还是只能写在对应的 index 位置上）。\n对于2，需要拓展 Prepare 请求的返回信息，和之前一样，Prepare 还是会返回最大提案编号的 acceptedValue，除此之外，Acceptor 还会向后查看日志记录，如果要写的这个位置之后都是空的记录，没有接受过任何值，那么 Acceptor 就额外返回一个标志位 noMoreAccepted。\n后续，如果 Leader 接收到超过半数的 Acceptor 回复了 noMoreAccepted，那 Leader 就不需要发送 Prepare 请求了，直接发送 Accept 请求即可。这样只需要一轮 RPC。\n副本的完整性 目前为止，通过选主和减少 Prepare 请求之后的 Multi-Paxos 依然不够完整，还需要解决：\n 之前的日志只需要被多数派接受，完整的日志记录需要复制到全部节点 只有 Proposer（也就是Leader） 知道哪些记录被 chosen 了，需要所有的服务器都知道哪些记录被 chosen  换句话说，我们需要每台机的日志都完整，这样状态机执行日志后才能达到一样的状态。\n要做到这点，我们需要：\n 为了让日志尽可能被复制到每台服务器：Leader 在收到多数派 Acceptor 回复后，可以继续做后面的处理，但同时在后台继续对未回复的 Acceptor 进行重试。这样不会影响客户端的响应时间，但这也不能确保完全复制了（例如，如果 Leader 在中途宕机了） 为了追踪哪些记录是被 chosen 的，我们增加一些内容：  acceptedProposal 代表日志的提案编号，如果第 i 条记录被 chosen，则 acceptedProposal[i] = 无穷大（这是因为，只有提案编号更大的提案才能被接受，无穷大则表示无法再被重写了） 每个节点都维护一个 firstUnChosenIndex，表示第一个没有被 chosen 的日志位置。（即第一个 acceptedProposal[i] != 无穷大的节点）   Leader 告诉 Acceptor 哪些日志被 chosen ：Leader 在向 Acceptor 发送 Accept 请求的时候带上 firstUnChosenIndex，这样 Acceptor 收到 Accept 请求的时候，如果第 i 条日志满足 i ，则标记 i 为 chosen（即设为无穷大）  用图示来说明一下，上图表示同一个 Acceptor 节点 Accept 请求前后的 ``。该 Acceptor 在 Accept 请求之前的第 6 位的提案编号为 3.4，这时它收到一个提案编号也为 3.4 的 Accept 请求，并且请求的 firstUnchosenIndex = 7，大于之前 3.4 所在的 6，所以将选中第 6 位，同时因为该请求的 index = 8，acceptedProposal[8] == 3.4\n到了这里还需要考虑，Acceptor 的日志条目中仍然可能有一些前任 Leader 留下的提案记录，还没有完成提案的复制或者 chosen 时 Leader 宕机，换了一个 Leader 节点，这时候需要：  Acceptor 将其 firstUnchosenIndex 作为 Accept 请求的响应返回给 Proposer Proposer 判断如果 Acceptor.firstUnChosenIndex ，则在后台（异步）发送 Success(index, v) RPC Acceptor 收到 Success RPC 后，更新已经被 chosen 的日志记录：  acceptedValue[index] = v acceptedProposal[index] = 无穷大 return firstUnchosenIndex 如果需要(可能存在多个不确定的状态)，Proposer 发送额外的 Success RPC      总结一下，通过 4 个步骤就可以确保所有的 Acceptor 都最终知道 chosen 的日志记录。在一般的情况，并不需要额外的第 4 步，只有在 Leader 切换时才可能需要第 4 步。\n现在我们的日志已被完全复制了。因此，让我们转头看看与客户端的交互。\n客户端请求 接下来需要考虑客户端如何与系统交互。\n首先，当客户端第一次请求时，并不知道谁是 Leader，它任意请求一台服务器，如果该服务器不是 Leader，重定向给 Leader。\nLeader 直到日志记录被 chosen 并且被 Leader 的状态机执行才返回响应给客户端。\n客户端会一直和 Leader 交互，直到无法再联系上它（例如请求超时）。在这种情况下，客户端会联系任何其它服务器，这些服务器又在重定向到实际的 Leader。\n但这存在一个问题，如果请求提案被 chosen 后，Leader 在回复客户端之前宕机了。客户端会认为请求失败了，并重试请求。这相当于一个命令会被状态机执行两次，这是不可接受的。\n解决办法是客户端为每个请求增加一个唯一 id，服务器将该 id 与命令一起保存到日志记录中。状态机在执行命令之前，会根据 id 检查该命令是否被执行过。\n集群管理（加入或减少节点） 最后一个非常棘手的问题，因为集群中的节点是会变更的，包括：服务器的 id、网络地址变更和节点数量等。集群节点数量改变会影响多数派数量的判断，我们必须保证不会出现两个重叠的多数派。\nLamport 在 Paxos 论文中的建议解决方案是：使用日志来管理这些变更。当前的集群配置被当作一条日志记录存储起来，并与其它的日志记录一起被复制同步。\n这里看起来会比较奇怪，如图所示，第 1、3 个位置存储了两个不同的系统配置，其它位置的日志存储了状态机要执行的命令。增加一个系统参数 𝛼 去控制当配置变更时什么时候去应用它，𝛼 表示配置多少条记录后才能生效。\n这里假设 𝛼 = 3，意味着 C1 在 3 条记录内不生效，也就是 C1 在第 4 条才会生效， C2 在第 6 条开始生效。\n𝛼 是在系统启动的时候就指定的参数。这个参数的大小会限制我们在系统可以同时 chosen 的日志条数：在 i 这个位置的值被 chosen 之前，我们不能 chosen i+α 这个位置的值——因为我们不知道中间是否有配置变更。\n所以，如果 α 值很小，假设是 1，那整个系统就是串行工作了；如果 α = 3，意味着我们可以同时 chosen 3 个位置的值；如果 α 非常大， α = 1000，那事情就会变得复杂，如果我们要变更配置，可能要等配置所在的 1000 条记录都被 chosen 以后才会生效，那要等好一阵子。这时候为了让配置更快生效，我们可以写入一些 no-op 指令来填充日志，使得迅速达到需要的条数，而不用一直等待客户端请求进来。\n总结 首先，描述了如何从 Basic-Paxos 到 Multi-Paxos，如何 chosen 某个位置的日志记录，接着是两个提高 Paxos 效率的办法：选定 Leader 和减少 Prepare 请求。还讲到了如何让所有的服务器都得到完整的日志，系统如何与客户端交互工作。最后，讲了通过 α 值来处理配置变更。\nBasic Paxos 流程是比较容易理解的，但 Multi-Paxos 却非常棘手，尤其是实际使用的时候，需要一系列的优化，这一系列优化又是不那么容易理解和做到的。这也是后来的分布式系系统纷纷转投 Raft 的原因之一吧，Paxos 的工程化实在令人头疼。\n但不得不说的是，大厂都有自己的 Paxos/Multi-Paxos 实现。Google 的论文 “Paxos made live\u0010” 介绍他们相关的工作，他们的 BigTable、chubby 都是基于文章描述的 Multi-Paxos；微信作为体量巨大的应用，也有开源的 paxos 实现：phxpaxos；\u0010阿里的 Oceanbase 也是使用 Paxos——Paxos 可谓分布式系统的皇冠。\n下篇文章我们还会继续介绍 Paxos 的其它变体：Fast-Paxos。\n",
  "wordCount" : "606",
  "inLanguage": "en",
  "datePublished": "2020-10-18T00:00:00Z",
  "dateModified": "2020-10-18T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "多颗糖"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tangwz.com/post/multi-paxos/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "多颗糖",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tangwz.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tangwz.com/" accesskey="h" title="多颗糖 (Alt + H)">多颗糖</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tangwz.com/page/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tangwz.com/">Home</a>&nbsp;»&nbsp;<a href="https://tangwz.com/post/">Posts</a></div>
    <h1 class="post-title">
      Paxos 的变种（一）：Multi-Paxos
    </h1>
    <div class="post-meta"><span title='2020-10-18 00:00:00 +0000 UTC'>October 18, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;多颗糖&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/post/multi-paxos.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e7%a1%ae%e5%ae%9a%e6%98%af%e5%93%aa%e6%9d%a1%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95" aria-label="如何确定是哪条日志记录？">如何确定是哪条日志记录？</a><ul>
                        
                <li>
                    <a href="#%e4%b8%be%e4%b8%aa%e4%be%8b%e5%ad%90" aria-label="举个例子">举个例子</a></li></ul>
                </li>
                <li>
                    <a href="#leader-%e9%80%89%e4%b8%be" aria-label="Leader 选举">Leader 选举</a></li>
                <li>
                    <a href="#%e5%87%8f%e5%b0%91-prepare-%e8%af%b7%e6%b1%82" aria-label="减少 Prepare 请求">减少 Prepare 请求</a></li>
                <li>
                    <a href="#%e5%89%af%e6%9c%ac%e7%9a%84%e5%ae%8c%e6%95%b4%e6%80%a7" aria-label="副本的完整性">副本的完整性</a></li>
                <li>
                    <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e8%af%b7%e6%b1%82" aria-label="客户端请求">客户端请求</a></li>
                <li>
                    <a href="#%e9%9b%86%e7%be%a4%e7%ae%a1%e7%90%86%e5%8a%a0%e5%85%a5%e6%88%96%e5%87%8f%e5%b0%91%e8%8a%82%e7%82%b9" aria-label="集群管理（加入或减少节点）">集群管理（加入或减少节点）</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>分布式系统为了实现<strong>多副本状态机（Replicated state machine）</strong>，常常需要一个多副本日志（Replicated log）系统，<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">这个原理受到简单的经验常识启发</a>：如果日志的内容和顺序都相同，多个进程从同一状态开始，并且以相同的顺序获得相同的输入，那么这些进程将会生成相同的输出，并且结束在相同的状态。</p>
<p>Replicated log =&gt; Replicated state machine</p>
<p><img loading="lazy" src="/media/images/20201018-multi-paxos/Replicated-state-machine.jpg" alt="Replicated-state-machine"  />
</p>
<p>问题是：</p>
<blockquote>
<p>如何保证日志数据在每台机器上都一样？</p>
</blockquote>
<p>当然是一直在讨论的 Paxos。一次独立的 Paxos 代表日志中的一条记录，重复运行 Paxos 即可创建一个 Replicated log。</p>
<p>但是如果每一组提案值都通过一次 Paxos 算法实例来达成共识，每次都要两轮 RPC，会产生大量开销。所以需要对 Paxos 做一些调整解决更实际的问题，并提升性能。经过一系列优化后的 Paxos 我们称之为 Multi-Paxos。</p>
<blockquote>
<p>Multi-Paxos 的目标就是实现 Replicated log.</p>
</blockquote>
<p>下面我们从第一个问题开始。</p>
<h2 id="如何确定是哪条日志记录">如何确定是哪条日志记录？<a hidden class="anchor" aria-hidden="true" href="#如何确定是哪条日志记录">#</a></h2>
<p>首先，Replicated log 类似一个数组，我们需要知道当次请求是在写日志的第几位。因此，Multi-Paxos 做的第一个调整就是要添加一个日志的 index 参数到 <code>Prepare</code> 和 <code>Accept</code> 阶段，表示这轮 Paxos 正在决策哪一条日志记录。</p>
<p>现在流程大致如下，当收到客户端带有提案值的请求时：</p>
<ol>
<li>找到第一个没有 chosen 的日志记录</li>
<li>运行 Basic Paxos，对这个 index 用客户端请求的提案值进行提案</li>
<li>Prepare 是否返回 <code>acceptedValue</code>？
<ul>
<li>是：用 <code>acceptedValue</code> 跑完这轮 Paxos，然后回到步骤 1 继续处理</li>
<li>否：chosen 客户端提案值</li>
</ul>
</li>
</ol>
<h3 id="举个例子">举个例子<a hidden class="anchor" aria-hidden="true" href="#举个例子">#</a></h3>
<p><img loading="lazy" src="/media/images/20201018-multi-paxos/Selecting-log-entries.png" alt=""  />
</p>
<p>如图所示，首先，服务器上的每条日志记录可能存在三种状态：</p>
<ul>
<li>已经保存并知道被 chosen 的日志记录，例如 S1 方框加粗的第 1、2、6 条记录（后面会介绍服务器如何知道这些记录已经被 chosen）</li>
<li>已经保存但不知道有没有被 chosen，例如 S1 第 3 条 <code>cmp</code> 命令。观察三台服务器上的日志，cmp 其实已经存在两台上达成了多数派，只是 S1 还不知道</li>
<li>空的记录，例如 S1 第 4、5 条记录，S1 在这个位置没有接受过值，但可能在其它服务器接受过：例如 S2 第 4 条接受了 <code>sub</code>，S3 第 5 条接受了 <code>cmp</code></li>
</ul>
<p>我们知道三台机可以容忍一台故障，为了更具体的分析，我们假设此时<strong>是 S3 宕机的情况</strong>。同时，这里的提案值是一条具体的命令。当 S1 收到客户端的请求命令 <code>jmp</code> 时，：</p>
<ol>
<li>找到第一个没有 chosen 的日志记录：图示中是第 3 条 <code>cmp</code> 命令。</li>
<li>这时候 S1 会尝试让 <code>jmp</code> 作为第 3 条的 chosen 值，运行 Paxos。</li>
<li>因为 S1 的 Acceptor 已经接受了 <code>cmp</code>，所以在 Prepare 阶段会返回 <code>cmp</code>，接着用 <code>cmp</code> 作为提案值跑完这轮 Paxos，s2 也将接受 <code>cmp</code> 同时 S1 的 <code>cmp</code> 变为 chosen 状态，然后继续找下一个没有 chosen 的位置——也就是第 4 位。</li>
<li>S2 的第 4 个位置接受了 <code>sub</code>，所以在 Prepare 阶段会返回 <code>sub</code>，S1 的第 4 位会 chosen <code>sub</code>，接着往下找。</li>
<li>第 5 位 S1 和 S2 都为空，不会返回 <code>acceptedValue</code>，所以第 5 个位置就确定为 <code>jmp</code> 命令的位置，运行 Paxos，并返回请求。</li>
</ol>
<p>值得注意的是，这个系统是可以并行处理多个客户端请求，比如 S1 知道 3、4、5、7 这几个位置都是未 chosen 的，就直接把收到的 4 个命令并行尝试写到这四个位置。但是，如果是状态机要执行日志时，必须是按照日志顺序逐一输入，如果第 3 条没有被 chosen，即便第 4 条已经 chosen 了，状态机也不能执行第 4 条命令。</p>
<p>还记得我们之前文章里说的活锁。如果所有的 Proposer 都一起并行工作，因 Proposer 间大量的冲突而需要更多轮 RPC 才能达成共识的可能性就很大。另外，<strong>每个提案最优情况下还是需要两轮 RPC</strong> ！</p>
<p>一般通过以下方式优化：</p>
<ul>
<li>选择一个Leader，任意时刻只有它一个 Proposer，这样可以避免冲突</li>
<li>减少大部分 Prepare 请求，只需要对整个日志进行一次 Prepare，后面大部分日志可以通过一次 Accept 被 chosen</li>
</ul>
<p>下面谈谈这两个优化。</p>
<h2 id="leader-选举">Leader 选举<a hidden class="anchor" aria-hidden="true" href="#leader-选举">#</a></h2>
<p>有很多办法可以进行选举，Lamport 提出了一种简单的方式：让 server_id 最大的节点成为Leader（在<a href="http://tangwz.com/post/basic-paxos/">上篇</a>说到提案编号由自增 id 和 server_id 组成，就是这个 server_id）。</p>
<ol>
<li>既然每台服务器都有一个 server_id，我们就直接让 server_id 最大的服务器成为 Leader，这意味着每台服务器需要知道其它服务器的 server_id</li>
<li>为此，每个节点每隔 Tms 向其它服务器发送心跳</li>
<li>如果一个节点在 2Tms 时间内没有收到比自己 server_id 更大的心跳，那它自己就转为 Leader，意味着：
<ul>
<li>该节点处理客户端请求</li>
<li>该节点同时担任 Proposer 和 Acceptor</li>
</ul>
</li>
<li>如果一个节点收到比自己 server_id 更大的服务器的心跳，那么它就不能成为 Leader，意味着：
<ul>
<li>该节点拒绝掉客户端请求，或者将请求重定向到 Leader</li>
<li>该节点只能担任 Acceptor</li>
</ul>
</li>
</ol>
<p>值得注意的是，这是非常简单的策略，这种方式系统中同时有两个 Leader 的概率是较小的。<strong>即使是系统中有两个 Leader，Paxos 也是能正常工作的，只是冲突的概率就大了很多，效率也会降低。</strong></p>
<p>有一些基于租约的策略显得更为稳定，也更复杂，在此不表。</p>
<h2 id="减少-prepare-请求">减少 Prepare 请求<a hidden class="anchor" aria-hidden="true" href="#减少-prepare-请求">#</a></h2>
<p>在讨论如何减少 Prepare 请求之前，先讨论下 Prepare 阶段的作用，需要 Prepare 有两个原因：</p>
<ol>
<li>屏蔽老的提案：但 Basic-Paxos 只作用在日志的一条记录</li>
<li>检查可能已经被 chosen 的 value 来代替原本的提案值：多个 Proposer 并发进行提案的时候，新的 Proposal 要确保提案的值相同</li>
</ol>
<p>我们<strong>依然是需要 Prepare 的</strong>。我们要做的是减少大部分 Prepare 请求，首先要搞定这两个功能。</p>
<p>对于 1，我们不再让提案编号只屏蔽一个 index 位置，而是让它变成全局的，即屏蔽整个日志。一旦 Prepare 成功，整个日志都会阻塞（值得注意的是，Accept 阶段还是只能写在对应的 index 位置上）。</p>
<p>对于2，需要拓展 Prepare 请求的返回信息，和之前一样，Prepare 还是会返回最大提案编号的 <code>acceptedValue</code>，除此之外，Acceptor 还会向后查看日志记录，如果要写的这个位置之后都是空的记录，没有接受过任何值，那么 Acceptor 就额外返回一个标志位 <code>noMoreAccepted</code>。</p>
<p>后续，如果 Leader 接收到超过半数的 Acceptor 回复了 <code>noMoreAccepted</code>，那 Leader 就不需要发送 Prepare 请求了，直接发送 Accept 请求即可。这样只需要一轮 RPC。</p>
<h2 id="副本的完整性">副本的完整性<a hidden class="anchor" aria-hidden="true" href="#副本的完整性">#</a></h2>
<p>目前为止，通过选主和减少 Prepare 请求之后的 Multi-Paxos 依然不够完整，还需要解决：</p>
<ul>
<li>之前的日志只需要被多数派接受，完整的日志记录需要复制到全部节点</li>
<li>只有 Proposer（也就是Leader） 知道哪些记录被 chosen 了，需要所有的服务器都知道哪些记录被 chosen</li>
</ul>
<p>换句话说，我们需要每台机的日志都完整，这样状态机执行日志后才能达到一样的状态。</p>
<p>要做到这点，我们需要：</p>
<ol>
<li>为了让日志尽可能被复制到每台服务器：Leader 在收到多数派 Acceptor 回复后，可以继续做后面的处理，但同时在后台继续对未回复的 Acceptor 进行重试。这样不会影响客户端的响应时间，但这也不能确保完全复制了（例如，如果 Leader 在中途宕机了）</li>
<li>为了追踪哪些记录是被 chosen 的，我们增加一些内容：
<ul>
<li><code>acceptedProposal</code> 代表日志的提案编号，如果第 i 条记录被 chosen，则 <code>acceptedProposal[i] = 无穷大</code>（这是因为，只有提案编号更大的提案才能被接受，无穷大则表示无法再被重写了）</li>
<li>每个节点都维护一个 <code>firstUnChosenIndex</code>，表示第一个没有被 chosen 的日志位置。（即第一个 <code>acceptedProposal[i] != 无穷大</code>的节点）</li>
</ul>
</li>
<li>Leader 告诉 Acceptor 哪些日志被 chosen ：Leader 在向 Acceptor 发送 Accept 请求的时候带上 <code>firstUnChosenIndex</code>，这样 Acceptor 收到 Accept 请求的时候，如果第 i 条日志满足 <code>i &lt; request.firstUnchosenIndex &amp;&amp; acceptedProposal[i] == request.proposal</code>，则标记 i 为 chosen（即设为无穷大）</li>
</ol>
<p><img loading="lazy" src="/media/images/20201018-multi-paxos/full-disclosure.jpg" alt=""  />
</p>
<p>用图示来说明一下，上图表示同一个 Acceptor 节点 Accept 请求前后的 ``。该 Acceptor 在 Accept 请求之前的第 6 位的提案编号为 3.4，这时它收到一个提案编号也为 3.4 的 Accept 请求，并且请求的 firstUnchosenIndex = 7，大于之前 3.4 所在的 6，所以<strong>将选中第 6 位，同时因为该请求的 index = 8，acceptedProposal[8] == 3.4</strong></p>
<ol start="4">
<li>到了这里还需要考虑，Acceptor 的日志条目中仍然可能有一些前任 Leader 留下的提案记录，还没有完成提案的复制或者 chosen 时 Leader 宕机，换了一个 Leader 节点，这时候需要：
<ul>
<li>Acceptor 将其 <code>firstUnchosenIndex</code> 作为 Accept 请求的响应返回给 Proposer</li>
<li>Proposer 判断如果 <code>Acceptor.firstUnChosenIndex &lt; Proposer.firstUnChosenIndex</code>，则在后台（异步）发送 <code>Success(index, v)</code> RPC</li>
<li>Acceptor 收到 Success RPC 后，更新已经被 chosen 的日志记录：
<ul>
<li>acceptedValue[index] = v</li>
<li>acceptedProposal[index] = 无穷大</li>
<li>return firstUnchosenIndex</li>
<li>如果需要(可能存在多个不确定的状态)，Proposer 发送额外的 Success RPC</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>总结一下，通过 4 个步骤就可以确保所有的 Acceptor 都最终知道 chosen 的日志记录。在一般的情况，并不需要额外的第 4 步，只有在 Leader 切换时才可能需要第 4 步。</p>
<p>现在我们的日志已被完全复制了。因此，让我们转头看看与客户端的交互。</p>
<h2 id="客户端请求">客户端请求<a hidden class="anchor" aria-hidden="true" href="#客户端请求">#</a></h2>
<p>接下来需要考虑客户端如何与系统交互。</p>
<p>首先，当客户端第一次请求时，并不知道谁是 Leader，它任意请求一台服务器，如果该服务器不是 Leader，重定向给 Leader。</p>
<p>Leader 直到日志记录被 chosen 并且被 Leader 的状态机执行才返回响应给客户端。</p>
<p>客户端会一直和 Leader 交互，直到无法再联系上它（例如请求超时）。在这种情况下，客户端会联系任何其它服务器，这些服务器又在重定向到实际的 Leader。</p>
<p>但这存在一个问题，如果请求提案被 chosen 后，Leader 在回复客户端之前宕机了。客户端会认为请求失败了，并重试请求。这相当于一个命令会被状态机执行两次，这是不可接受的。</p>
<p>解决办法是客户端为每个请求增加一个唯一 id，服务器将该 id 与命令一起保存到日志记录中。状态机在执行命令之前，会根据 id 检查该命令是否被执行过。</p>
<h2 id="集群管理加入或减少节点">集群管理（加入或减少节点）<a hidden class="anchor" aria-hidden="true" href="#集群管理加入或减少节点">#</a></h2>
<p>最后一个非常棘手的问题，因为集群中的节点是会变更的，包括：服务器的 id、网络地址变更和节点数量等。集群节点数量改变会影响多数派数量的判断，我们必须保证不会出现两个重叠的多数派。</p>
<p><img loading="lazy" src="/media/images/20201018-multi-paxos/configuration-changes.jpg" alt=""  />
</p>
<p>Lamport 在 Paxos 论文中的建议解决方案是：使用日志来管理这些变更。当前的集群配置被当作一条日志记录存储起来，并与其它的日志记录一起被复制同步。</p>
<p><img loading="lazy" src="/media/images/20201018-multi-paxos/configuration-changes-demo.jpg" alt=""  />
</p>
<p>这里看起来会比较奇怪，如图所示，第 1、3 个位置存储了两个不同的系统配置，其它位置的日志存储了状态机要执行的命令。增加一个系统参数 𝛼 去控制当配置变更时什么时候去应用它，<strong>𝛼 表示配置多少条记录后才能生效。</strong></p>
<p>这里假设 𝛼 = 3，意味着 C1 在 3 条记录内不生效，也就是 C1 在第 4 条才会生效， C2 在第 6 条开始生效。</p>
<p>𝛼 是在系统启动的时候就指定的参数。这个参数的大小会限制我们在系统可以同时 chosen 的日志条数：在 <code>i</code> 这个位置的值被 chosen 之前，我们不能 chosen <code>i+α</code> 这个位置的值——因为我们不知道中间是否有配置变更。</p>
<p>所以，如果 α 值很小，假设是 1，那整个系统就是串行工作了；如果 α = 3，意味着我们可以同时 chosen 3 个位置的值；如果 α 非常大， α = 1000，那事情就会变得复杂，如果我们要变更配置，可能要等配置所在的 1000 条记录都被 chosen 以后才会生效，那要等好一阵子。这时候为了让配置更快生效，我们可以写入一些 <code>no-op</code> 指令来填充日志，使得迅速达到需要的条数，而不用一直等待客户端请求进来。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>首先，描述了如何从 Basic-Paxos 到 Multi-Paxos，如何 chosen 某个位置的日志记录，接着是两个提高 Paxos 效率的办法：选定 Leader 和减少 Prepare 请求。还讲到了如何让所有的服务器都得到完整的日志，系统如何与客户端交互工作。最后，讲了通过 α 值来处理配置变更。</p>
<p>Basic Paxos 流程是比较容易理解的，但 Multi-Paxos 却非常棘手，尤其是实际使用的时候，需要一系列的优化，这一系列优化又是不那么容易理解和做到的。这也是后来的分布式系系统纷纷转投 Raft 的原因之一吧，Paxos 的工程化实在令人头疼。</p>
<p>但不得不说的是，大厂都有自己的 Paxos/Multi-Paxos 实现。Google 的论文 &ldquo;<a href="https://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf">Paxos made live</a>&rdquo; 介绍他们相关的工作，他们的 BigTable、chubby 都是基于文章描述的 Multi-Paxos；微信作为体量巨大的应用，也有开源的 paxos 实现：<a href="https://github.com/Tencent/phxpaxos">phxpaxos</a>；<a href="https://www.zhihu.com/question/52337912">阿里的 Oceanbase 也是使用 Paxos</a>——Paxos 可谓分布式系统的皇冠。</p>
<p>下篇文章我们还会继续介绍 Paxos 的其它变体：<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-112.pdf">Fast-Paxos</a>。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tangwz.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://tangwz.com/post/paxos-exam/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Raft 作者出的 Paxos 的试题</span>
  </a>
  <a class="next" href="https://tangwz.com/post/basic-paxos/">
    <span class="title">Next Page »</span>
    <br>
    <span>理解 Paxos（含伪代码）</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Paxos 的变种（一）：Multi-Paxos on twitter"
        href="https://twitter.com/intent/tweet/?text=Paxos%20%e7%9a%84%e5%8f%98%e7%a7%8d%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9aMulti-Paxos&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fmulti-paxos%2f&amp;hashtags=%e5%88%86%e5%b8%83%e5%bc%8f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Paxos 的变种（一）：Multi-Paxos on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fmulti-paxos%2f&amp;title=Paxos%20%e7%9a%84%e5%8f%98%e7%a7%8d%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9aMulti-Paxos&amp;summary=Paxos%20%e7%9a%84%e5%8f%98%e7%a7%8d%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9aMulti-Paxos&amp;source=https%3a%2f%2ftangwz.com%2fpost%2fmulti-paxos%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Paxos 的变种（一）：Multi-Paxos on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ftangwz.com%2fpost%2fmulti-paxos%2f&title=Paxos%20%e7%9a%84%e5%8f%98%e7%a7%8d%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9aMulti-Paxos">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Paxos 的变种（一）：Multi-Paxos on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftangwz.com%2fpost%2fmulti-paxos%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Paxos 的变种（一）：Multi-Paxos on whatsapp"
        href="https://api.whatsapp.com/send?text=Paxos%20%e7%9a%84%e5%8f%98%e7%a7%8d%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9aMulti-Paxos%20-%20https%3a%2f%2ftangwz.com%2fpost%2fmulti-paxos%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Paxos 的变种（一）：Multi-Paxos on telegram"
        href="https://telegram.me/share/url?text=Paxos%20%e7%9a%84%e5%8f%98%e7%a7%8d%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9aMulti-Paxos&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fmulti-paxos%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://tangwz.com/">多颗糖</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
