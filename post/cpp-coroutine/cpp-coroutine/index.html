<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>如何编写 C&#43;&#43; 20 协程(Coroutines) | 多颗糖</title>
<meta name="keywords" content="C&#43;&#43;" />
<meta name="description" content="C&#43;&#43;20 带着 Coroutines 来了！
花了一两周的时间后，我想写写 C&#43;&#43;20 协程的基本用法，因为 C&#43;&#43; 的协程让我感到很奇怪，写一个协程程序十分费劲。让我们抛去复杂的东西，来看看写一个 C&#43;&#43; 协程需要哪些东西。
编译器支持 由于 C&#43;&#43; 20 还没被所有编译器完全支持，首先需要确保你的编译器实现了 Coroutines，可以通过下面的网站查看编译器支持情况：https://en.cppreference.com/w/cpp/compiler_support#cpp20
值得一提，我使用的 MacOS 自带的 Apple Clang 对 C&#43;&#43;20 支持很弱，我选择通过 Homebrew 安装最新版的 GNU GCC (10 以上版本)来编译。
我使用的 GNU GCC 10.2 版本编译指令：
g&#43;&#43; -fcoroutines -std=c&#43;&#43;20 Clang 支持不够好，不推荐使用。Clang 可以使用如下命令编译：
clang&#43;&#43; -std=c&#43;&#43;20 -stdlib=libc&#43;&#43; -fcoroutines-ts 不推荐 Clang 还有一个理由：使用 Clang 需要 include 头文件 &lt;experimental/coroutine&gt;  而不是 &lt;coroutine&gt;。此外，一些类型被命名为 std::experimental:xxx 而不是 std:xxx。
以下示例代码只支持 GNU GCC 版本的编译器。
C&#43;&#43; 协程简介 在正式开始之前，我们先要理解 C&#43;&#43;20 中协程使用的一些术语。#
首先，什么是协程？">
<meta name="author" content="多颗糖">
<link rel="canonical" href="https://tangwz.com/post/cpp-coroutine/cpp-coroutine/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://tangwz.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tangwz.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tangwz.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tangwz.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://tangwz.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.4" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-72128068-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="如何编写 C&#43;&#43; 20 协程(Coroutines)" />
<meta property="og:description" content="C&#43;&#43;20 带着 Coroutines 来了！
花了一两周的时间后，我想写写 C&#43;&#43;20 协程的基本用法，因为 C&#43;&#43; 的协程让我感到很奇怪，写一个协程程序十分费劲。让我们抛去复杂的东西，来看看写一个 C&#43;&#43; 协程需要哪些东西。
编译器支持 由于 C&#43;&#43; 20 还没被所有编译器完全支持，首先需要确保你的编译器实现了 Coroutines，可以通过下面的网站查看编译器支持情况：https://en.cppreference.com/w/cpp/compiler_support#cpp20
值得一提，我使用的 MacOS 自带的 Apple Clang 对 C&#43;&#43;20 支持很弱，我选择通过 Homebrew 安装最新版的 GNU GCC (10 以上版本)来编译。
我使用的 GNU GCC 10.2 版本编译指令：
g&#43;&#43; -fcoroutines -std=c&#43;&#43;20 Clang 支持不够好，不推荐使用。Clang 可以使用如下命令编译：
clang&#43;&#43; -std=c&#43;&#43;20 -stdlib=libc&#43;&#43; -fcoroutines-ts 不推荐 Clang 还有一个理由：使用 Clang 需要 include 头文件 &lt;experimental/coroutine&gt;  而不是 &lt;coroutine&gt;。此外，一些类型被命名为 std::experimental:xxx 而不是 std:xxx。
以下示例代码只支持 GNU GCC 版本的编译器。
C&#43;&#43; 协程简介 在正式开始之前，我们先要理解 C&#43;&#43;20 中协程使用的一些术语。#
首先，什么是协程？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tangwz.com/post/cpp-coroutine/cpp-coroutine/" /><meta property="og:image" content="https://tangwz.com/"/><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-06T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-03-06T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://tangwz.com/"/>

<meta name="twitter:title" content="如何编写 C&#43;&#43; 20 协程(Coroutines)"/>
<meta name="twitter:description" content="C&#43;&#43;20 带着 Coroutines 来了！
花了一两周的时间后，我想写写 C&#43;&#43;20 协程的基本用法，因为 C&#43;&#43; 的协程让我感到很奇怪，写一个协程程序十分费劲。让我们抛去复杂的东西，来看看写一个 C&#43;&#43; 协程需要哪些东西。
编译器支持 由于 C&#43;&#43; 20 还没被所有编译器完全支持，首先需要确保你的编译器实现了 Coroutines，可以通过下面的网站查看编译器支持情况：https://en.cppreference.com/w/cpp/compiler_support#cpp20
值得一提，我使用的 MacOS 自带的 Apple Clang 对 C&#43;&#43;20 支持很弱，我选择通过 Homebrew 安装最新版的 GNU GCC (10 以上版本)来编译。
我使用的 GNU GCC 10.2 版本编译指令：
g&#43;&#43; -fcoroutines -std=c&#43;&#43;20 Clang 支持不够好，不推荐使用。Clang 可以使用如下命令编译：
clang&#43;&#43; -std=c&#43;&#43;20 -stdlib=libc&#43;&#43; -fcoroutines-ts 不推荐 Clang 还有一个理由：使用 Clang 需要 include 头文件 &lt;experimental/coroutine&gt;  而不是 &lt;coroutine&gt;。此外，一些类型被命名为 std::experimental:xxx 而不是 std:xxx。
以下示例代码只支持 GNU GCC 版本的编译器。
C&#43;&#43; 协程简介 在正式开始之前，我们先要理解 C&#43;&#43;20 中协程使用的一些术语。#
首先，什么是协程？"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tangwz.com/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "如何编写 C++ 20 协程(Coroutines)",
      "item": "https://tangwz.com/post/cpp-coroutine/cpp-coroutine/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "如何编写 C++ 20 协程(Coroutines)",
  "name": "如何编写 C\u002b\u002b 20 协程(Coroutines)",
  "description": "C++20 带着 Coroutines 来了！\n花了一两周的时间后，我想写写 C++20 协程的基本用法，因为 C++ 的协程让我感到很奇怪，写一个协程程序十分费劲。让我们抛去复杂的东西，来看看写一个 C++ 协程需要哪些东西。\n编译器支持 由于 C++ 20 还没被所有编译器完全支持，首先需要确保你的编译器实现了 Coroutines，可以通过下面的网站查看编译器支持情况：https://en.cppreference.com/w/cpp/compiler_support#cpp20\n值得一提，我使用的 MacOS 自带的 Apple Clang 对 C++20 支持很弱，我选择通过 Homebrew 安装最新版的 GNU GCC (10 以上版本)来编译。\n我使用的 GNU GCC 10.2 版本编译指令：\ng++ -fcoroutines -std=c++20 Clang 支持不够好，不推荐使用。Clang 可以使用如下命令编译：\nclang++ -std=c++20 -stdlib=libc++ -fcoroutines-ts 不推荐 Clang 还有一个理由：使用 Clang 需要 include 头文件 \u0026lt;experimental/coroutine\u0026gt;  而不是 \u0026lt;coroutine\u0026gt;。此外，一些类型被命名为 std::experimental:xxx 而不是 std:xxx。\n以下示例代码只支持 GNU GCC 版本的编译器。\nC++ 协程简介 在正式开始之前，我们先要理解 C++20 中协程使用的一些术语。#\n首先，什么是协程？",
  "keywords": [
    "C++"
  ],
  "articleBody": "C++20 带着 Coroutines 来了！\n花了一两周的时间后，我想写写 C++20 协程的基本用法，因为 C++ 的协程让我感到很奇怪，写一个协程程序十分费劲。让我们抛去复杂的东西，来看看写一个 C++ 协程需要哪些东西。\n编译器支持 由于 C++ 20 还没被所有编译器完全支持，首先需要确保你的编译器实现了 Coroutines，可以通过下面的网站查看编译器支持情况：https://en.cppreference.com/w/cpp/compiler_support#cpp20\n值得一提，我使用的 MacOS 自带的 Apple Clang 对 C++20 支持很弱，我选择通过 Homebrew 安装最新版的 GNU GCC (10 以上版本)来编译。\n我使用的 GNU GCC 10.2 版本编译指令：\ng++ -fcoroutines -std=c++20 Clang 支持不够好，不推荐使用。Clang 可以使用如下命令编译：\nclang++ -std=c++20 -stdlib=libc++ -fcoroutines-ts 不推荐 Clang 还有一个理由：使用 Clang 需要 include 头文件   而不是 。此外，一些类型被命名为 std::experimental:xxx 而不是 std:xxx。\n以下示例代码只支持 GNU GCC 版本的编译器。\nC++ 协程简介 在正式开始之前，我们先要理解 C++20 中协程使用的一些术语。#\n首先，什么是协程？\n协程就是一个可以**挂起(suspend)和恢复(resume)**的函数(但无论如何不能是 main 函数)。你可以暂停协程的执行，去做其他事情，然后在适当的时候恢复到暂停的位置继续执行。协程让我们使用同步方式写异步代码。\n怎么挂起协程呢？C++ 提供了三个方法：co_await, co_yield 和 co_return。\n 顺便说一句：coroutine 不是并行(parallelism)，和 Go 语言的 goroutine 不一样！\n 与你之前接触到的协程完全不同，一个 C++ 协程一般长这样：\nstruct ReturnObject { struct promise_type { ReturnObject get_return_object() { return {}; } std::suspend_never initial_suspend() { return {}; } std::suspend_never final_suspend() { return {}; } void unhandled_exception() {} }; }; struct Awaitable { std::coroutine_handle *hp_; constexpr bool await_ready() const noexcept { return false; } void await_suspend(std::coroutine_handle h) { *hp_ = h; } void await_resume() noexcept { std::cout  \"Event signaled, resuming.\"  std::endl; } }; ReturnObject counter(std::coroutine_handle *continuation_out) { Awaitable a{continuation_out}; for (unsigned i = 0;; ++i) { co_await a; std::cout  \"counter: \"  i  std::endl; } } 这奇怪的协程代码涉及了 C++ 协程很重要的三个概念：\n promise_type Awaitable std::coroutine_handle  在写 C++20 的协程之前，我们必须需要先了解三个概念，可以用这三张图来形容这三个概念：\n图来源: https://www.youtube.com/watch?v=vzC2iRfO_H8\nPromise C++ 协程的返回类型必须是 promise_type，promise_type 是一个 interface，你可以用它来控制协程，在协程的生命周期中注入自定义行为：\n get_return_object： 控制协程的返回对象 initial_suspend：在协程开始的时候挂起 final_suspend：在协程结束的时候挂起  协程的生命周期如下，用户自定义的函数  被包裹在下面的伪代码中(来源：http://eel.is/c++draft/dcl.fct.def.coroutine#5)：\n{ promise-type promise promise-constructor-arguments ; try { co_await promise.initial_suspend() ; function-body } catch ( ... ) { if (!initial-await-resume-called) throw ; promise.unhandled_exception() ; } final-suspend : co_await promise.final_suspend() ; } // coroutine 被销毁 可以看到，initial_suspend 会在进入协程(也就是函数)之前执行，final_suspend 会在协程返回之前执行。\n如果 final_suspend 真的挂起了协程，那么作为协程的调用者，你需要手动的调用 destroy 来释放协程；如果 final_suspend 没有挂起协程，那么协程将自动销毁。先记住这句话，在后面还会提到。\n除此之外，Promise 还有一些其它责任：\n return_void()/return_value()/yield_value() 方法: 用来控制 co_return 和 co_yield 的行为； unhandled_exception() 处理异常 创建和销毁协程的 stackframe 处理 stackframe 创建可能发生的异常   stackframe ：函数运行时占用的内存空间，是栈上的数据集合，它包括：\n  Local variables Saved copies of registers modified by subprograms that could need restoration Argument parameters Return address  Awaitable 第二个概念是 Awaitable，Awaitable 负责管理协程挂起时的行为。\n一个 Awaitable 对象可以成为 co_await 调用的对象\u0010\u0010。Awaitable 拥有以下方法：\n await_ready()：是否要挂起，如果返回 true，那么 co_await 就不会挂起函数； await_resume()：co_await 的返回值，通常返回空； await_suspend()：协程挂起时的行为；   可以在 await_suspend 中实现 await_ready 的效果，例如直接不挂起当前的协程，但在调用 await_suspend 之前，编译器必须将所有状态捆绑到协程的 stackframe 中，这会更耗时。\n 有时候我们的协程并不需要自定义复杂的行为，C++ 提供了两个默认的 Awaitable：\nnamespace std { struct suspend_never { constexpr bool await_ready() const noexcept { return true; } constexpr void await_suspend(coroutine_handle) const noexcept {} constexpr void await_resume() const noexcept {} }; struct suspend_always { constexpr bool await_ready() const noexcept { return false; } constexpr void await_suspend(coroutine_handle) const noexcept {} constexpr void await_resume() const noexcept {} }; } suspend_always::await_ready() 总是返回 false，而 suspend_always::await_ready() 总是返回 true。其他的方法都是空的，没有任何作用。\n如果没有其它多余的行为，我们可以在函数中直接调用 co_await std::suspend_always{} 来挂起一个函数。\nCoroutine Handle co_await 挂起函数，并创建了一个可调用对象，这个对象可以用来恢复Hanns乎的执行。这个可调用对象的类型就是 std::coroutine_handle，最常用的两个方法是：\n handle.resume()：恢复协程的执行； handle.destroy()：销毁协程；  Coroutine Handle 很像指针，我们可以复制它，但析构函数不会释放相关状态的内存。为了避免内存泄漏，一般要调用 handle.destroy() 来释放（尽管在某些情况下，协程会在完成后自行销毁——前文有提到）。同样像指针一样，一旦销毁了一个 Coroutine Handle ，指向同一个协程的另一个 Coroutine Handle 将指向垃圾，并在调用时表现出未定义行为。\n学习更复杂的用法之前，我们先看下示例。\n示例 #include #include  struct HelloCoroutine { struct HelloPromise { HelloCoroutine get_return_object() { return std::coroutine_handleHelloPromise::from_promise(*this); } std::suspend_never initial_suspend() { return {}; } // 在 final_suspend() 挂起了协程，所以要手动 destroy  std::suspend_always final_suspend() { return {}; } void unhandled_exception() {} }; using promise_type = HelloPromise; HelloCoroutine(std::coroutine_handleHelloPromise h) : handle(h) {} std::coroutine_handleHelloPromise handle; }; HelloCoroutine hello() { std::cout  \"Hello \"  std::endl; co_await std::suspend_always{}; std::cout  \"world!\"  std::endl; } int main() { HelloCoroutine coro = hello(); std::cout  \"calling resume\"  std::endl; coro.handle.resume(); std::cout  \"destroy\"  std::endl; coro.handle.destroy(); return 0; } 这个简短的示例展示了 C++ 实现协程 “Hello world” 程序。我们执行完 “Hello \" 后挂起函数，又在执行 handle.resume() 后恢复函数的运行。\n非常简单，不再过多解释。\nco_yield C++ 协程与一个 Promise 交互之所以如此笨拙，有一个特殊原因就是为了 co_yield。\n如果 promise 是当前协程的 Promise 对象，那么执行：\nco_yield expression; 相当于执行了：\nco_await promise.yield_value(expression); 所以，需要在 promise_type 中添加一个 yield_value 方法。上面的例子可以改为：\n#include #include #include  struct HelloCoroutine { struct HelloPromise { std::string_view value_; HelloCoroutine get_return_object() { return std::coroutine_handleHelloPromise::from_promise(*this); } std::suspend_never initial_suspend() { return {}; } std::suspend_always final_suspend() { return {}; } void unhandled_exception() {} std::suspend_always yield_value(std::string_view value) { value_ = value; std::cout  value_  std::endl; return {}; } }; using promise_type = HelloPromise; HelloCoroutine(std::coroutine_handleHelloPromise h) : handle(h) {} std::coroutine_handleHelloPromise handle; }; HelloCoroutine hello() { std::string_view s = \"Hello \"; co_yield s; std::cout  \"world\"  std::endl; } int main() { HelloCoroutine coro = hello(); std::cout  \"calling resume\"  std::endl; coro.handle.resume(); std::cout  \"destroy\"  std::endl; coro.handle.destroy(); return 0; } 可以用 co_yield 实现 Python 中的生成器，参考：https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type\nco_return 执行 co_return 语句时：\nco_return expression; 相当于执行了：\nco_return promise.return_value(expression); goto end; 下面再给出示例加上 co_return 的版本：\n#include #include  struct HelloCoroutine { struct HelloPromise { HelloCoroutine get_return_object() { return std::coroutine_handleHelloPromise::from_promise(*this); } std::suspend_never initial_suspend() { return {}; } std::suspend_always final_suspend() { return {}; } void unhandled_exception() {} void return_value(int value) { std::cout  \"got co_return value \"  value  std::endl; } }; using promise_type = HelloPromise; HelloCoroutine(std::coroutine_handleHelloPromise h) : handle(h) {} std::coroutine_handleHelloPromise handle; }; HelloCoroutine hello() { std::cout  \"Hello \"  std::endl; co_await std::suspend_always{}; std::cout  \"world!\"  std::endl; co_return 42; } int main() { HelloCoroutine coro = hello(); std::cout  \"calling resume\"  std::endl; coro.handle.resume(); std::cout  \"destroy\"  std::endl; coro.handle.destroy(); return 0; } 复杂一些 到此， Awaitable 和 Coroutine Handle 好像还没有发挥什么作用，我写的示例程序都非常简单。\n如果我们想在协程挂起的时候，做更多的动作，一般将 Coroutine Handle 传到 Awaitable 的 await_suspend() 中，用一个官网的例子展示一下：\n#include #include #include #include  auto switch_to_new_thread(std::jthread\u0026 out) { struct awaitable { std::jthread* p_out; bool await_ready() { return false; } void await_suspend(std::coroutine_handle h) { std::jthread\u0026 out = *p_out; if (out.joinable()) throw std::runtime_error(\"Output jthread parameter not empty\"); out = std::jthread([h] { h.resume(); }); // Potential undefined behavior: accessing potentially destroyed *this  // std::cout get_id()  std::cout  \"New thread ID: \"  out.get_id()  '\\n'; // this is OK  } void await_resume() {} }; return awaitable{\u0026out}; } struct task{ struct promise_type { task get_return_object() { return {}; } std::suspend_never initial_suspend() { return {}; } std::suspend_never final_suspend() noexcept { return {}; } void return_void() {} void unhandled_exception() {} }; }; task resuming_on_new_thread(std::jthread\u0026 out) { std::cout  \"Coroutine started on thread: \"  std::this_thread::get_id()  '\\n'; co_await switch_to_new_thread(out); // awaiter destroyed here  std::cout  \"Coroutine resumed on thread: \"  std::this_thread::get_id()  '\\n'; } int main() { std::jthread out; resuming_on_new_thread(out); } 小结 本文简单介绍了 C++ 协程，希望下次你写 C++ 协程的时候，首先想到这三个东西：\n我不是编程语言专家，对于 C++ 也没有很深入的研究，C++ 在万众期待下终于支持了协程，但用了一下发现，C++ 的协程显得有些\u0010繁琐、怪异，或许是我不清楚 C++ 在原有情况下支持协程的困难，但我依然觉得 C++ 团队可以做得更好。\n我本人确实还没明白到底该如何在项目中使用这臃肿的协程。\n不过，可以预见到的是，我们会在越来越多的 C++ 项目中看到协程的身影。比如 facebook folly 就已经实现了一个实验阶段的协程框架: https://github.com/facebook/folly/tree/master/folly/experimental/coro\n也许等我再研究一段时间，会写一篇到底该如何使用 C++ 协程。\nReference  C++ Coroutine definitions: http://eel.is/c++draft/dcl.fct.def.coroutine#5 C++ draft expr.await: http://eel.is/c++draft/expr.await C++ Coroutines: Understanding the promise type: https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type 官网的例子：https://en.cppreference.com/w/cpp/language/coroutines My tutorial and take on C++20 coroutines：https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html#coroutine-handles  ",
  "wordCount" : "950",
  "inLanguage": "en",
  "datePublished": "2021-03-06T00:00:00Z",
  "dateModified": "2021-03-06T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "多颗糖"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tangwz.com/post/cpp-coroutine/cpp-coroutine/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "多颗糖",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tangwz.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tangwz.com/" accesskey="h" title="多颗糖 (Alt + H)">多颗糖</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tangwz.com/page/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tangwz.com/">Home</a>&nbsp;»&nbsp;<a href="https://tangwz.com/post/">Posts</a></div>
    <h1 class="post-title">
      如何编写 C&#43;&#43; 20 协程(Coroutines)
    </h1>
    <div class="post-meta"><span title='2021-03-06 00:00:00 +0000 UTC'>March 6, 2021</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;多颗糖&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/post/cpp-coroutine/cpp-coroutine.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%bc%96%e8%af%91%e5%99%a8%e6%94%af%e6%8c%81" aria-label="编译器支持">编译器支持</a></li>
                <li>
                    <a href="#c-%e5%8d%8f%e7%a8%8b%e7%ae%80%e4%bb%8b" aria-label="C&#43;&#43; 协程简介">C++ 协程简介</a></li>
                <li>
                    <a href="#promise" aria-label="Promise">Promise</a></li>
                <li>
                    <a href="#awaitable" aria-label="Awaitable">Awaitable</a></li>
                <li>
                    <a href="#coroutine-handle" aria-label="Coroutine Handle">Coroutine Handle</a></li>
                <li>
                    <a href="#%e7%a4%ba%e4%be%8b" aria-label="示例">示例</a></li>
                <li>
                    <a href="#co_yield" aria-label="co_yield"><code>co_yield</code></a></li>
                <li>
                    <a href="#co_return" aria-label="co_return"><code>co_return</code></a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e4%b8%80%e4%ba%9b" aria-label="复杂一些">复杂一些</a></li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a></li>
                <li>
                    <a href="#reference" aria-label="Reference">Reference</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>C++20 带着 Coroutines 来了！</p>
<p>花了一两周的时间后，我想写写 C++20 协程的基本用法，因为 C++ 的协程让我感到很奇怪，写一个协程程序十分费劲。让我们抛去复杂的东西，来看看写一个 C++ 协程需要哪些东西。</p>
<h2 id="编译器支持">编译器支持<a hidden class="anchor" aria-hidden="true" href="#编译器支持">#</a></h2>
<p>由于 C++ 20 还没被所有编译器完全支持，首先需要确保你的编译器实现了 Coroutines，可以通过下面的网站查看编译器支持情况：https://en.cppreference.com/w/cpp/compiler_support#cpp20</p>
<p>值得一提，我使用的 MacOS 自带的 Apple Clang 对 C++20 支持很弱，我选择通过 Homebrew 安装最新版的 GNU GCC (10 以上版本)来编译。</p>
<p>我使用的 GNU GCC 10.2 版本编译指令：</p>
<pre tabindex="0"><code>g++ -fcoroutines -std=c++20
</code></pre><p><strong>Clang 支持不够好，不推荐使用</strong>。Clang 可以使用如下命令编译：</p>
<pre tabindex="0"><code>clang++ -std=c++20 -stdlib=libc++ -fcoroutines-ts
</code></pre><p>不推荐 Clang 还有一个理由：使用 Clang 需要 include 头文件 <code>&lt;experimental/coroutine&gt; </code> 而不是 <code>&lt;coroutine&gt;</code>。此外，一些类型被命名为 <code>std::experimental:xxx</code> 而不是 <code>std:xxx</code>。</p>
<p>以下示例代码只支持 GNU GCC 版本的编译器。</p>
<h2 id="c-协程简介">C++ 协程简介<a hidden class="anchor" aria-hidden="true" href="#c-协程简介">#</a></h2>
<p>在正式开始之前，我们先要理解 C++20 中协程使用的一些术语。#</p>
<p>首先，什么是协程？</p>
<p>协程就是一个可以**挂起(suspend)<strong>和</strong>恢复(resume)**的函数(但无论如何不能是 main 函数)。你可以暂停协程的执行，去做其他事情，然后在适当的时候恢复到暂停的位置继续执行。<strong>协程让我们使用同步方式写异步代码</strong>。</p>
<p>怎么挂起协程呢？C++ 提供了三个方法：<code>co_await</code>, <code>co_yield</code> 和 <code>co_return</code>。</p>
<blockquote>
<p>顺便说一句：coroutine 不是并行(parallelism)，和 Go 语言的 goroutine 不一样！</p>
</blockquote>
<p>与你之前接触到的协程完全不同，一个 C++ 协程一般长这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ReturnObject</span> {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">promise_type</span> {
        ReturnObject <span style="color:#a6e22e">get_return_object</span>() { <span style="color:#66d9ef">return</span> {}; }
        std<span style="color:#f92672">::</span>suspend_never initial_suspend() { <span style="color:#66d9ef">return</span> {}; }
        std<span style="color:#f92672">::</span>suspend_never final_suspend() { <span style="color:#66d9ef">return</span> {}; }
        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unhandled_exception</span>() {}
    };
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Awaitable</span> {
    std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span> <span style="color:#f92672">*</span>hp_;
    <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">await_ready</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> { <span style="color:#66d9ef">return</span> false; }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_suspend</span>(std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span> h) { <span style="color:#f92672">*</span>hp_ <span style="color:#f92672">=</span> h; }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_resume</span>() <span style="color:#66d9ef">noexcept</span> {
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Event signaled, resuming.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    }
};

ReturnObject <span style="color:#a6e22e">counter</span>(std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span> <span style="color:#f92672">*</span>continuation_out) {
    Awaitable a{continuation_out};
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;; <span style="color:#f92672">++</span>i) {
        <span style="color:#66d9ef">co_await</span> a;
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;counter: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    }
}
</code></pre></div><p>这奇怪的协程代码涉及了 C++ 协程很重要的三个概念：</p>
<ul>
<li><code>promise_type</code></li>
<li><code>Awaitable</code></li>
<li><code>std::coroutine_handle&lt;&gt;</code></li>
</ul>
<p>在写 C++20 的协程之前，我们必须需要先了解三个概念，可以用这三张图来形容这三个概念：</p>
<p><img loading="lazy" src="https://i.loli.net/2021/03/06/9om1brcaIDQl374.jpg" alt=""  />

图来源: <a href="https://www.youtube.com/watch?v=vzC2iRfO_H8">https://www.youtube.com/watch?v=vzC2iRfO_H8</a></p>
<h2 id="promise">Promise<a hidden class="anchor" aria-hidden="true" href="#promise">#</a></h2>
<p>C++ 协程的<strong>返回类型</strong>必须是 <code>promise_type</code>，<code>promise_type</code> 是一个 interface，你可以用它来控制协程，在协程的生命周期中注入自定义行为：</p>
<ul>
<li><code>get_return_object</code>： 控制协程的返回对象</li>
<li><code>initial_suspend</code>：在协程开始的时候挂起</li>
<li><code>final_suspend</code>：在协程结束的时候挂起</li>
</ul>
<p>协程的生命周期如下，用户自定义的函数 <code>&lt;function-body&gt;</code> 被包裹在下面的伪代码中(来源：http://eel.is/c++draft/dcl.fct.def.coroutine#5)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">{
   promise<span style="color:#f92672">-</span>type promise promise<span style="color:#f92672">-</span>constructor<span style="color:#f92672">-</span>arguments ;
   <span style="color:#66d9ef">try</span> {
      <span style="color:#66d9ef">co_await</span> promise.initial_suspend() ;
      <span style="color:#f92672">&lt;</span>function<span style="color:#f92672">-</span>body<span style="color:#f92672">&gt;</span>
   } <span style="color:#66d9ef">catch</span> ( ... ) {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>initial<span style="color:#f92672">-</span>await<span style="color:#f92672">-</span>resume<span style="color:#f92672">-</span>called)
         <span style="color:#66d9ef">throw</span> ;
      promise.unhandled_exception() ;
   }
<span style="color:#66d9ef">final</span><span style="color:#f92672">-</span>suspend :
   <span style="color:#66d9ef">co_await</span> promise.final_suspend() ;
}

<span style="color:#75715e">// coroutine 被销毁
</span></code></pre></div><p>可以看到，<code>initial_suspend</code> 会在进入协程(也就是函数)之前执行，<code>final_suspend</code> 会在协程返回之前执行。</p>
<p>如果 <code>final_suspend</code> 真的挂起了协程，那么作为协程的调用者，你需要手动的调用 destroy 来释放协程；如果 <code>final_suspend</code> 没有挂起协程，那么协程将自动销毁。先记住这句话，在后面还会提到。</p>
<p>除此之外，Promise 还有一些其它责任：</p>
<ul>
<li><code>return_void()</code>/<code>return_value()</code>/<code>yield_value()</code> 方法: 用来控制 <code>co_return</code> 和 <code>co_yield</code> 的行为；</li>
<li><code>unhandled_exception()</code> 处理异常</li>
<li>创建和销毁协程的 <code>stackframe</code></li>
<li>处理 <code>stackframe</code> 创建可能发生的异常</li>
</ul>
<blockquote>
<p>stackframe ：函数运行时占用的内存空间，是栈上的数据集合，它包括：</p>
</blockquote>
<ul>
<li>Local variables</li>
<li>Saved copies of registers modified by subprograms that could need restoration</li>
<li>Argument parameters</li>
<li>Return address</li>
</ul>
<h2 id="awaitable">Awaitable<a hidden class="anchor" aria-hidden="true" href="#awaitable">#</a></h2>
<p>第二个概念是 <code>Awaitable</code>，<code>Awaitable</code> 负责管理协程挂起时的行为。</p>
<p>一个 Awaitable 对象可以成为 <code>co_await</code> 调用的对象。Awaitable 拥有以下方法：</p>
<ul>
<li><code>await_ready()</code>：是否要挂起，如果返回 true，那么 <code>co_await</code> 就不会挂起函数；</li>
<li><code>await_resume()</code>：<code>co_await</code> 的返回值，通常返回空；</li>
<li><code>await_suspend()</code>：协程挂起时的行为；</li>
</ul>
<blockquote>
<p>可以在 <code>await_suspend</code> 中实现 <code>await_ready</code> 的效果，例如直接不挂起当前的协程，但在调用 <code>await_suspend</code> 之前，编译器必须将所有状态捆绑到协程的 <code>stackframe</code> 中，这会更耗时。</p>
</blockquote>
<p>有时候我们的协程并不需要自定义复杂的行为，C++ 提供了两个默认的 <code>Awaitable</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">namespace</span> std {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">suspend_never</span> {
        <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">await_ready</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> { <span style="color:#66d9ef">return</span> true; }
        <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_suspend</span>(coroutine_handle<span style="color:#f92672">&lt;&gt;</span>) <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {}
        <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_resume</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {}
    };
    
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">suspend_always</span> {
        <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">await_ready</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> { <span style="color:#66d9ef">return</span> false; } 
        <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_suspend</span>(coroutine_handle<span style="color:#f92672">&lt;&gt;</span>) <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {}
        <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_resume</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {}
    };
}
</code></pre></div><p><code>suspend_always::await_ready()</code> 总是返回 false，而 <code>suspend_always::await_ready()</code> 总是返回 true。其他的方法都是空的，没有任何作用。</p>
<p>如果没有其它多余的行为，我们可以在函数中直接调用 <code>co_await std::suspend_always{}</code> 来挂起一个函数。</p>
<h2 id="coroutine-handle">Coroutine Handle<a hidden class="anchor" aria-hidden="true" href="#coroutine-handle">#</a></h2>
<p><code>co_await</code> 挂起函数，并创建了一个可调用对象，这个对象可以用来恢复Hanns乎的执行。这个可调用对象的类型就是 <code>std::coroutine_handle&lt;&gt;</code>，最常用的两个方法是：</p>
<ul>
<li><code>handle.resume()</code>：恢复协程的执行；</li>
<li><code>handle.destroy()</code>：销毁协程；</li>
</ul>
<p><code>Coroutine Handle</code> 很像指针，我们可以复制它，但析构函数不会释放相关状态的内存。为了避免内存泄漏，一般要调用 <code>handle.destroy()</code> 来释放（尽管在某些情况下，协程会在完成后自行销毁——前文有提到）。同样像指针一样，一旦销毁了一个 <code>Coroutine Handle</code> ，指向同一个协程的另一个 <code>Coroutine Handle</code> 将指向垃圾，并在调用时表现出未定义行为。</p>
<p>学习更复杂的用法之前，我们先看下示例。</p>
<h2 id="示例">示例<a hidden class="anchor" aria-hidden="true" href="#示例">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;coroutine&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HelloCoroutine</span> {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HelloPromise</span> {
        HelloCoroutine <span style="color:#a6e22e">get_return_object</span>() {
            <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>HelloPromise<span style="color:#f92672">&gt;::</span>from_promise(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
        }
        std<span style="color:#f92672">::</span>suspend_never initial_suspend() { <span style="color:#66d9ef">return</span> {}; }
        <span style="color:#75715e">// 在 final_suspend() 挂起了协程，所以要手动 destroy
</span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>suspend_always final_suspend() { <span style="color:#66d9ef">return</span> {}; }
        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unhandled_exception</span>() {}
    };

    <span style="color:#66d9ef">using</span> promise_type <span style="color:#f92672">=</span> HelloPromise;
    HelloCoroutine(std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>HelloPromise<span style="color:#f92672">&gt;</span> h) <span style="color:#f92672">:</span> handle(h) {}

    std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>HelloPromise<span style="color:#f92672">&gt;</span> handle;
};

HelloCoroutine <span style="color:#a6e22e">hello</span>() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    <span style="color:#66d9ef">co_await</span> std<span style="color:#f92672">::</span>suspend_always{};
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;world!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    HelloCoroutine coro <span style="color:#f92672">=</span> hello();
    
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;calling resume&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    coro.handle.resume();
    
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destroy&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    coro.handle.destroy();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>这个简短的示例展示了 C++ 实现协程 &ldquo;Hello world&rdquo; 程序。我们执行完 &ldquo;Hello &quot; 后挂起函数，又在执行 <code>handle.resume()</code> 后恢复函数的运行。</p>
<p>非常简单，不再过多解释。</p>
<h2 id="co_yield"><code>co_yield</code><a hidden class="anchor" aria-hidden="true" href="#co_yield">#</a></h2>
<p>C++ 协程与一个 Promise 交互之所以如此笨拙，有一个特殊原因就是为了 <code>co_yield</code>。</p>
<p>如果 promise 是当前协程的 Promise 对象，那么执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">co_yield</span> <span style="color:#f92672">&lt;</span>expression<span style="color:#f92672">&gt;</span>;
</code></pre></div><p>相当于执行了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">co_await</span> promise.yield_value(<span style="color:#f92672">&lt;</span>expression<span style="color:#f92672">&gt;</span>);
</code></pre></div><p>所以，需要在 promise_type 中添加一个 <code>yield_value</code> 方法。上面的例子可以改为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;coroutine&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string_view&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HelloCoroutine</span> {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HelloPromise</span> {
        std<span style="color:#f92672">::</span>string_view value_;

        HelloCoroutine <span style="color:#a6e22e">get_return_object</span>() {
            <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>HelloPromise<span style="color:#f92672">&gt;::</span>from_promise(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
        }
        std<span style="color:#f92672">::</span>suspend_never initial_suspend() { <span style="color:#66d9ef">return</span> {}; }
        std<span style="color:#f92672">::</span>suspend_always final_suspend() { <span style="color:#66d9ef">return</span> {}; }
        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unhandled_exception</span>() {}

        std<span style="color:#f92672">::</span>suspend_always yield_value(std<span style="color:#f92672">::</span>string_view value) {
            value_ <span style="color:#f92672">=</span> value;
            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> value_ <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
            <span style="color:#66d9ef">return</span> {};
        }
    };

    <span style="color:#66d9ef">using</span> promise_type <span style="color:#f92672">=</span> HelloPromise;
    HelloCoroutine(std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>HelloPromise<span style="color:#f92672">&gt;</span> h) <span style="color:#f92672">:</span> handle(h) {}

    std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>HelloPromise<span style="color:#f92672">&gt;</span> handle;
};

HelloCoroutine <span style="color:#a6e22e">hello</span>() {
    std<span style="color:#f92672">::</span>string_view s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello &#34;</span>;
    <span style="color:#66d9ef">co_yield</span> s;

    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;world&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    HelloCoroutine coro <span style="color:#f92672">=</span> hello();

    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;calling resume&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    coro.handle.resume();

    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destroy&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    coro.handle.destroy();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>可以用 <code>co_yield</code> 实现 Python 中的生成器，参考：https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type</p>
<h2 id="co_return"><code>co_return</code><a hidden class="anchor" aria-hidden="true" href="#co_return">#</a></h2>
<p>执行 <code>co_return</code> 语句时：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">co_return</span> <span style="color:#f92672">&lt;</span>expression<span style="color:#f92672">&gt;</span>;
</code></pre></div><p>相当于执行了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">co_return</span> promise.return_value(<span style="color:#f92672">&lt;</span>expression<span style="color:#f92672">&gt;</span>); <span style="color:#66d9ef">goto</span> end;
</code></pre></div><p>下面再给出示例加上 <code>co_return</code> 的版本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;coroutine&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HelloCoroutine</span> {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HelloPromise</span> {
        HelloCoroutine <span style="color:#a6e22e">get_return_object</span>() {
            <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>HelloPromise<span style="color:#f92672">&gt;::</span>from_promise(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
        }
        std<span style="color:#f92672">::</span>suspend_never initial_suspend() { <span style="color:#66d9ef">return</span> {}; }
        std<span style="color:#f92672">::</span>suspend_always final_suspend() { <span style="color:#66d9ef">return</span> {}; }
        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unhandled_exception</span>() {}

        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">return_value</span>(<span style="color:#66d9ef">int</span> value) { 
            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;got co_return value &#34;</span> <span style="color:#f92672">&lt;&lt;</span> value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; 
        }
    };

    <span style="color:#66d9ef">using</span> promise_type <span style="color:#f92672">=</span> HelloPromise;
    HelloCoroutine(std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>HelloPromise<span style="color:#f92672">&gt;</span> h) <span style="color:#f92672">:</span> handle(h) {}

    std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>HelloPromise<span style="color:#f92672">&gt;</span> handle;
};

HelloCoroutine <span style="color:#a6e22e">hello</span>() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    <span style="color:#66d9ef">co_await</span> std<span style="color:#f92672">::</span>suspend_always{};
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;world!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    <span style="color:#66d9ef">co_return</span> <span style="color:#ae81ff">42</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    HelloCoroutine coro <span style="color:#f92672">=</span> hello();
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;calling resume&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;

    coro.handle.resume();
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destroy&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    coro.handle.destroy();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="复杂一些">复杂一些<a hidden class="anchor" aria-hidden="true" href="#复杂一些">#</a></h2>
<p>到此， <code>Awaitable</code> 和 <code>Coroutine Handle</code> 好像还没有发挥什么作用，我写的示例程序都非常简单。</p>
<p>如果我们想在协程挂起的时候，做更多的动作，一般将 <code>Coroutine Handle</code> 传到 Awaitable 的 <code>await_suspend()</code> 中，用一个<a href="https://en.cppreference.com/w/cpp/language/coroutines">官网的例子</a>展示一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;coroutine&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdexcept&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">switch_to_new_thread</span>(std<span style="color:#f92672">::</span>jthread<span style="color:#f92672">&amp;</span> out) {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">awaitable</span> {
    std<span style="color:#f92672">::</span>jthread<span style="color:#f92672">*</span> p_out;
    <span style="color:#66d9ef">bool</span> await_ready() { <span style="color:#66d9ef">return</span> false; }
    <span style="color:#66d9ef">void</span> await_suspend(std<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span> h) {
      std<span style="color:#f92672">::</span>jthread<span style="color:#f92672">&amp;</span> out <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>p_out;
      <span style="color:#66d9ef">if</span> (out.joinable())
        <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(<span style="color:#e6db74">&#34;Output jthread parameter not empty&#34;</span>);
      out <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>jthread([h] { h.resume(); });
      <span style="color:#75715e">// Potential undefined behavior: accessing potentially destroyed *this
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// std::cout &lt;&lt; &#34;New thread ID: &#34; &lt;&lt; p_out-&gt;get_id() &lt;&lt; &#39;\n&#39;;
</span><span style="color:#75715e"></span>      std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;New thread ID: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> out.get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; <span style="color:#75715e">// this is OK
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">void</span> await_resume() {}
  };
  <span style="color:#66d9ef">return</span> awaitable{<span style="color:#f92672">&amp;</span>out};
}
 
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">task</span>{
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">promise_type</span> {
    task <span style="color:#a6e22e">get_return_object</span>() { <span style="color:#66d9ef">return</span> {}; }
    std<span style="color:#f92672">::</span>suspend_never initial_suspend() { <span style="color:#66d9ef">return</span> {}; }
    std<span style="color:#f92672">::</span>suspend_never final_suspend() <span style="color:#66d9ef">noexcept</span> { <span style="color:#66d9ef">return</span> {}; }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">return_void</span>() {}
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unhandled_exception</span>() {}
  };
};
 
task <span style="color:#a6e22e">resuming_on_new_thread</span>(std<span style="color:#f92672">::</span>jthread<span style="color:#f92672">&amp;</span> out) {
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Coroutine started on thread: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
  <span style="color:#66d9ef">co_await</span> switch_to_new_thread(out);
  <span style="color:#75715e">// awaiter destroyed here
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Coroutine resumed on thread: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  std<span style="color:#f92672">::</span>jthread out;
  resuming_on_new_thread(out);
}
</code></pre></div><h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>本文简单介绍了 C++ 协程，希望下次你写 C++ 协程的时候，首先想到这三个东西：</p>
<p><img loading="lazy" src="https://i.loli.net/2021/03/06/9om1brcaIDQl374.jpg" alt=""  />
</p>
<p>我不是编程语言专家，对于 C++ 也没有很深入的研究，C++ 在万众期待下终于支持了协程，但用了一下发现，C++ 的协程显得有些繁琐、怪异，或许是我不清楚 C++ 在原有情况下支持协程的困难，但我依然觉得 C++ 团队可以做得更好。</p>
<p>我本人确实还没明白到底该如何在项目中使用这臃肿的协程。</p>
<p>不过，可以预见到的是，我们会在越来越多的 C++ 项目中看到协程的身影。比如 facebook folly 就已经实现了一个实验阶段的协程框架: <a href="https://github.com/facebook/folly/tree/master/folly/experimental/coro">https://github.com/facebook/folly/tree/master/folly/experimental/coro</a></p>
<p>也许等我再研究一段时间，会写一篇到底该如何使用 C++ 协程。</p>
<h2 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h2>
<ul>
<li>C++ Coroutine definitions: <a href="http://eel.is/c++draft/dcl.fct.def.coroutine#5">http://eel.is/c++draft/dcl.fct.def.coroutine#5</a></li>
<li>C++ draft expr.await: <a href="http://eel.is/c++draft/expr.await">http://eel.is/c++draft/expr.await</a></li>
<li>C++ Coroutines: Understanding the promise type: <a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type</a></li>
<li>官网的例子：https://en.cppreference.com/w/cpp/language/coroutines</li>
<li>My tutorial and take on C++20 coroutines：https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html#coroutine-handles</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tangwz.com/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://tangwz.com/post/raft-extension/">
    <span class="title">Next Page »</span>
    <br>
    <span>条分缕析 Raft 算法(续)：日志压缩和性能优化</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 如何编写 C&#43;&#43; 20 协程(Coroutines) on twitter"
        href="https://twitter.com/intent/tweet/?text=%e5%a6%82%e4%bd%95%e7%bc%96%e5%86%99%20C%2b%2b%2020%20%e5%8d%8f%e7%a8%8b%28Coroutines%29&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fcpp-coroutine%2fcpp-coroutine%2f&amp;hashtags=C%2b%2b">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 如何编写 C&#43;&#43; 20 协程(Coroutines) on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fcpp-coroutine%2fcpp-coroutine%2f&amp;title=%e5%a6%82%e4%bd%95%e7%bc%96%e5%86%99%20C%2b%2b%2020%20%e5%8d%8f%e7%a8%8b%28Coroutines%29&amp;summary=%e5%a6%82%e4%bd%95%e7%bc%96%e5%86%99%20C%2b%2b%2020%20%e5%8d%8f%e7%a8%8b%28Coroutines%29&amp;source=https%3a%2f%2ftangwz.com%2fpost%2fcpp-coroutine%2fcpp-coroutine%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 如何编写 C&#43;&#43; 20 协程(Coroutines) on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ftangwz.com%2fpost%2fcpp-coroutine%2fcpp-coroutine%2f&title=%e5%a6%82%e4%bd%95%e7%bc%96%e5%86%99%20C%2b%2b%2020%20%e5%8d%8f%e7%a8%8b%28Coroutines%29">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 如何编写 C&#43;&#43; 20 协程(Coroutines) on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftangwz.com%2fpost%2fcpp-coroutine%2fcpp-coroutine%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 如何编写 C&#43;&#43; 20 协程(Coroutines) on whatsapp"
        href="https://api.whatsapp.com/send?text=%e5%a6%82%e4%bd%95%e7%bc%96%e5%86%99%20C%2b%2b%2020%20%e5%8d%8f%e7%a8%8b%28Coroutines%29%20-%20https%3a%2f%2ftangwz.com%2fpost%2fcpp-coroutine%2fcpp-coroutine%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 如何编写 C&#43;&#43; 20 协程(Coroutines) on telegram"
        href="https://telegram.me/share/url?text=%e5%a6%82%e4%bd%95%e7%bc%96%e5%86%99%20C%2b%2b%2020%20%e5%8d%8f%e7%a8%8b%28Coroutines%29&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fcpp-coroutine%2fcpp-coroutine%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://tangwz.com/">多颗糖</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
