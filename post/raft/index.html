<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>条分缕析 Raft 算法 | 多颗糖</title>
<meta name="keywords" content="分布式" />
<meta name="description" content="本文整理自 Ongaro 在 Youtube 上的视频。
目标 Raft 的目标（或者说是分布式共识算法的目标）是：保证 log 完全相同地复制到多台服务器上。
只要每台服务器的日志相同，那么，在不同服务器上的状态机以相同顺序从日志中执行相同的命令，将会产生相同的结果。
共识算法的工作就是管理这些日志。
系统模型 我们假设：
 服务器可能会宕机、会停止运行过段时间再恢复，但是非拜占庭的（即它的行为是非恶意的，不会篡改数据等）； 网络通信会中断，消息可能会丢失、延迟或乱序；可能会网络分区；  Raft 是基于 Leader 的共识算法，故主要考虑：
 Leader 正常运行 Leader 故障，必须选出新的 Leader  优点：只有一个 Leader，简单。
难点：Leader 发生改变时，可能会使系统处于不一致的状态，因此，下一任 Leader 必须进行清理；
我们将从 6 个部分解释 Raft：
 Leader 选举； 正常运行：日志复制（最简单的部分）； Leader 变更时的安全性和一致性（最棘手、最关键的部分）； 处理旧 Leader：旧的 Leader 并没有真的下线怎么办？ 客户端交互：实现线性化语义(linearizable semantics)； 配置变更：如何在集群中增加或删除节点；  开始之前 开始之前需要了解 Raft 的一些术语。
服务器状态 服务器在任意时间只能处于以下三种状态之一：
 Leader：处理所有客户端请求、日志复制。同一时刻最多只能有一个可行的 Leader； Follower：完全被动的（不发送 RPC，只响应收到的 RPC）——大多数服务器在大多数情况下处于此状态； Candidate：用来选举新的 Leader，处于 Leader 和 Follower 之间的暂时状态；  系统正常运行时，只有一个 Leader，其余都是 Followers.">
<meta name="author" content="多颗糖">
<link rel="canonical" href="https://tangwz.com/post/raft/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://tangwz.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tangwz.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tangwz.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tangwz.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://tangwz.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.4" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-72128068-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="条分缕析 Raft 算法" />
<meta property="og:description" content="本文整理自 Ongaro 在 Youtube 上的视频。
目标 Raft 的目标（或者说是分布式共识算法的目标）是：保证 log 完全相同地复制到多台服务器上。
只要每台服务器的日志相同，那么，在不同服务器上的状态机以相同顺序从日志中执行相同的命令，将会产生相同的结果。
共识算法的工作就是管理这些日志。
系统模型 我们假设：
 服务器可能会宕机、会停止运行过段时间再恢复，但是非拜占庭的（即它的行为是非恶意的，不会篡改数据等）； 网络通信会中断，消息可能会丢失、延迟或乱序；可能会网络分区；  Raft 是基于 Leader 的共识算法，故主要考虑：
 Leader 正常运行 Leader 故障，必须选出新的 Leader  优点：只有一个 Leader，简单。
难点：Leader 发生改变时，可能会使系统处于不一致的状态，因此，下一任 Leader 必须进行清理；
我们将从 6 个部分解释 Raft：
 Leader 选举； 正常运行：日志复制（最简单的部分）； Leader 变更时的安全性和一致性（最棘手、最关键的部分）； 处理旧 Leader：旧的 Leader 并没有真的下线怎么办？ 客户端交互：实现线性化语义(linearizable semantics)； 配置变更：如何在集群中增加或删除节点；  开始之前 开始之前需要了解 Raft 的一些术语。
服务器状态 服务器在任意时间只能处于以下三种状态之一：
 Leader：处理所有客户端请求、日志复制。同一时刻最多只能有一个可行的 Leader； Follower：完全被动的（不发送 RPC，只响应收到的 RPC）——大多数服务器在大多数情况下处于此状态； Candidate：用来选举新的 Leader，处于 Leader 和 Follower 之间的暂时状态；  系统正常运行时，只有一个 Leader，其余都是 Followers." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tangwz.com/post/raft/" /><meta property="og:image" content="https://tangwz.com/"/><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-02-01T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-02-01T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://tangwz.com/"/>

<meta name="twitter:title" content="条分缕析 Raft 算法"/>
<meta name="twitter:description" content="本文整理自 Ongaro 在 Youtube 上的视频。
目标 Raft 的目标（或者说是分布式共识算法的目标）是：保证 log 完全相同地复制到多台服务器上。
只要每台服务器的日志相同，那么，在不同服务器上的状态机以相同顺序从日志中执行相同的命令，将会产生相同的结果。
共识算法的工作就是管理这些日志。
系统模型 我们假设：
 服务器可能会宕机、会停止运行过段时间再恢复，但是非拜占庭的（即它的行为是非恶意的，不会篡改数据等）； 网络通信会中断，消息可能会丢失、延迟或乱序；可能会网络分区；  Raft 是基于 Leader 的共识算法，故主要考虑：
 Leader 正常运行 Leader 故障，必须选出新的 Leader  优点：只有一个 Leader，简单。
难点：Leader 发生改变时，可能会使系统处于不一致的状态，因此，下一任 Leader 必须进行清理；
我们将从 6 个部分解释 Raft：
 Leader 选举； 正常运行：日志复制（最简单的部分）； Leader 变更时的安全性和一致性（最棘手、最关键的部分）； 处理旧 Leader：旧的 Leader 并没有真的下线怎么办？ 客户端交互：实现线性化语义(linearizable semantics)； 配置变更：如何在集群中增加或删除节点；  开始之前 开始之前需要了解 Raft 的一些术语。
服务器状态 服务器在任意时间只能处于以下三种状态之一：
 Leader：处理所有客户端请求、日志复制。同一时刻最多只能有一个可行的 Leader； Follower：完全被动的（不发送 RPC，只响应收到的 RPC）——大多数服务器在大多数情况下处于此状态； Candidate：用来选举新的 Leader，处于 Leader 和 Follower 之间的暂时状态；  系统正常运行时，只有一个 Leader，其余都是 Followers."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tangwz.com/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "条分缕析 Raft 算法",
      "item": "https://tangwz.com/post/raft/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "条分缕析 Raft 算法",
  "name": "条分缕析 Raft 算法",
  "description": "本文整理自 Ongaro 在 Youtube 上的视频。\n目标 Raft 的目标（或者说是分布式共识算法的目标）是：保证 log 完全相同地复制到多台服务器上。\n只要每台服务器的日志相同，那么，在不同服务器上的状态机以相同顺序从日志中执行相同的命令，将会产生相同的结果。\n共识算法的工作就是管理这些日志。\n系统模型 我们假设：\n 服务器可能会宕机、会停止运行过段时间再恢复，但是非拜占庭的（即它的行为是非恶意的，不会篡改数据等）； 网络通信会中断，消息可能会丢失、延迟或乱序；可能会网络分区；  Raft 是基于 Leader 的共识算法，故主要考虑：\n Leader 正常运行 Leader 故障，必须选出新的 Leader  优点：只有一个 Leader，简单。\n难点：Leader 发生改变时，可能会使系统处于不一致的状态，因此，下一任 Leader 必须进行清理；\n我们将从 6 个部分解释 Raft：\n Leader 选举； 正常运行：日志复制（最简单的部分）； Leader 变更时的安全性和一致性（最棘手、最关键的部分）； 处理旧 Leader：旧的 Leader 并没有真的下线怎么办？ 客户端交互：实现线性化语义(linearizable semantics)； 配置变更：如何在集群中增加或删除节点；  开始之前 开始之前需要了解 Raft 的一些术语。\n服务器状态 服务器在任意时间只能处于以下三种状态之一：\n Leader：处理所有客户端请求、日志复制。同一时刻最多只能有一个可行的 Leader； Follower：完全被动的（不发送 RPC，只响应收到的 RPC）——大多数服务器在大多数情况下处于此状态； Candidate：用来选举新的 Leader，处于 Leader 和 Follower 之间的暂时状态；  系统正常运行时，只有一个 Leader，其余都是 Followers.",
  "keywords": [
    "分布式"
  ],
  "articleBody": "本文整理自 Ongaro 在 Youtube 上的视频。\n目标 Raft 的目标（或者说是分布式共识算法的目标）是：保证 log 完全相同地复制到多台服务器上。\n只要每台服务器的日志相同，那么，在不同服务器上的状态机以相同顺序从日志中执行相同的命令，将会产生相同的结果。\n共识算法的工作就是管理这些日志。\n系统模型 我们假设：\n 服务器可能会宕机、会停止运行过段时间再恢复，但是非拜占庭的（即它的行为是非恶意的，不会篡改数据等）； 网络通信会中断，消息可能会丢失、延迟或乱序；可能会网络分区；  Raft 是基于 Leader 的共识算法，故主要考虑：\n Leader 正常运行 Leader 故障，必须选出新的 Leader  优点：只有一个 Leader，简单。\n难点：Leader 发生改变时，可能会使系统处于不一致的状态，因此，下一任 Leader 必须进行清理；\n我们将从 6 个部分解释 Raft：\n Leader 选举； 正常运行：日志复制（最简单的部分）； Leader 变更时的安全性和一致性（最棘手、最关键的部分）； 处理旧 Leader：旧的 Leader 并没有真的下线怎么办？ 客户端交互：实现线性化语义(linearizable semantics)； 配置变更：如何在集群中增加或删除节点；  开始之前 开始之前需要了解 Raft 的一些术语。\n服务器状态 服务器在任意时间只能处于以下三种状态之一：\n Leader：处理所有客户端请求、日志复制。同一时刻最多只能有一个可行的 Leader； Follower：完全被动的（不发送 RPC，只响应收到的 RPC）——大多数服务器在大多数情况下处于此状态； Candidate：用来选举新的 Leader，处于 Leader 和 Follower 之间的暂时状态；  系统正常运行时，只有一个 Leader，其余都是 Followers.\n状态转换图：\n任期 时间被划分成一个个的任期(Term)，每个任期都由一个数字来表示任期号，任期号单调递增并且永远不会重复。\n一个正常的任期至少有一个 Leader，通常分为两部分：\n 任期开始时的选举过程； 正常运行的部分；  有些任期可能没有选出 Leader（如图 Term 3），这时候会立即进入下一个任期，再次尝试选出一个 Leader。\n每个节点维护一个 currentTerm 变量，表示系统中当前任期。currentTerm 必须持久化存储，以便在服务器宕机重启时将其恢复。\n**任期非常重要！任期能够帮助 Raft 识别过期的信息。**例如：如果 currentTerm = 2 的节点与 currentTerm = 3 的节点通信，我们可以知道第一个节点上的信息是过时的。\n我们只使用最新任期的信息。后面我们会遇到各种情况，去检测和消除不是最新任期的信息。\n两个 RPC Raft 中服务器之间所有类型的通信通过两个 RPC 调用：\n RequestVote：用于选举； AppendEntries：用于复制 log 和发送心跳；  1. Leader 选举 启动  节点启动时，都是 Follower 状态； Follower 被动地接受 Leader 或 Candidate 的 RPC； 所以，如果 Leader 想要保持权威，必须向集群中的其它节点发送心跳包（空的 AppendEntries RPC）； 等待选举超时(electionTimeout，一般在 100~500ms)后，Follower 没有收到任何 RPC：  Follower 认为集群中没有 Leader 开始新的一轮选举    选举 当一个节点开始竞选：\n 增加自己的 currentTerm 转为 Candidate 状态，其目标是获取超过半数节点的选票，让自己成为 Leader 先给自己投一票 并行地向集群中其它节点发送 RequestVote RPC 索要选票，如果没有收到指定节点的响应，它会反复尝试，直到发生以下三种情况之一：   获得超过半数的选票：成为 Leader，并向其它节点发送 AppendEntries 心跳； 收到来自 Leader 的 RPC：转为 Follower； 其它两种情况都没发生，没人能够获胜(electionTimeout 已过)：增加 currentTerm，开始新一轮选举；  流程图如下： 选举安全性 选举过程需要保证两个特性：安全性(safety)和活性(liveness)。\n安全性(safety)：一个任期内只会有一个 Leader 被选举出来。需要保证：\n 每个节点在同一任期内只能投一次票，它将投给第一个满足条件的投票请求，然后拒绝其它 Candidate 的请求。这需要持久化存储投票信息 votedFor，以便宕机重启后恢复，否则重启后 votedFor 丢失会导致投给别的节点； 只有获得超过半数节点的选票才能成为 Leader，也就是说，两个不同的 Candidate 无法在同一任期内都获得超过半数的票；  活性(liveness)：确保最终能选出一个 Leader。\n问题是：原则上我们可以无限重复分割选票，假如选举同一时间开始，同一时间超时，同一时间再次选举，如此循环。\n解决办法很简单：\n 节点随机选择超时时间，通常在 [T, 2T] 之间（T = electionTimeout） 这样，节点不太可能再同时开始竞选，先竞选的节点有足够的时间来索要其他节点的选票 T » broadcast time(T 远大于广播时间)时效果更佳  2. 日志复制 日志结构 每个节点存储自己的日志副本(log[])，每条日志记录包含：\n 索引：该记录在日志中的位置 任期号：该记录首次被创建时的任期号 命令  **日志必须持久化存储。**一个节点必须先将记录安全写到磁盘，才能向系统中其他节点返回响应。\n如果一条日志记录被存储在超过半数的节点上，我们认为该记录已提交(committed)——这是 Raft 非常重要的特性！如果一条记录已提交，意味着状态机可以安全地执行该记录。\n在上图中，第 1-7 条记录被提交，第 8 条尚未提交。\n 提醒：多数派复制了日志即已提交，这个定义并不精确，我们会在后面稍作修改。\n 正常运行  客户端向 Leader 发送命令，希望该命令被所有状态机执行； Leader 先将该命令追加到自己的日志中； Leader 并行地向其它节点发送 AppendEntries RPC，等待响应； 收到超过半数节点的响应，则认为新的日志记录是被提交的：  Leader 将命令传给自己的状态机，然后向客户端返回响应 此外，一旦 Leader 知道一条记录被提交了，将在后续的 AppendEntries RPC 中通知已经提交记录的 Followers Follower 将已提交的命令传给自己的状态机   如果 Follower 宕机/超时：Leader 将反复尝试发送 RPC； 性能优化：Leader 不必等待每个 Follower 做出响应，只需要超过半数的成功响应（确保日志记录已经存储在超过半数的节点上）——一个很慢的节点不会使系统变慢，因为 Leader 不必等他；  日志一致性 Raft 尝试在集群中保持日志较高的一致性。\nRaft 日志的 index 和 term 唯一标示一条日志记录。（这非常重要！！！）\n 如果两个节点的日志在相同的索引位置上的任期号相同，则认为他们具有一样的命令；从头到这个索引位置之间的日志完全相同； 如果给定的记录已提交，那么所有前面的记录也已提交。  AppendEntries 一致性检查 Raft 通过 AppendEntries RPC 来检测这两个属性。\n 对于每个 AppendEntries RPC 包含新日志记录之前那条记录的索引(prevLogIndex)和任期(prevLogTerm)； Follower 检查自己的 index 和 term 是否与 prevLogIndex 和 prevLogTerm 匹配，匹配则接收该记录；否则拒绝；  3. Leader 更替 当新的 Leader 上任后，日志可能不会非常干净，因为前一任领导可能在完成日志复制之前就宕机了。Raft 对此的处理方式是：无需采取任何特殊处理。\n当新 Leader 上任后，他不会立即进行任何清理操作，他将会在正常运行期间进行清理。\n原因是当一个新的 Leader 上任时，往往意味着有机器故障了，那些机器可能宕机或网络不通，所以没有办法立即清理他们的日志。在机器恢复运行之前，我们必须保证系统正常运行。\n**大前提是 Raft 假设了 Leader 的日志始终是对的。**所以 Leader 要做的是，随着时间推移，让所有 Follower 的日志最终都与其匹配。\n但与此同时，Leader 也可能在完成这项工作之前故障，日志会在一段时间内堆积起来，从而造成看起来相当混乱的情况，如下所示：\n因为我们已经知道 index 和 term 是日志记录的唯一标识符，这里不再显示日志包含的命令，下同。\n如图，这种情况可能出现在 S4 和 S5 是任期 2、3、4 的 Leader，但不知何故，他们没有复制自己的日志记录就崩溃了，系统分区了一段时间，S1、S2、S3 轮流成为了任期 5、6、7 的 Leader，但无法与 S4、S5 通信以进行日志清理——所以我们看到的日志非常混乱。\n唯一重要的是，索引 1-3 之间的记录是已提交的(已存在多数派节点)，因此我们必须确保留下它们。\n其它日志都是未提交的，我们还没有将这些命令传递给状态机，也没有客户端会收到这些执行的结果，所以不管是保留还是丢弃它们都无关紧要。\n安全性 一旦状态机执行了一条日志里的命令，必须确保其它状态机在同样索引的位置不会执行不同的命令。\nRaft 安全性(Safety)：如果某条日志记录在某个任期号已提交，那么这条记录必然出现在更大任期号的未来 Leader 的日志中。\n这保证了安全性要求：\n Leader 不会覆盖日志中的记录； 只有 Leader 的日志中的记录才能被提交； 在应用到状态机之前，日志必须先被提交；  这决定我们要修改选举程序：\n 如果节点的日志中没有正确的内容，需要避免其成为 Leader； 稍微修改 committed 的定义（即前面提到的要稍作修改）：前面说多数派存储即是已提交的，但在某些时候，我们必须延迟提交日志记录，直到我们知道这条记录是安全的，所谓安全的，就是我们认为后续 Leader 也会有这条日志。  延迟提交，选出最佳 Leader 问题来了：我们如何确保选出了一个很好地保存了所有已提交日志的 Leader ？\n这有点棘手，举个例子：假设我们要在下面的集群中选出一个新 Leader，但此时第三台服务器不可用。\n这种情况下，仅看前两个节点的日志我们无法确认是否达成多数派，故无法确认第五条日志是否已提交。\n那怎么办呢？\n通过比较日志，在选举期间，选择最有可能包含所有已提交的日志：\n Candidate 在 RequestVote RPCs 中包含日志信息（最后一条记录的 index 和 term，记为 lastIndex 和 lastTerm）； 收到此投票请求的服务器 V 将比较谁的日志更完整：(lastTermV  lastTermC) || (lastTermV == lastTermC) \u0026\u0026 (lastIndexV  lastIndexC) 将拒绝投票；（即：V 的任期比 C 的任期新，或任期相同但 V 的日志比 C 的日志更完整）； 无论谁赢得选举，可以确保 Leader 和超过半数投票给它的节点中拥有最完整的日志——最完整的意思就是 index 和 term 这对唯一标识是最大的。  举个例子 Case 1: Leader 决定提交日志 任期 2 的 Leader S1 的 index = 4 日志刚刚被复制到 S3，并且 Leader 可以看到 index = 4 已复制到超过半数的服务器，那么该日志可以提交，并且安全地应用到状态机。\n现在，这条记录是安全的，下一任期的 Leader 必须包含此记录，因此 S4 和 S5 都不可能从其它节点那里获得选票：S5 任期太旧，S4 日志太短。\n只有前三台中的一台可以成为新的 Leader——S1 当然可以，S2、S3 也可以通过获取 S4 和 S5 的选票成为 Leader。\nCase 2: Leader 试图提交之前任期的日志 如图所示的情况，在任期 2 时记录仅写在 S1 和 S2 两个节点上，由于某种原因，任期 3 的 Leader S5 并不知道这些记录，S5 创建了自己的三条记录然后宕机了，然后任期 4 的 Leader S1 被选出，S1 试图与其它服务器的日志进行匹配。因此它复制了任期 2 的日志到 S3。\n此时 index=3 的记录时是不安全的。\n因为 S1 可能在此时宕机，然后 S5 可能从 S2、S3、S4 获得选票成为任期 5 的 Leader。一旦 S5 成为新 Leader，它将覆盖 index=3-5 的日志，S1-S3 的这些记录都将消失。\n我们还要需要一条新的规则，来处理这种情况。\n新的 Commit 规则 新的选举不足以保证日志安全，我们还需要继续修改 commit 规则。\nLeader 要提交一条日志：\n 日志必须存储在超过半数的节点上； Leader 必须看到：超过半数的节点上还必须存储着至少一条自己任期内的日志；  如图，回到上面的 Case 2: 当 index = 3 \u0026 term = 2 被复制到 S3 时，它还不能提交该记录，必须等到 term = 4 的记录存储在超过半数的节点上，此时 index = 3 和 index = 4 可以认为是已提交。\n此时 S5 无法赢得选举了，它无法从 S1-S3 获得选票。\n结合新的选举规则和 commit 规则，我们可以保证 Raft 的安全性。\n日志不一致 Leader 变更可能导致日志的不一致，这里展示一种可能的情况。\n可以从图中看出，Raft 集群中通常有两种不一致的日志：\n 缺失的记录(Missing Entries)； 多出来的记录(Extraneous Entries)；  我们要做的就是清理这两种日志。\n修复 Follower 日志 新的 Leader 必须使 Follower 的日志与自己的日志保持一致，通过：\n 删除 Extraneous Entries； 补齐 Missing Entries；  Leader 为每个 Follower 保存 nextIndex：\n 下一个要发送给 Follower 的日志索引； 初始化为： 1 + Leader 最后一条日志的索引；  Leader 通过 nextIndex 来修复日志。当 AppendEntries RPC 一致性检查失败，递减 nextIndex 并重试。如下图所示：\n对于 a：\n 一开始 nextIndex = 11，带上日志 index = 10 \u0026 term = 6，检查失败； nextIndex = 10，带上日志 index = 9 \u0026 term = 6，检查失败； 如此反复，直到 nextIndex = 5，带上日志 index = 4 \u0026 term = 4，该日志现在匹配，会在 a 中补齐 Leader 的日志。如此往下补齐。  对于 b： 会一直检查到 nextIndex = 4 才匹配。值得注意的是，对于 b 这种情况，当 Follower 覆盖不一致的日志时，它将删除所有后续的日志记录（任何无关紧要的记录之后的记录也都是无关紧要的）。如下图所示：\n4. 处理旧 Leader 实际上，老的 Leader 可能不会马上消失，例如：网络分区将 Leader 与集群的其余部分分隔，其余部分选举出了一个新的 Leader。问题在于，如果老的 Leader 重新连接，也不知道新的 Leader 已经被选出来，它会尝试作为 Leader 继续提交日志。此时如果有客户端向老 Leader 发送请求，老的 Leader 会尝试存储该命令并向其它节点复制日志——我们必须阻止这种情况发生。\n任期就是用来发现过时的 Leader(和 Candidates)：\n 每个 RPC 都包含发送方的任期； 如果发送方的任期太老，无论哪个过程，RPC 都会被拒绝，发送方转变到 Follower 并更新其任期； 如果接收方的任期太老，接收方将转为 Follower，更新它的任期，然后正常的处理 RPC；  由于新 Leader 的选举会更新超过半数服务器的任期，旧的 Leader 不能提交新的日志，因为它会联系至少一台多数派集群的节点，然后发现自己任期太老，会转为 Follower 继续工作。\n这里不打算继续讨论别的极端情况。\n5. 客户端协议 客户端只将命令发送到 Leader：\n 如果客户端不知道 Leader 是谁，它会和任意一台服务器通信； 如果通信的节点不是 Leader，它会告诉客户端 Leader 是谁；  Leader 直到将命令记录、提交和执行到状态机之前，不会做出响应。\n这里的问题是如果 Leader 宕机会导致请求超时：\n 客户端重新发出命令到其他服务器上，最终重定向到新的 Leader 用新的 Leader 重试请求，直到命令被执行  这留下了一个命令可能被执行两次的风险——Leader 可能在执行命令之后但响应客户端之前宕机，此时客户端再去寻找下一个 Leader，同一个命令就会被执行两次——这是不可接受的！\n解决办法是：客户端发送给 Leader 的每个命令都带上一个唯一 id\n Leader 将唯一 id 写到日志记录中 在 Leader 接受命令之前，先检查其日志中是否已经具有该 id 如果 id 在日志中，说明是重复的请求，则忽略新的命令，返回旧命令的响应  每个命令只会被执行一次，这就是所谓的线性化的关键要素。\n6. 配置变更 随着时间推移，会有机器故障需要我们去替换它，或者修改节点数量，需要有一些机制来变更系统配置，并且是安全、自动的方式，无需停止系统。\n系统配置是指：\n 每台服务器的 id 和地址 系统配置信息是非常重要的，它决定了多数派的组成  首先要意识到，我们不能直接从旧配置切换到新配置，这可能会导致矛盾的多数派。\n如图，系统以三台服务器的配置运行着，此时我们要添加两台服务器。如果我们直接修改配置，他们可能无法完全在同一时间做到配置切换，这会导致 S1 和 S2 形成旧集群的多数派，而同一时间 S3-S5 已经切换到新配置，这会产生两个集群。\n这说明我们必须使用一个两阶段(two-phase)协议。\n 如果有人告诉你，他可以在分布式系统中一个阶段就做出决策，你应该非常认真地询问他，因为他要么错了，要么发现了世界上所有人都不知道的东西。\n 共同一致(Joint Consensus) Raft 通过共同一致(Joint Consensus)来完成两阶段协议，即：新、旧两种配置上都获得多数派选票。\n第一阶段：\n Leader 收到 $C_{new}$ 的配置变更请求后，先写入一条 $C_{old+new}$ 的日志，配置变更立即生效，然后将日志通过 AppendEntries RPC 复制到 Follower 中，收到该 $C_{old+new}$ 的节点立即应用该配置作为当前节点的配置； $C_{old+new}$ 日志复制到多数派节点上时，$C_{old+new}$ 的日志已提交；  $C_{old+new}$ 日志已提交保证了后续任何 Leader 一定有 $C_{old+new}$ 日志，Leader 选举过程必须获得旧配置中的多数派和新配置中的多数派同时投票。\n第二阶段：\n $C_{old+new}$ 日志已提交后，立即写入一条 $C_{new}$ 的日志，并将该日志通过 AppendEntries RPC 复制到 Follower 中，收到 $C_{new}$ 的节点立即应用该配置作为当前节点的配置； $C_{new}$ 日志复制到多数派节点上时，$C_{new}$ 的日志已提交；在 $C_{new}$ 日志提交以后，后续的配置都基于 $C_{new}$ 了；  Joint Consensus 还有一些细节：\n 变更过程中，来自新旧配置的节点都有可能成为 Leader； 如果当前 Leader 不在 $C_{new}$ 配置里面，一旦 $C_{new}$ 提交，它必须下台(step down)。  如图所示，旧 Leader 不再是新配置的成员之后，还有可能继续服务一小段时间；即旧 Leader 可能在 $C_{new}$ 配置下继续当 Leader（虽然实质上并不是Leader），直到 $C_{new}$ 的日志复制到多数派上而 committed；\n相关阅读 Raft 作者亲自出的 Raft 试题，你能做对几道？\nGolang 实现 Paxos 分布式共识算法\n漫谈分布式共识问题\n理解 Paxos（含伪代码）\n",
  "wordCount" : "798",
  "inLanguage": "en",
  "datePublished": "2021-02-01T00:00:00Z",
  "dateModified": "2021-02-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "多颗糖"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tangwz.com/post/raft/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "多颗糖",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tangwz.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tangwz.com/" accesskey="h" title="多颗糖 (Alt + H)">多颗糖</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tangwz.com/page/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tangwz.com/">Home</a>&nbsp;»&nbsp;<a href="https://tangwz.com/post/">Posts</a></div>
    <h1 class="post-title">
      条分缕析 Raft 算法
    </h1>
    <div class="post-meta"><span title='2021-02-01 00:00:00 +0000 UTC'>February 1, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;多颗糖&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/post/raft.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%9b%ae%e6%a0%87" aria-label="目标">目标</a></li>
                <li>
                    <a href="#%e7%b3%bb%e7%bb%9f%e6%a8%a1%e5%9e%8b" aria-label="系统模型">系统模型</a></li>
                <li>
                    <a href="#%e5%bc%80%e5%a7%8b%e4%b9%8b%e5%89%8d" aria-label="开始之前">开始之前</a><ul>
                        
                <li>
                    <a href="#%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%8a%b6%e6%80%81" aria-label="服务器状态">服务器状态</a></li>
                <li>
                    <a href="#%e4%bb%bb%e6%9c%9f" aria-label="任期">任期</a></li>
                <li>
                    <a href="#%e4%b8%a4%e4%b8%aa-rpc" aria-label="两个 RPC">两个 RPC</a></li></ul>
                </li>
                <li>
                    <a href="#1-leader-%e9%80%89%e4%b8%be" aria-label="1. Leader 选举">1. Leader 选举</a><ul>
                        
                <li>
                    <a href="#%e5%90%af%e5%8a%a8" aria-label="启动">启动</a></li>
                <li>
                    <a href="#%e9%80%89%e4%b8%be" aria-label="选举">选举</a></li>
                <li>
                    <a href="#%e9%80%89%e4%b8%be%e5%ae%89%e5%85%a8%e6%80%a7" aria-label="选举安全性">选举安全性</a></li></ul>
                </li>
                <li>
                    <a href="#2-%e6%97%a5%e5%bf%97%e5%a4%8d%e5%88%b6" aria-label="2. 日志复制">2. 日志复制</a><ul>
                        
                <li>
                    <a href="#%e6%97%a5%e5%bf%97%e7%bb%93%e6%9e%84" aria-label="日志结构">日志结构</a></li>
                <li>
                    <a href="#%e6%ad%a3%e5%b8%b8%e8%bf%90%e8%a1%8c" aria-label="正常运行">正常运行</a></li>
                <li>
                    <a href="#%e6%97%a5%e5%bf%97%e4%b8%80%e8%87%b4%e6%80%a7" aria-label="日志一致性">日志一致性</a></li>
                <li>
                    <a href="#appendentries-%e4%b8%80%e8%87%b4%e6%80%a7%e6%a3%80%e6%9f%a5" aria-label="AppendEntries 一致性检查"><code>AppendEntries</code> 一致性检查</a></li></ul>
                </li>
                <li>
                    <a href="#3-leader-%e6%9b%b4%e6%9b%bf" aria-label="3. Leader 更替">3. Leader 更替</a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e5%85%a8%e6%80%a7" aria-label="安全性">安全性</a></li>
                <li>
                    <a href="#%e5%bb%b6%e8%bf%9f%e6%8f%90%e4%ba%a4%e9%80%89%e5%87%ba%e6%9c%80%e4%bd%b3-leader" aria-label="延迟提交，选出最佳 Leader">延迟提交，选出最佳 Leader</a></li>
                <li>
                    <a href="#%e4%b8%be%e4%b8%aa%e4%be%8b%e5%ad%90" aria-label="举个例子">举个例子</a><ul>
                        
                <li>
                    <a href="#case-1-leader-%e5%86%b3%e5%ae%9a%e6%8f%90%e4%ba%a4%e6%97%a5%e5%bf%97" aria-label="Case 1: Leader 决定提交日志">Case 1: Leader 决定提交日志</a></li>
                <li>
                    <a href="#case-2-leader-%e8%af%95%e5%9b%be%e6%8f%90%e4%ba%a4%e4%b9%8b%e5%89%8d%e4%bb%bb%e6%9c%9f%e7%9a%84%e6%97%a5%e5%bf%97" aria-label="Case 2: Leader 试图提交之前任期的日志">Case 2: Leader 试图提交之前任期的日志</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%96%b0%e7%9a%84-commit-%e8%a7%84%e5%88%99" aria-label="新的 Commit 规则">新的 Commit 规则</a></li>
                <li>
                    <a href="#%e6%97%a5%e5%bf%97%e4%b8%8d%e4%b8%80%e8%87%b4" aria-label="日志不一致">日志不一致</a></li>
                <li>
                    <a href="#%e4%bf%ae%e5%a4%8d-follower-%e6%97%a5%e5%bf%97" aria-label="修复 Follower 日志">修复 Follower 日志</a></li></ul>
                </li>
                <li>
                    <a href="#4-%e5%a4%84%e7%90%86%e6%97%a7-leader" aria-label="4. 处理旧 Leader">4. 处理旧 Leader</a></li>
                <li>
                    <a href="#5-%e5%ae%a2%e6%88%b7%e7%ab%af%e5%8d%8f%e8%ae%ae" aria-label="5. 客户端协议">5. 客户端协议</a></li>
                <li>
                    <a href="#6-%e9%85%8d%e7%bd%ae%e5%8f%98%e6%9b%b4" aria-label="6. 配置变更">6. 配置变更</a><ul>
                        
                <li>
                    <a href="#%e5%85%b1%e5%90%8c%e4%b8%80%e8%87%b4joint-consensus" aria-label="共同一致(Joint Consensus)">共同一致(Joint Consensus)</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%9b%b8%e5%85%b3%e9%98%85%e8%af%bb" aria-label="相关阅读">相关阅读</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><em>本文整理自 Ongaro 在 Youtube 上的视频。</em></p>
<h1 id="目标">目标<a hidden class="anchor" aria-hidden="true" href="#目标">#</a></h1>
<p>Raft 的目标（或者说是分布式共识算法的目标）是：<strong>保证 log 完全相同地复制到多台服务器上</strong>。</p>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/LsBmFw8ZUIJuNXP.jpg" alt="-w1001"  />
</p>
<p>只要每台服务器的日志相同，那么，在不同服务器上的状态机以相同顺序从日志中执行相同的命令，将会产生相同的结果。</p>
<p>共识算法的工作就是管理这些日志。</p>
<h1 id="系统模型">系统模型<a hidden class="anchor" aria-hidden="true" href="#系统模型">#</a></h1>
<p>我们假设：</p>
<ul>
<li>服务器可能会宕机、会停止运行过段时间再恢复，但是<strong>非拜占庭的</strong>（即它的行为是非恶意的，不会篡改数据等）；</li>
<li>网络通信会中断，消息可能会丢失、延迟或乱序；可能会网络分区；</li>
</ul>
<p>Raft 是基于 Leader 的共识算法，故主要考虑：</p>
<ul>
<li>Leader 正常运行</li>
<li>Leader 故障，必须选出新的 Leader</li>
</ul>
<p>优点：只有一个 Leader，简单。</p>
<p>难点：<strong>Leader 发生改变时，可能会使系统处于不一致的状态，因此，下一任 Leader 必须进行清理；</strong></p>
<p>我们将从 6 个部分解释 Raft：</p>
<ol>
<li>Leader 选举；</li>
<li>正常运行：日志复制（最简单的部分）；</li>
<li>Leader 变更时的安全性和一致性（最棘手、最关键的部分）；</li>
<li>处理旧 Leader：旧的 Leader 并没有真的下线怎么办？</li>
<li>客户端交互：实现线性化语义(linearizable semantics)；</li>
<li>配置变更：如何在集群中增加或删除节点；</li>
</ol>
<h1 id="开始之前">开始之前<a hidden class="anchor" aria-hidden="true" href="#开始之前">#</a></h1>
<p>开始之前需要了解 Raft 的一些术语。</p>
<h2 id="服务器状态">服务器状态<a hidden class="anchor" aria-hidden="true" href="#服务器状态">#</a></h2>
<p>服务器在任意时间只能处于以下三种状态之一：</p>
<ul>
<li>Leader：处理所有客户端请求、日志复制。同一时刻最多只能有一个可行的 Leader；</li>
<li>Follower：完全被动的（不发送 RPC，只响应收到的 RPC）——大多数服务器在大多数情况下处于此状态；</li>
<li>Candidate：用来选举新的 Leader，处于 Leader 和 Follower 之间的暂时状态；</li>
</ul>
<p><strong>系统正常运行时，只有一个 Leader，其余都是 Followers.</strong></p>
<p>状态转换图：</p>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/JRt5QCUgKOHfj1A.jpg" alt="-w935"  />
</p>
<h2 id="任期">任期<a hidden class="anchor" aria-hidden="true" href="#任期">#</a></h2>
<p>时间被划分成一个个的<strong>任期(Term)</strong>，每个任期都由一个数字来表示任期号，任期号单调递增并且永远不会重复。</p>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/8qQX6wrioezWEav.jpg" alt="-w735"  />
</p>
<p>一个正常的任期至少有一个 Leader，通常分为两部分：</p>
<ul>
<li>任期开始时的选举过程；</li>
<li>正常运行的部分；</li>
</ul>
<p>有些任期可能没有选出 Leader（如图 Term 3），这时候会立即进入下一个任期，再次尝试选出一个 Leader。</p>
<p>每个节点维护一个 <code>currentTerm</code> 变量，表示系统中当前任期。<code>currentTerm</code> <strong>必须持久化存储</strong>，以便在服务器宕机重启时将其恢复。</p>
<p>**任期非常重要！任期能够帮助 Raft 识别过期的信息。**例如：如果 <code>currentTerm = 2</code> 的节点与 <code>currentTerm = 3</code> 的节点通信，我们可以知道第一个节点上的信息是过时的。</p>
<p>我们只使用最新任期的信息。后面我们会遇到各种情况，去检测和消除不是最新任期的信息。</p>
<h2 id="两个-rpc">两个 RPC<a hidden class="anchor" aria-hidden="true" href="#两个-rpc">#</a></h2>
<p>Raft 中服务器之间所有类型的通信通过两个 RPC 调用：</p>
<ul>
<li><code>RequestVote</code>：用于选举；</li>
<li><code>AppendEntries</code>：用于复制 log 和发送心跳；</li>
</ul>
<h1 id="1-leader-选举">1. Leader 选举<a hidden class="anchor" aria-hidden="true" href="#1-leader-选举">#</a></h1>
<h2 id="启动">启动<a hidden class="anchor" aria-hidden="true" href="#启动">#</a></h2>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/J4FBX29fgucDV7l.jpg" alt="-w870"  />
</p>
<ul>
<li>节点启动时，都是 Follower 状态；</li>
<li>Follower 被动地接受 Leader 或 Candidate 的 RPC；</li>
<li>所以，如果 Leader 想要保持权威，必须向集群中的其它节点发送心跳包（空的 <code>AppendEntries RPC</code>）；</li>
<li>等待选举超时(<code>electionTimeout</code>，一般在 100~500ms)后，Follower 没有收到任何 RPC：
<ul>
<li>Follower 认为集群中没有 Leader</li>
<li>开始新的一轮选举</li>
</ul>
</li>
</ul>
<h2 id="选举">选举<a hidden class="anchor" aria-hidden="true" href="#选举">#</a></h2>
<p>当一个节点开始竞选：</p>
<ul>
<li>增加自己的 <code>currentTerm</code></li>
<li>转为 Candidate 状态，<strong>其目标是获取超过半数节点的选票，让自己成为 Leader</strong></li>
<li><strong>先给自己投一票</strong></li>
<li>并行地向集群中其它节点发送 <code>RequestVote RPC</code> 索要选票，如果没有收到指定节点的响应，它会反复尝试，直到发生以下三种情况之一：</li>
</ul>
<ol>
<li>获得超过半数的选票：成为 Leader，并向其它节点发送 <code>AppendEntries</code> 心跳；</li>
<li>收到来自 Leader 的 RPC：转为 Follower；</li>
<li>其它两种情况都没发生，没人能够获胜(<code>electionTimeout</code> 已过)：增加 <code>currentTerm</code>，开始新一轮选举；</li>
</ol>
<p>流程图如下：
<img loading="lazy" src="https://i.loli.net/2021/02/03/4WmUxfkB56CRAp3.jpg" alt="-w542"  />
</p>
<h2 id="选举安全性">选举安全性<a hidden class="anchor" aria-hidden="true" href="#选举安全性">#</a></h2>
<p>选举过程需要保证两个特性：<strong>安全性(safety)<strong>和</strong>活性(liveness)</strong>。</p>
<p>安全性(safety)：一个任期内只会有一个 Leader 被选举出来。需要保证：</p>
<ul>
<li>每个节点在同一任期内只能投一次票，它将投给第一个满足条件的投票请求，然后拒绝其它 Candidate 的请求。这需要持久化存储投票信息 <code>votedFor</code>，以便宕机重启后恢复，否则重启后 <code>votedFor</code> 丢失会导致投给别的节点；</li>
<li>只有获得超过半数节点的选票才能成为 Leader，也就是说，两个不同的 Candidate 无法在同一任期内都获得超过半数的票；</li>
</ul>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/CmEIAMG1HV4XiLB.jpg" alt="-w794"  />
</p>
<p>活性(liveness)：确保最终能选出一个 Leader。</p>
<p>问题是：原则上我们可以无限重复分割选票，假如选举同一时间开始，同一时间超时，同一时间再次选举，如此循环。</p>
<p>解决办法很简单：</p>
<ul>
<li>节点随机选择超时时间，通常在 [T, 2T] 之间（T = <code>electionTimeout</code>）</li>
<li>这样，节点不太可能再同时开始竞选，先竞选的节点有足够的时间来索要其他节点的选票</li>
<li>T &raquo; broadcast time(T 远大于广播时间)时效果更佳</li>
</ul>
<h1 id="2-日志复制">2. 日志复制<a hidden class="anchor" aria-hidden="true" href="#2-日志复制">#</a></h1>
<h2 id="日志结构">日志结构<a hidden class="anchor" aria-hidden="true" href="#日志结构">#</a></h2>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/1CcUMnIhJeBkbYj.jpg" alt="-w1019"  />
</p>
<p>每个节点存储自己的日志副本(<code>log[]</code>)，每条日志记录包含：</p>
<ul>
<li>索引：该记录在日志中的位置</li>
<li>任期号：该记录首次被创建时的任期号</li>
<li>命令</li>
</ul>
<p>**日志必须持久化存储。**一个节点必须先将记录安全写到磁盘，才能向系统中其他节点返回响应。</p>
<p>如果一条日志记录被存储在超过半数的节点上，我们认为该记录<strong>已提交</strong>(<code>committed</code>)——这是 Raft 非常重要的特性！如果一条记录已提交，意味着状态机可以安全地执行该记录。</p>
<p>在上图中，第 1-7 条记录被提交，第 8 条尚未提交。</p>
<blockquote>
<p>提醒：多数派复制了日志即已提交，这个定义并不精确，我们会在后面稍作修改。</p>
</blockquote>
<h2 id="正常运行">正常运行<a hidden class="anchor" aria-hidden="true" href="#正常运行">#</a></h2>
<ul>
<li>客户端向 Leader 发送命令，希望该命令被所有状态机执行；</li>
<li>Leader 先将该命令追加到自己的日志中；</li>
<li>Leader 并行地向其它节点发送 <code>AppendEntries RPC</code>，等待响应；</li>
<li>收到超过半数节点的响应，则认为新的日志记录是被提交的：
<ul>
<li>Leader 将命令传给自己的状态机，然后向客户端返回响应</li>
<li>此外，一旦 Leader 知道一条记录被提交了，将在后续的 <code>AppendEntries RPC</code> 中通知已经提交记录的 Followers</li>
<li>Follower 将已提交的命令传给自己的状态机</li>
</ul>
</li>
<li>如果 Follower 宕机/超时：Leader 将反复尝试发送 RPC；</li>
<li>性能优化：Leader 不必等待每个 Follower 做出响应，只需要超过半数的成功响应（确保日志记录已经存储在超过半数的节点上）——一个很慢的节点不会使系统变慢，因为 Leader 不必等他；</li>
</ul>
<h2 id="日志一致性">日志一致性<a hidden class="anchor" aria-hidden="true" href="#日志一致性">#</a></h2>
<p>Raft 尝试在集群中保持日志较高的一致性。</p>
<p><strong>Raft 日志的 index 和 term 唯一标示一条日志记录。</strong>（这非常重要！！！）</p>
<ol>
<li>如果两个节点的日志在相同的索引位置上的任期号相同，则认为他们具有一样的命令；<strong>从头到这个索引位置之间的日志完全相同</strong>；</li>
<li><strong>如果给定的记录已提交，那么所有前面的记录也已提交</strong>。</li>
</ol>
<h2 id="appendentries-一致性检查"><code>AppendEntries</code> 一致性检查<a hidden class="anchor" aria-hidden="true" href="#appendentries-一致性检查">#</a></h2>
<p>Raft 通过 <code>AppendEntries RPC</code> 来检测这两个属性。</p>
<ul>
<li>对于每个 <code>AppendEntries RPC</code> 包含新日志记录<strong>之前那条记录的</strong>索引(<code>prevLogIndex</code>)和任期(<code>prevLogTerm</code>)；</li>
<li>Follower 检查自己的 index 和 term 是否与 <code>prevLogIndex</code> 和 <code>prevLogTerm</code> 匹配，匹配则接收该记录；否则拒绝；</li>
</ul>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/BkCdlbF34aQJhz9.jpg" alt="-w1018"  />
</p>
<h1 id="3-leader-更替">3. Leader 更替<a hidden class="anchor" aria-hidden="true" href="#3-leader-更替">#</a></h1>
<p>当新的 Leader 上任后，日志可能不会非常干净，因为前一任领导可能在完成日志复制之前就宕机了。<strong>Raft 对此的处理方式是：无需采取任何特殊处理。</strong></p>
<p>当新 Leader 上任后，他不会立即进行任何清理操作，他将会在正常运行期间进行清理。</p>
<p>原因是当一个新的 Leader 上任时，往往意味着有机器故障了，那些机器可能宕机或网络不通，所以没有办法立即清理他们的日志。在机器恢复运行之前，我们必须保证系统正常运行。</p>
<p>**大前提是 Raft 假设了 Leader 的日志始终是对的。**所以 Leader 要做的是，随着时间推移，让所有 Follower 的日志最终都与其匹配。</p>
<p>但与此同时，Leader 也可能在完成这项工作之前故障，日志会在一段时间内堆积起来，从而造成看起来相当混乱的情况，如下所示：</p>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/6LSfxX48Pzs92Yq.jpg" alt="-w534"  />
</p>
<p>因为我们已经知道 index 和 term 是日志记录的唯一标识符，这里不再显示日志包含的命令，下同。</p>
<p>如图，这种情况可能出现在 S4 和 S5 是任期 2、3、4 的 Leader，但不知何故，他们没有复制自己的日志记录就崩溃了，系统分区了一段时间，S1、S2、S3 轮流成为了任期 5、6、7 的 Leader，但无法与 S4、S5 通信以进行日志清理——所以我们看到的日志非常混乱。</p>
<p><strong>唯一重要的是，索引 1-3 之间的记录是已提交的(已存在多数派节点)，因此我们必须确保留下它们</strong>。</p>
<p>其它日志都是未提交的，我们还没有将这些命令传递给状态机，也没有客户端会收到这些执行的结果，所以不管是保留还是丢弃它们都无关紧要。</p>
<h2 id="安全性">安全性<a hidden class="anchor" aria-hidden="true" href="#安全性">#</a></h2>
<p><strong>一旦状态机执行了一条日志里的命令，必须确保其它状态机在同样索引的位置不会执行不同的命令。</strong></p>
<p>Raft 安全性(Safety)：如果某条日志记录在某个任期号已提交，那么这条记录必然出现在更大任期号的未来 Leader 的日志中。</p>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/7RGYXVTCreaIt5U.jpg" alt="-w837"  />
</p>
<p>这保证了安全性要求：</p>
<ul>
<li>Leader 不会覆盖日志中的记录；</li>
<li>只有 Leader 的日志中的记录才能被提交；</li>
<li>在应用到状态机之前，日志必须先被提交；</li>
</ul>
<p>这决定我们要修改选举程序：</p>
<ul>
<li>如果节点的日志中没有正确的内容，需要避免其成为 Leader；</li>
<li>稍微修改 committed 的定义（<em>即前面提到的要稍作修改</em>）：前面说多数派存储即是已提交的，但在某些时候，我们必须延迟提交日志记录，直到我们知道这条记录是安全的，<strong>所谓安全的，就是我们认为后续 Leader 也会有这条日志</strong>。</li>
</ul>
<h2 id="延迟提交选出最佳-leader">延迟提交，选出最佳 Leader<a hidden class="anchor" aria-hidden="true" href="#延迟提交选出最佳-leader">#</a></h2>
<p>问题来了：我们如何确保选出了一个很好地保存了所有已提交日志的 Leader ？</p>
<p>这有点棘手，举个例子：假设我们要在下面的集群中选出一个新 Leader，但此时第三台服务器不可用。</p>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/FEtKwMzfrZXUOdv.jpg" alt="-w601"  />
</p>
<p>这种情况下，仅看前两个节点的日志我们无法确认是否达成多数派，故无法确认第五条日志是否已提交。</p>
<p>那怎么办呢？</p>
<p>通过比较日志，在选举期间，选择最有可能包含所有已提交的日志：</p>
<ul>
<li>Candidate 在 <code>RequestVote RPCs</code> 中包含日志信息（最后一条记录的 index 和 term，记为 <code>lastIndex</code> 和 <code>lastTerm</code>）；</li>
<li>收到此投票请求的服务器 V 将比较谁的日志更完整：<code>(lastTermV &gt; lastTermC) || (lastTermV == lastTermC) &amp;&amp; (lastIndexV &gt; lastIndexC)</code> 将拒绝投票；（即：V 的任期比 C 的任期新，或任期相同但 V 的日志比 C 的日志更完整）；</li>
<li>无论谁赢得选举，可以确保 Leader 和超过半数投票给它的节点中拥有最完整的日志——<strong>最完整的意思就是 index 和 term 这对唯一标识是最大的</strong>。</li>
</ul>
<h2 id="举个例子">举个例子<a hidden class="anchor" aria-hidden="true" href="#举个例子">#</a></h2>
<h3 id="case-1-leader-决定提交日志">Case 1: Leader 决定提交日志<a hidden class="anchor" aria-hidden="true" href="#case-1-leader-决定提交日志">#</a></h3>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/EFgfXRzo3NbLHB6.jpg" alt="-w589"  />
</p>
<p>任期 2 的 Leader S1 的 index = 4 日志刚刚被复制到 S3，并且 Leader 可以看到 index = 4 已复制到超过半数的服务器，那么该日志可以提交，并且安全地应用到状态机。</p>
<p>现在，这条记录是安全的，下一任期的 Leader 必须包含此记录，因此 S4 和 S5 都不可能从其它节点那里获得选票：S5 任期太旧，S4 日志太短。</p>
<p>只有前三台中的一台可以成为新的 Leader——S1 当然可以，S2、S3 也可以通过获取 S4 和 S5 的选票成为 Leader。</p>
<h3 id="case-2-leader-试图提交之前任期的日志">Case 2: Leader 试图提交之前任期的日志<a hidden class="anchor" aria-hidden="true" href="#case-2-leader-试图提交之前任期的日志">#</a></h3>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/WfnMTVqRNwH4g3A.jpg" alt="-w588"  />
</p>
<p>如图所示的情况，在任期 2 时记录仅写在 S1 和 S2 两个节点上，由于某种原因，任期 3 的 Leader S5 并不知道这些记录，S5 创建了自己的三条记录然后宕机了，然后任期 4 的 Leader S1 被选出，S1 试图与其它服务器的日志进行匹配。因此它复制了任期 2 的日志到 S3。</p>
<p><strong>此时 index=3 的记录时是不安全的</strong>。</p>
<p>因为 S1 可能在此时宕机，然后 S5 可能从 S2、S3、S4 获得选票成为任期 5 的 Leader。一旦 S5 成为新 Leader，它将覆盖 index=3-5 的日志，S1-S3 的这些记录都将消失。</p>
<p>我们还要需要一条新的规则，来处理这种情况。</p>
<h2 id="新的-commit-规则">新的 Commit 规则<a hidden class="anchor" aria-hidden="true" href="#新的-commit-规则">#</a></h2>
<p>新的选举不足以保证日志安全，我们还需要继续修改 commit 规则。</p>
<p>Leader 要提交一条日志：</p>
<ul>
<li>日志必须存储在超过半数的节点上；</li>
<li><strong>Leader 必须看到：超过半数的节点上还必须存储着至少一条自己任期内的日志</strong>；</li>
</ul>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/fBWkG9E2YLQp5FN.jpg" alt="-w483"  />
</p>
<p>如图，回到上面的 Case 2: 当 index = 3 &amp; term = 2 被复制到 S3 时，它还不能提交该记录，必须等到 term = 4 的记录存储在超过半数的节点上，此时 index = 3 和 index = 4 可以认为是已提交。</p>
<p>此时 S5 无法赢得选举了，它无法从 S1-S3 获得选票。</p>
<p><strong>结合新的选举规则和 commit 规则，我们可以保证 Raft 的安全性。</strong></p>
<h2 id="日志不一致">日志不一致<a hidden class="anchor" aria-hidden="true" href="#日志不一致">#</a></h2>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/g6HrkQfEzC7eNqd.jpg" alt="-w1024"  />
</p>
<p>Leader 变更可能导致日志的不一致，这里展示一种可能的情况。</p>
<p>可以从图中看出，Raft 集群中通常有两种不一致的日志：</p>
<ul>
<li>缺失的记录(Missing Entries)；</li>
<li>多出来的记录(Extraneous Entries)；</li>
</ul>
<p>我们要做的就是清理这两种日志。</p>
<h2 id="修复-follower-日志">修复 Follower 日志<a hidden class="anchor" aria-hidden="true" href="#修复-follower-日志">#</a></h2>
<p>新的 Leader 必须使 Follower 的日志与自己的日志保持一致，通过：</p>
<ul>
<li>删除 Extraneous Entries；</li>
<li>补齐 Missing Entries；</li>
</ul>
<p>Leader 为每个 Follower 保存 <code>nextIndex</code>：</p>
<ul>
<li>下一个要发送给 Follower 的日志索引；</li>
<li>初始化为： 1 + Leader 最后一条日志的索引；</li>
</ul>
<p>Leader 通过 <code>nextIndex</code> 来修复日志。当 <code>AppendEntries RPC</code> 一致性检查失败，递减 <code>nextIndex</code> 并重试。如下图所示：</p>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/3unHSXWaOFBsUJP.jpg" alt="-w785"  />
</p>
<p>对于 a：</p>
<ul>
<li>一开始 <code>nextIndex</code> = 11，带上日志 index = 10 &amp; term = 6，检查失败；</li>
<li><code>nextIndex</code> = 10，带上日志 index = 9 &amp; term = 6，检查失败；</li>
<li>如此反复，直到 <code>nextIndex</code> = 5，带上日志 index = 4 &amp; term = 4，该日志现在匹配，会在 a 中补齐 Leader 的日志。如此往下补齐。</li>
</ul>
<p>对于 b：
会一直检查到 <code>nextIndex</code> = 4 才匹配。值得注意的是，对于 b 这种情况，当 Follower 覆盖不一致的日志时，它将删除所有后续的日志记录（任何无关紧要的记录之后的记录也都是无关紧要的）。如下图所示：</p>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/k4IqB7JaUOndzxA.jpg" alt="-w753"  />
</p>
<h1 id="4-处理旧-leader">4. 处理旧 Leader<a hidden class="anchor" aria-hidden="true" href="#4-处理旧-leader">#</a></h1>
<p>实际上，老的 Leader 可能不会马上消失，例如：网络分区将 Leader 与集群的其余部分分隔，其余部分选举出了一个新的 Leader。问题在于，如果老的 Leader 重新连接，也不知道新的 Leader 已经被选出来，它会尝试作为 Leader 继续提交日志。此时如果有客户端向老 Leader 发送请求，老的 Leader 会尝试存储该命令并向其它节点复制日志——我们必须阻止这种情况发生。</p>
<p><strong>任期就是用来发现过时的 Leader</strong>(和 Candidates)：</p>
<ul>
<li>每个 RPC 都包含发送方的任期；</li>
<li>如果发送方的任期太老，无论哪个过程，RPC 都会被拒绝，发送方转变到 Follower 并更新其任期；</li>
<li>如果接收方的任期太老，接收方将转为 Follower，更新它的任期，然后正常的处理 RPC；</li>
</ul>
<p>由于新 Leader 的选举会更新超过半数服务器的任期，旧的 Leader 不能提交新的日志，因为它会联系至少一台多数派集群的节点，然后发现自己任期太老，会转为 Follower 继续工作。</p>
<p>这里不打算继续讨论别的极端情况。</p>
<h1 id="5-客户端协议">5. 客户端协议<a hidden class="anchor" aria-hidden="true" href="#5-客户端协议">#</a></h1>
<p>客户端只将命令发送到 Leader：</p>
<ul>
<li>如果客户端不知道 Leader 是谁，它会和任意一台服务器通信；</li>
<li>如果通信的节点不是 Leader，它会告诉客户端 Leader 是谁；</li>
</ul>
<p>Leader 直到将命令记录、提交和执行到状态机之前，不会做出响应。</p>
<p>这里的问题是如果 Leader 宕机会导致请求超时：</p>
<ul>
<li>客户端重新发出命令到其他服务器上，最终重定向到新的 Leader</li>
<li>用新的 Leader 重试请求，直到命令被执行</li>
</ul>
<p>这留下了一个命令可能被执行两次的风险——Leader 可能在执行命令之后但响应客户端之前宕机，此时客户端再去寻找下一个 Leader，同一个命令就会被执行两次——这是不可接受的！</p>
<p>解决办法是：客户端发送给 Leader 的每个命令都带上一个唯一 id</p>
<ul>
<li>Leader 将唯一 id 写到日志记录中</li>
<li>在 Leader 接受命令之前，先检查其日志中是否已经具有该 id</li>
<li>如果 id 在日志中，说明是重复的请求，则忽略新的命令，返回旧命令的响应</li>
</ul>
<p><strong>每个命令只会被执行一次，这就是所谓的线性化的关键要素</strong>。</p>
<h1 id="6-配置变更">6. 配置变更<a hidden class="anchor" aria-hidden="true" href="#6-配置变更">#</a></h1>
<p>随着时间推移，会有机器故障需要我们去替换它，或者修改节点数量，需要有一些机制来变更系统配置，并且是安全、自动的方式，无需停止系统。</p>
<p>系统配置是指：</p>
<ul>
<li>每台服务器的 id 和地址</li>
<li><strong>系统配置信息是非常重要的，它决定了多数派的组成</strong></li>
</ul>
<p>首先要意识到，我们不能直接从旧配置切换到新配置，这可能会导致矛盾的多数派。</p>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/JseC43wyEI6jzDA.jpg" alt="-w977"  />
</p>
<p>如图，系统以三台服务器的配置运行着，此时我们要添加两台服务器。如果我们直接修改配置，他们可能无法完全在同一时间做到配置切换，这会导致 S1 和 S2 形成旧集群的多数派，而同一时间 S3-S5 已经切换到新配置，这会产生两个集群。</p>
<p>这说明我们必须使用一个两阶段(two-phase)协议。</p>
<blockquote>
<p>如果有人告诉你，他可以在分布式系统中一个阶段就做出决策，你应该非常认真地询问他，因为他要么错了，要么发现了世界上所有人都不知道的东西。</p>
</blockquote>
<h2 id="共同一致joint-consensus">共同一致(Joint Consensus)<a hidden class="anchor" aria-hidden="true" href="#共同一致joint-consensus">#</a></h2>
<p>Raft 通过共同一致(Joint Consensus)来完成两阶段协议，即：新、旧两种配置上都获得多数派选票。</p>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/uiwta7xnJymeDHT.jpg" alt="-w842"  />
</p>
<p>第一阶段：</p>
<ul>
<li>Leader 收到 $C_{new}$ 的配置变更请求后，先写入一条 $C_{old+new}$ 的日志，配置变更立即生效，然后将日志通过 <code>AppendEntries RPC</code> 复制到 Follower 中，收到该  $C_{old+new}$ 的节点立即应用该配置作为当前节点的配置；</li>
<li>$C_{old+new}$ 日志复制到多数派节点上时，$C_{old+new}$ 的日志已提交；</li>
</ul>
<p>$C_{old+new}$ 日志已提交保证了后续任何 Leader 一定有 $C_{old+new}$ 日志，Leader 选举过程必须获得旧配置中的多数派和新配置中的多数派同时投票。</p>
<p>第二阶段：</p>
<ul>
<li>$C_{old+new}$ 日志已提交后，立即写入一条 $C_{new}$ 的日志，并将该日志通过 <code>AppendEntries RPC</code> 复制到 Follower 中，收到 $C_{new}$ 的节点立即应用该配置作为当前节点的配置；</li>
<li>$C_{new}$ 日志复制到多数派节点上时，$C_{new}$ 的日志已提交；在 $C_{new}$ 日志提交以后，后续的配置都基于 $C_{new}$ 了；</li>
</ul>
<p><img loading="lazy" src="https://i.loli.net/2021/02/03/6cXKlrEdxshvB3F.jpg" alt="-w907"  />
</p>
<p>Joint Consensus 还有一些细节：</p>
<ul>
<li>变更过程中，来自新旧配置的节点都有可能成为 Leader；</li>
<li>如果当前 Leader 不在 $C_{new}$ 配置里面，一旦 $C_{new}$ 提交，它必须下台(step down)。</li>
</ul>
<p>如图所示，旧 Leader 不再是新配置的成员之后，还有可能继续服务一小段时间；即旧 Leader 可能在 $C_{new}$ 配置下继续当 Leader（虽然实质上并不是Leader），直到 $C_{new}$ 的日志复制到多数派上而 committed；</p>
<h1 id="相关阅读">相关阅读<a hidden class="anchor" aria-hidden="true" href="#相关阅读">#</a></h1>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;mid=2247483932&amp;idx=1&amp;sn=895af82bf5939d9be5e862f73f74acbd&amp;chksm=970981d9a07e08cf4c4121543aa6e2420a6a7c7c40f116bf89b534b6f2a54a46b2402522e2a5&amp;scene=21#wechat_redirect">Raft 作者亲自出的 Raft 试题，你能做对几道？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;mid=2247484009&amp;idx=1&amp;sn=ec4f6ad749895230121622ed63de0051&amp;chksm=970981aca07e08ba9e9c3e356694bbc0f0e83e2296d90d1307f0edb5137dd9079c9cba7b63dd&amp;scene=21#wechat_redirect">Golang 实现 Paxos 分布式共识算法</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;mid=2247483855&amp;idx=1&amp;sn=55a9c2c1eb28310e678c35df91d33818&amp;chksm=9709820aa07e0b1c2c82f94bbbd530d6a60fdd78b3a3171b93aff3e755b8f501dc7f243e78ac&amp;scene=21#wechat_redirect">漫谈分布式共识问题</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;mid=2247483889&amp;idx=1&amp;sn=45f929ef634ee55cbec235dee9c347a5&amp;chksm=97098234a07e0b226c9aa2d3a8c4e2eded8795be0b6c68f299ac8ba1546a626052e33efa295f&amp;scene=21#wechat_redirect">理解 Paxos（含伪代码）</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tangwz.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://tangwz.com/post/raft-extension/">
    <span class="title">« Prev Page</span>
    <br>
    <span>条分缕析 Raft 算法(续)：日志压缩和性能优化</span>
  </a>
  <a class="next" href="https://tangwz.com/post/fosa5/">
    <span class="title">Next Page »</span>
    <br>
    <span>软件架构基础 5 架构特性识别与实战: 订餐系统</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 条分缕析 Raft 算法 on twitter"
        href="https://twitter.com/intent/tweet/?text=%e6%9d%a1%e5%88%86%e7%bc%95%e6%9e%90%20Raft%20%e7%ae%97%e6%b3%95&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fraft%2f&amp;hashtags=%e5%88%86%e5%b8%83%e5%bc%8f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 条分缕析 Raft 算法 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fraft%2f&amp;title=%e6%9d%a1%e5%88%86%e7%bc%95%e6%9e%90%20Raft%20%e7%ae%97%e6%b3%95&amp;summary=%e6%9d%a1%e5%88%86%e7%bc%95%e6%9e%90%20Raft%20%e7%ae%97%e6%b3%95&amp;source=https%3a%2f%2ftangwz.com%2fpost%2fraft%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 条分缕析 Raft 算法 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ftangwz.com%2fpost%2fraft%2f&title=%e6%9d%a1%e5%88%86%e7%bc%95%e6%9e%90%20Raft%20%e7%ae%97%e6%b3%95">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 条分缕析 Raft 算法 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftangwz.com%2fpost%2fraft%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 条分缕析 Raft 算法 on whatsapp"
        href="https://api.whatsapp.com/send?text=%e6%9d%a1%e5%88%86%e7%bc%95%e6%9e%90%20Raft%20%e7%ae%97%e6%b3%95%20-%20https%3a%2f%2ftangwz.com%2fpost%2fraft%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 条分缕析 Raft 算法 on telegram"
        href="https://telegram.me/share/url?text=%e6%9d%a1%e5%88%86%e7%bc%95%e6%9e%90%20Raft%20%e7%ae%97%e6%b3%95&amp;url=https%3a%2f%2ftangwz.com%2fpost%2fraft%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://tangwz.com/">多颗糖</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
