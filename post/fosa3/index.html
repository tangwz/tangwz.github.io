<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title> 软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？ | 多颗糖</title>
<meta name="keywords" content="架构" />
<meta name="description" content="0. 写在前面 什么是好的代码？好的代码应该模块化。
王垠在其《编程的智慧》中也提到，要“写模块化的代码”。(不对人做评价，这篇文章写得是非常好的。)
如果你读过《代码大全》和《代码整洁之道》等书，一定对**“高内聚、低耦合”**不陌生。
好的模块化代码就是要高内聚、低耦合。
事实上，内聚和耦合是 1972 年就提出的概念，由于耦合不好具体的衡量，Meilir Page-Jones 在 1992 年提出了共生性（Connascence）。本章重点就是介绍如何评估模块化架构，以及引入共生性这一概念来帮助更好的模块化。
1. 模块化 不同的平台、语言为代码提供了不同的复用机制，将相关代码组合成模块。
理解模块对于架构师来说非常重要，因为用来分析架构的工具（可视化等）常常都依赖于模块化的概念。如果一个架构师在设计一个系统时，没有注意到各个部分是如何连接在一起的，那么他们最终创建的系统会带来无数的问题。
架构师必须保持良好的结构，这不会偶然发生。
模块的代码到底是什么？我们用模块化来描述相关代码中的逻辑分组，这些模块可以用来构造一个更复杂的结构。
现代的语言有各种各样的封装机制，例如，许多语言可以在函数/方法、类、包/命名空间中定义行为，每个包都有不同的可见性和范围规则。（这有时候也会让开发人员选择困难）
架构师必须意识到开发者是如何组织包的，如果几个包紧密的耦合在一起，那么重用其中一个包就变得非常困难。
鉴于模块化的重要性，研究人员提供了各种语言无关的标准来衡量，我们专注于三个关键概念：
 内聚（Cohesion） 耦合（Coupling） 共生性（Connascence）（注：参考《UML面向对象设计基础》的翻译）  2. 内聚（Cohesion） 内聚性是指子程序中各种操作之间联系的紧密程度，我们的目标是让每一个模块只做好一件事，不去做其他事情。
 试图分割一个内聚的模块只会导致耦合性增加和可读性降低。（Attempting to divide a cohesive module would only result in increased coupling and decreased readability.） —— Larry Constantine
 计算机科学家们已经定义了一系列的内聚的衡量标准，从最好到最坏列出如下：
 功能性内聚（Functional cohesion）：模块内所有元素都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分，具有最高的内聚； 顺序内聚（Sequential cohesion）：模块必须顺序执行； 通信内聚（Communicational cohesion）：两个不同操作的模块使用同样的数据。例如，在数据库中添加一条记录，并根据该信息生成一封邮件； 过程内聚（Procedural cohesion）：两个模块必须以特定的次序执行。 时间内聚（Temporal cohesion）：把需要同时执行的动作组合在一起形成的模块。 逻辑内聚（Logical cohesion）：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能。 巧合内聚（Coincidental cohesion）：模块内的各个元素之间没有任何联系，只是偶然地被凑到一起；内聚程度最低。  内聚不容易考量，特定的模块需要架构师来具体决定，例如，考虑一个模块定义了：
Customer：">
<meta name="author" content="多颗糖">
<link rel="canonical" href="https://tangwz.com/post/fosa3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://tangwz.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tangwz.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tangwz.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tangwz.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://tangwz.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.4" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-72128068-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content=" 软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？" />
<meta property="og:description" content="0. 写在前面 什么是好的代码？好的代码应该模块化。
王垠在其《编程的智慧》中也提到，要“写模块化的代码”。(不对人做评价，这篇文章写得是非常好的。)
如果你读过《代码大全》和《代码整洁之道》等书，一定对**“高内聚、低耦合”**不陌生。
好的模块化代码就是要高内聚、低耦合。
事实上，内聚和耦合是 1972 年就提出的概念，由于耦合不好具体的衡量，Meilir Page-Jones 在 1992 年提出了共生性（Connascence）。本章重点就是介绍如何评估模块化架构，以及引入共生性这一概念来帮助更好的模块化。
1. 模块化 不同的平台、语言为代码提供了不同的复用机制，将相关代码组合成模块。
理解模块对于架构师来说非常重要，因为用来分析架构的工具（可视化等）常常都依赖于模块化的概念。如果一个架构师在设计一个系统时，没有注意到各个部分是如何连接在一起的，那么他们最终创建的系统会带来无数的问题。
架构师必须保持良好的结构，这不会偶然发生。
模块的代码到底是什么？我们用模块化来描述相关代码中的逻辑分组，这些模块可以用来构造一个更复杂的结构。
现代的语言有各种各样的封装机制，例如，许多语言可以在函数/方法、类、包/命名空间中定义行为，每个包都有不同的可见性和范围规则。（这有时候也会让开发人员选择困难）
架构师必须意识到开发者是如何组织包的，如果几个包紧密的耦合在一起，那么重用其中一个包就变得非常困难。
鉴于模块化的重要性，研究人员提供了各种语言无关的标准来衡量，我们专注于三个关键概念：
 内聚（Cohesion） 耦合（Coupling） 共生性（Connascence）（注：参考《UML面向对象设计基础》的翻译）  2. 内聚（Cohesion） 内聚性是指子程序中各种操作之间联系的紧密程度，我们的目标是让每一个模块只做好一件事，不去做其他事情。
 试图分割一个内聚的模块只会导致耦合性增加和可读性降低。（Attempting to divide a cohesive module would only result in increased coupling and decreased readability.） —— Larry Constantine
 计算机科学家们已经定义了一系列的内聚的衡量标准，从最好到最坏列出如下：
 功能性内聚（Functional cohesion）：模块内所有元素都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分，具有最高的内聚； 顺序内聚（Sequential cohesion）：模块必须顺序执行； 通信内聚（Communicational cohesion）：两个不同操作的模块使用同样的数据。例如，在数据库中添加一条记录，并根据该信息生成一封邮件； 过程内聚（Procedural cohesion）：两个模块必须以特定的次序执行。 时间内聚（Temporal cohesion）：把需要同时执行的动作组合在一起形成的模块。 逻辑内聚（Logical cohesion）：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能。 巧合内聚（Coincidental cohesion）：模块内的各个元素之间没有任何联系，只是偶然地被凑到一起；内聚程度最低。  内聚不容易考量，特定的模块需要架构师来具体决定，例如，考虑一个模块定义了：
Customer：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tangwz.com/post/fosa3/" /><meta property="og:image" content="https://tangwz.com/"/><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-14T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-01-14T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://tangwz.com/"/>

<meta name="twitter:title" content=" 软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？"/>
<meta name="twitter:description" content="0. 写在前面 什么是好的代码？好的代码应该模块化。
王垠在其《编程的智慧》中也提到，要“写模块化的代码”。(不对人做评价，这篇文章写得是非常好的。)
如果你读过《代码大全》和《代码整洁之道》等书，一定对**“高内聚、低耦合”**不陌生。
好的模块化代码就是要高内聚、低耦合。
事实上，内聚和耦合是 1972 年就提出的概念，由于耦合不好具体的衡量，Meilir Page-Jones 在 1992 年提出了共生性（Connascence）。本章重点就是介绍如何评估模块化架构，以及引入共生性这一概念来帮助更好的模块化。
1. 模块化 不同的平台、语言为代码提供了不同的复用机制，将相关代码组合成模块。
理解模块对于架构师来说非常重要，因为用来分析架构的工具（可视化等）常常都依赖于模块化的概念。如果一个架构师在设计一个系统时，没有注意到各个部分是如何连接在一起的，那么他们最终创建的系统会带来无数的问题。
架构师必须保持良好的结构，这不会偶然发生。
模块的代码到底是什么？我们用模块化来描述相关代码中的逻辑分组，这些模块可以用来构造一个更复杂的结构。
现代的语言有各种各样的封装机制，例如，许多语言可以在函数/方法、类、包/命名空间中定义行为，每个包都有不同的可见性和范围规则。（这有时候也会让开发人员选择困难）
架构师必须意识到开发者是如何组织包的，如果几个包紧密的耦合在一起，那么重用其中一个包就变得非常困难。
鉴于模块化的重要性，研究人员提供了各种语言无关的标准来衡量，我们专注于三个关键概念：
 内聚（Cohesion） 耦合（Coupling） 共生性（Connascence）（注：参考《UML面向对象设计基础》的翻译）  2. 内聚（Cohesion） 内聚性是指子程序中各种操作之间联系的紧密程度，我们的目标是让每一个模块只做好一件事，不去做其他事情。
 试图分割一个内聚的模块只会导致耦合性增加和可读性降低。（Attempting to divide a cohesive module would only result in increased coupling and decreased readability.） —— Larry Constantine
 计算机科学家们已经定义了一系列的内聚的衡量标准，从最好到最坏列出如下：
 功能性内聚（Functional cohesion）：模块内所有元素都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分，具有最高的内聚； 顺序内聚（Sequential cohesion）：模块必须顺序执行； 通信内聚（Communicational cohesion）：两个不同操作的模块使用同样的数据。例如，在数据库中添加一条记录，并根据该信息生成一封邮件； 过程内聚（Procedural cohesion）：两个模块必须以特定的次序执行。 时间内聚（Temporal cohesion）：把需要同时执行的动作组合在一起形成的模块。 逻辑内聚（Logical cohesion）：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能。 巧合内聚（Coincidental cohesion）：模块内的各个元素之间没有任何联系，只是偶然地被凑到一起；内聚程度最低。  内聚不容易考量，特定的模块需要架构师来具体决定，例如，考虑一个模块定义了：
Customer："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tangwz.com/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": " 软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？",
      "item": "https://tangwz.com/post/fosa3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": " 软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？",
  "name": " 软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？",
  "description": "0. 写在前面 什么是好的代码？好的代码应该模块化。\n王垠在其《编程的智慧》中也提到，要“写模块化的代码”。(不对人做评价，这篇文章写得是非常好的。)\n如果你读过《代码大全》和《代码整洁之道》等书，一定对**“高内聚、低耦合”**不陌生。\n好的模块化代码就是要高内聚、低耦合。\n事实上，内聚和耦合是 1972 年就提出的概念，由于耦合不好具体的衡量，Meilir Page-Jones 在 1992 年提出了共生性（Connascence）。本章重点就是介绍如何评估模块化架构，以及引入共生性这一概念来帮助更好的模块化。\n1. 模块化 不同的平台、语言为代码提供了不同的复用机制，将相关代码组合成模块。\n理解模块对于架构师来说非常重要，因为用来分析架构的工具（可视化等）常常都依赖于模块化的概念。如果一个架构师在设计一个系统时，没有注意到各个部分是如何连接在一起的，那么他们最终创建的系统会带来无数的问题。\n架构师必须保持良好的结构，这不会偶然发生。\n模块的代码到底是什么？我们用模块化来描述相关代码中的逻辑分组，这些模块可以用来构造一个更复杂的结构。\n现代的语言有各种各样的封装机制，例如，许多语言可以在函数/方法、类、包/命名空间中定义行为，每个包都有不同的可见性和范围规则。（这有时候也会让开发人员选择困难）\n架构师必须意识到开发者是如何组织包的，如果几个包紧密的耦合在一起，那么重用其中一个包就变得非常困难。\n鉴于模块化的重要性，研究人员提供了各种语言无关的标准来衡量，我们专注于三个关键概念：\n 内聚（Cohesion） 耦合（Coupling） 共生性（Connascence）（注：参考《UML面向对象设计基础》的翻译）  2. 内聚（Cohesion） 内聚性是指子程序中各种操作之间联系的紧密程度，我们的目标是让每一个模块只做好一件事，不去做其他事情。\n 试图分割一个内聚的模块只会导致耦合性增加和可读性降低。（Attempting to divide a cohesive module would only result in increased coupling and decreased readability.） —— Larry Constantine\n 计算机科学家们已经定义了一系列的内聚的衡量标准，从最好到最坏列出如下：\n 功能性内聚（Functional cohesion）：模块内所有元素都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分，具有最高的内聚； 顺序内聚（Sequential cohesion）：模块必须顺序执行； 通信内聚（Communicational cohesion）：两个不同操作的模块使用同样的数据。例如，在数据库中添加一条记录，并根据该信息生成一封邮件； 过程内聚（Procedural cohesion）：两个模块必须以特定的次序执行。 时间内聚（Temporal cohesion）：把需要同时执行的动作组合在一起形成的模块。 逻辑内聚（Logical cohesion）：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能。 巧合内聚（Coincidental cohesion）：模块内的各个元素之间没有任何联系，只是偶然地被凑到一起；内聚程度最低。  内聚不容易考量，特定的模块需要架构师来具体决定，例如，考虑一个模块定义了：\nCustomer：",
  "keywords": [
    "架构"
  ],
  "articleBody": "0. 写在前面 什么是好的代码？好的代码应该模块化。\n王垠在其《编程的智慧》中也提到，要“写模块化的代码”。(不对人做评价，这篇文章写得是非常好的。)\n如果你读过《代码大全》和《代码整洁之道》等书，一定对**“高内聚、低耦合”**不陌生。\n好的模块化代码就是要高内聚、低耦合。\n事实上，内聚和耦合是 1972 年就提出的概念，由于耦合不好具体的衡量，Meilir Page-Jones 在 1992 年提出了共生性（Connascence）。本章重点就是介绍如何评估模块化架构，以及引入共生性这一概念来帮助更好的模块化。\n1. 模块化 不同的平台、语言为代码提供了不同的复用机制，将相关代码组合成模块。\n理解模块对于架构师来说非常重要，因为用来分析架构的工具（可视化等）常常都依赖于模块化的概念。如果一个架构师在设计一个系统时，没有注意到各个部分是如何连接在一起的，那么他们最终创建的系统会带来无数的问题。\n架构师必须保持良好的结构，这不会偶然发生。\n模块的代码到底是什么？我们用模块化来描述相关代码中的逻辑分组，这些模块可以用来构造一个更复杂的结构。\n现代的语言有各种各样的封装机制，例如，许多语言可以在函数/方法、类、包/命名空间中定义行为，每个包都有不同的可见性和范围规则。（这有时候也会让开发人员选择困难）\n架构师必须意识到开发者是如何组织包的，如果几个包紧密的耦合在一起，那么重用其中一个包就变得非常困难。\n鉴于模块化的重要性，研究人员提供了各种语言无关的标准来衡量，我们专注于三个关键概念：\n 内聚（Cohesion） 耦合（Coupling） 共生性（Connascence）（注：参考《UML面向对象设计基础》的翻译）  2. 内聚（Cohesion） 内聚性是指子程序中各种操作之间联系的紧密程度，我们的目标是让每一个模块只做好一件事，不去做其他事情。\n 试图分割一个内聚的模块只会导致耦合性增加和可读性降低。（Attempting to divide a cohesive module would only result in increased coupling and decreased readability.） —— Larry Constantine\n 计算机科学家们已经定义了一系列的内聚的衡量标准，从最好到最坏列出如下：\n 功能性内聚（Functional cohesion）：模块内所有元素都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分，具有最高的内聚； 顺序内聚（Sequential cohesion）：模块必须顺序执行； 通信内聚（Communicational cohesion）：两个不同操作的模块使用同样的数据。例如，在数据库中添加一条记录，并根据该信息生成一封邮件； 过程内聚（Procedural cohesion）：两个模块必须以特定的次序执行。 时间内聚（Temporal cohesion）：把需要同时执行的动作组合在一起形成的模块。 逻辑内聚（Logical cohesion）：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能。 巧合内聚（Coincidental cohesion）：模块内的各个元素之间没有任何联系，只是偶然地被凑到一起；内聚程度最低。  内聚不容易考量，特定的模块需要架构师来具体决定，例如，考虑一个模块定义了：\nCustomer：\n add customer update customer get customer notify customer get customer orders cancel customer orders  或者说将后两个函数剥离出来，分成两个模块：\nCustomer：\n add customer update customer get customer notify customer  Order：\n get customer orders cancel customer orders  哪个更好？一如既往，这要看情况：\n 订单只有这两个操作吗？如果是这样，将这些操作放在客户包中维护可能是有意义的； 客户包按预期是否会变得更大？ 订单是否需要如此多的客户信息？  这些问题代表了软件架构师工作核心的权衡分析。\n由于内聚非常主观，计算机科学家制定了一个标准来衡量内聚性，其中 LCOM(Lack of Cohesion in Methods) 为著名。这里涉及到的数学公式平时很少用到，在此不再展开，只需要知道有这么一个公式，在需要的时候可以再查询拿出来用。想进一步了解的读者可以查看：https://en.wikipedia.org/wiki/Programming_complexity\n3. 耦合（Coupling） 我们常常谈到要“解耦”，弱耦合是系统可维护的关键。\n耦合其实也有多种类型，但在此不再介绍，因为它们已经被共生性（Connascence）所取代。\n4. 共生性（Connascence） 1996 年 Meilir Page-Jones 发表了 《What Every Programmer Should Know About Object-Oriented Design》，完善了耦合的度量，并命名为：Connascence。\n他是这样定义的：\n 如果一个组件的改变会要求另一个组件进行修改，才能保持系统的整体正确性，那么这两个组件就是共生的。 —— Meilir Page-Jones\n 共生性分为静态的和动态的。我们将分别介绍各种类型的共生性，对于部分重要的、不易理解的，我将补充一些代码案例，作为具体的参考来帮助理解。\n静态共生性：\n4.1 名称共生性（Connascence of Name, CoN） methodA() 改名为 methodB() 时,　调用 methodA() 的地方都要改名，这是代码库中最常见的耦合方式，现代的 IDE 的检索功能使修改代码的名称变得很容易，这是最理想的耦合方式；\n4.2 类型共生性（Connascence of Type, CoT) 如果一个变量从值 100 变成了一个很大的数，变量的类型可能要从 int 改成 BigInteger\n4.3 意义共生性（Connascence of Meaning, CoM） 例如，在很多语言中，通常会把大于 0 的数字认为是 True，0 认为是 False。下面是 Java 中的一个具体例子：\na.compareTo(b) // 如果 a = b，则返回值 0； // 如果 a  b，则返回大于 0 的值； // 如果 a 4.4 位置共生性（Connascence of Position, CoP） 函数的参数的位置顺序或个数耦合，例如下面的函数增加一个参数后，函数调用将会出错。\n针对这个例子，我们可以通过下面的办法，将位置共生性转为名称共生性来降低耦合性：\nclass User { FirstName, LastName, Address } void SaveUser(User); myrepo.SaveUser(new User{ FirstName = \"bob\", LastName = \"Marley\", Address = \"Jamaica\"}); 4.5 算法共生性（Connascence of Algorithm, CoA） 多个组件必须就一个特定的算法达成一致。例如：客户端和服务端用相同的算法验证用户身份。这代表一种较高的耦合形式——如果算法细节改变，验证将不再有效。\n 动态共生性：\n4.6 执行共生性（Connascence of Execution, CoE） 代码的执行顺序上的耦合。例如下面的代码，在设置主题之前就发送了，明显在顺序上有问题。\nemail = new Email(); email.setRecipient(\"foo@example.com\"); email.setSender(\"me@me.com\"); email.send(); email.setSubject(\"whoops\"); 4.7 时间共生性（Connascence of Timing, CoT） 常见情况是两个线程同时执行造成的竞赛条件。\n这里我们可以看一个有趣的例子，发生在 bootstrap 的一个 issue：https://github.com/twbs/bootstrap/issues/3902\n// using bootstrap modal $(element).modal('hide') $(element).modal('show') // Error!  // 隐藏一个 modal 大约需要 500ms 的动画， // 如果你在这时候直接调用了 'show'，将会发生异常  // 我们必须这样做 $(element).modal('hide') $(element).on('hidden.bs.modal', ()={ $(element).modal('show') // ok }) 4.8 值共生性（Connascence of Values, CoV） 常见的情况在分布式事务中，例如需要在多个独立的数据库中做分布式事务。\n4.9 身份共生性（Connascence of Identity, CoI） 两个独立的模块需要共享和更新同一个数据结构，例如：分布式队列。\n5. 共生性的属性 5.1 强度（Strength） Page-Jones 指出，共生性有明确的强弱谱系，如下图所示，按强度递增排序。identity 具有最强的共生性，name 具有最弱的共生性。——也就是说用 name 的方式耦合则为最弱的耦合方式。\n架构师应该倾向于静态共生性而不是动态共生性，因为开发人员可以通过现代的 IDE 来很快地确定它。\n5.2 局部性（Locality） 局部性指两个模块的之间的远近程度。\n通常情况下，在同一模块中、距离较近的类比在不同模块中、距离距离较远的类具有更高的共生性。换句话说，随着两个模块在代码中的距离增加，共生性会减弱。\n5.3 程度（Degree） 共生性的程度与模块的影响大小有关——它影响了几个类还是几十个类？影响较小的共生性对代码库的损坏就较小。\n6. 如何通过共生性来提高系统模块化 讲了这么多，我们到底如何实践共生性呢？\nPage-Jones 提供了三个使用共生性来提高系统模块化的指南： 1.通过将系统拆分成封装的元素，使得整体的共生性达到最弱 2.最大限度地减少任何跨越封装边界的共生性 3.最大限度地提高封装边界的共生性\nJim Weirich （传奇的软件架构创新者，Ruby 社区活跃人士）简化了上面较为抽象的指导，提供了两个更具体的建议：\n 程度法则（Rule of Degree）：将强共生性转化为弱共生性。 局部性规则（Rule of Locality）：随着软件元素之间距离的增加，应使用较弱的共生性。  7. 耦合性和共生性 从架构师的角度来看，耦合和共生是有所重叠的，这是不同时代的产物，下图列出两者重叠的部分：\n共生性提供了更精细化的考量，例如左边的数据耦合，在右边的静态共生性提供了更具体的建议。\n8. 局限性 尽管如此，架构师在应用这些指标来分析和设计系统时，存在几个问题：\n 这些度量从代码层面考察细节，关注代码质量，而不一定是架构。架构师更关注模块如何耦合，而不是耦合程度，例如，架构师关心的是同步或异步通信，而不关心如何实现。 共生性并没有真正解决许多现代架构师必须做出的一个基本决定–在分布式架构（例如：微服务）中，使用同步还是异步通信？在后面会介绍新的方法来思考现代的共生性。  虽然对模块化进行了大量的介绍和思考，开发人员和架构师在实际实施过程中，还是会遇到很多的困难。\n纸上得来终觉浅，绝知此事要躬行。\n设计良好的架构，并非易事！\n",
  "wordCount" : "338",
  "inLanguage": "en",
  "datePublished": "2021-01-14T00:00:00Z",
  "dateModified": "2021-01-14T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "多颗糖"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tangwz.com/post/fosa3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "多颗糖",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tangwz.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tangwz.com/" accesskey="h" title="多颗糖 (Alt + H)">多颗糖</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tangwz.com/page/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://tangwz.com/page/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tangwz.com/">Home</a>&nbsp;»&nbsp;<a href="https://tangwz.com/post/">Posts</a></div>
    <h1 class="post-title">
       软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？
    </h1>
    <div class="post-meta"><span title='2021-01-14 00:00:00 +0000 UTC'>January 14, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;多颗糖&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/post/fosa3.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#0--%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2" aria-label="0.  写在前面">0.  写在前面</a></li>
                <li>
                    <a href="#1-%e6%a8%a1%e5%9d%97%e5%8c%96" aria-label="1. 模块化">1. 模块化</a></li>
                <li>
                    <a href="#2-%e5%86%85%e8%81%9acohesion" aria-label="2. 内聚（Cohesion）">2. 内聚（Cohesion）</a></li>
                <li>
                    <a href="#3-%e8%80%a6%e5%90%88coupling" aria-label="3. 耦合（Coupling）">3. 耦合（Coupling）</a></li>
                <li>
                    <a href="#4-%e5%85%b1%e7%94%9f%e6%80%a7connascence" aria-label="4. 共生性（Connascence）">4. 共生性（Connascence）</a><ul>
                        
                <li>
                    <a href="#41-%e5%90%8d%e7%a7%b0%e5%85%b1%e7%94%9f%e6%80%a7connascence-of-name-con" aria-label="4.1 名称共生性（Connascence of Name, CoN）">4.1 名称共生性（Connascence of Name, CoN）</a></li>
                <li>
                    <a href="#42-%e7%b1%bb%e5%9e%8b%e5%85%b1%e7%94%9f%e6%80%a7connascence-of-type-cot" aria-label="4.2 类型共生性（Connascence of Type, CoT)">4.2 类型共生性（Connascence of Type, CoT)</a></li>
                <li>
                    <a href="#43-%e6%84%8f%e4%b9%89%e5%85%b1%e7%94%9f%e6%80%a7connascence-of-meaning-com" aria-label="4.3 意义共生性（Connascence of Meaning, CoM）">4.3 意义共生性（Connascence of Meaning, CoM）</a></li>
                <li>
                    <a href="#44-%e4%bd%8d%e7%bd%ae%e5%85%b1%e7%94%9f%e6%80%a7connascence-of-position-cop" aria-label="4.4 位置共生性（Connascence of Position, CoP）">4.4 位置共生性（Connascence of Position, CoP）</a></li>
                <li>
                    <a href="#45-%e7%ae%97%e6%b3%95%e5%85%b1%e7%94%9f%e6%80%a7connascence-of-algorithm-coa" aria-label="4.5 算法共生性（Connascence of Algorithm, CoA）">4.5 算法共生性（Connascence of Algorithm, CoA）</a></li>
                <li>
                    <a href="#46-%e6%89%a7%e8%a1%8c%e5%85%b1%e7%94%9f%e6%80%a7connascence-of-execution-coe" aria-label="4.6 执行共生性（Connascence of Execution, CoE）">4.6 执行共生性（Connascence of Execution, CoE）</a></li>
                <li>
                    <a href="#47-%e6%97%b6%e9%97%b4%e5%85%b1%e7%94%9f%e6%80%a7connascence-of-timing-cot" aria-label="4.7 时间共生性（Connascence of Timing, CoT）">4.7 时间共生性（Connascence of Timing, CoT）</a></li>
                <li>
                    <a href="#48-%e5%80%bc%e5%85%b1%e7%94%9f%e6%80%a7connascence-of-values-cov" aria-label="4.8 值共生性（Connascence of Values, CoV）">4.8 值共生性（Connascence of Values, CoV）</a></li>
                <li>
                    <a href="#49-%e8%ba%ab%e4%bb%bd%e5%85%b1%e7%94%9f%e6%80%a7connascence-of-identity-coi" aria-label="4.9 身份共生性（Connascence of Identity, CoI）">4.9 身份共生性（Connascence of Identity, CoI）</a></li></ul>
                </li>
                <li>
                    <a href="#5-%e5%85%b1%e7%94%9f%e6%80%a7%e7%9a%84%e5%b1%9e%e6%80%a7" aria-label="5. 共生性的属性">5. 共生性的属性</a><ul>
                        
                <li>
                    <a href="#51-%e5%bc%ba%e5%ba%a6strength" aria-label="5.1 强度（Strength）">5.1 强度（Strength）</a></li>
                <li>
                    <a href="#52-%e5%b1%80%e9%83%a8%e6%80%a7locality" aria-label="5.2 局部性（Locality）">5.2 局部性（Locality）</a></li>
                <li>
                    <a href="#53-%e7%a8%8b%e5%ba%a6degree" aria-label="5.3 程度（Degree）">5.3 程度（Degree）</a></li></ul>
                </li>
                <li>
                    <a href="#6-%e5%a6%82%e4%bd%95%e9%80%9a%e8%bf%87%e5%85%b1%e7%94%9f%e6%80%a7%e6%9d%a5%e6%8f%90%e9%ab%98%e7%b3%bb%e7%bb%9f%e6%a8%a1%e5%9d%97%e5%8c%96" aria-label="6. 如何通过共生性来提高系统模块化">6. 如何通过共生性来提高系统模块化</a></li>
                <li>
                    <a href="#7-%e8%80%a6%e5%90%88%e6%80%a7%e5%92%8c%e5%85%b1%e7%94%9f%e6%80%a7" aria-label="7. 耦合性和共生性">7. 耦合性和共生性</a></li>
                <li>
                    <a href="#8-%e5%b1%80%e9%99%90%e6%80%a7" aria-label="8. 局限性">8. 局限性</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="0--写在前面">0.  写在前面<a hidden class="anchor" aria-hidden="true" href="#0--写在前面">#</a></h2>
<p>什么是好的代码？好的代码应该模块化。</p>
<p>王垠在其<a href="https://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy">《编程的智慧》</a>中也提到，要“写模块化的代码”。(不对人做评价，这篇文章写得是非常好的。)</p>
<p>如果你读过《代码大全》和《代码整洁之道》等书，一定对**“高内聚、低耦合”**不陌生。</p>
<p><strong>好的模块化代码就是要高内聚、低耦合。</strong></p>
<p>事实上，内聚和耦合是 1972 年就提出的概念，由于耦合不好具体的衡量，Meilir Page-Jones 在 1992 年提出了共生性（Connascence）。本章重点就是介绍如何评估模块化架构，以及引入共生性这一概念来帮助更好的模块化。</p>
<h2 id="1-模块化">1. 模块化<a hidden class="anchor" aria-hidden="true" href="#1-模块化">#</a></h2>
<p>不同的平台、语言为代码提供了不同的复用机制，将相关代码组合成模块。</p>
<p>理解模块对于架构师来说非常重要，因为用来分析架构的工具（可视化等）常常都依赖于模块化的概念。如果一个架构师在设计一个系统时，没有注意到各个部分是如何连接在一起的，那么他们最终创建的系统会带来无数的问题。</p>
<p>架构师必须保持良好的结构，这不会偶然发生。</p>
<p>模块的代码到底是什么？我们用模块化来描述相关代码中的逻辑分组，这些模块可以用来构造一个更复杂的结构。</p>
<p>现代的语言有各种各样的封装机制，例如，许多语言可以在函数/方法、类、包/命名空间中定义行为，每个包都有不同的可见性和范围规则。（这有时候也会让开发人员选择困难）</p>
<p>架构师必须意识到开发者是如何组织包的，如果几个包紧密的耦合在一起，那么重用其中一个包就变得非常困难。</p>
<p>鉴于模块化的重要性，研究人员提供了各种语言无关的标准来衡量，我们专注于三个关键概念：</p>
<ul>
<li>内聚（Cohesion）</li>
<li>耦合（Coupling）</li>
<li>共生性（Connascence）（注：参考<a href="https://book.douban.com/subject/10737799/">《UML面向对象设计基础》</a>的翻译）</li>
</ul>
<h2 id="2-内聚cohesion">2. 内聚（Cohesion）<a hidden class="anchor" aria-hidden="true" href="#2-内聚cohesion">#</a></h2>
<p>内聚性是指子程序中各种操作之间联系的紧密程度，我们的目标是让每一个模块只做好一件事，不去做其他事情。</p>
<blockquote>
<p>试图分割一个内聚的模块只会导致耦合性增加和可读性降低。（Attempting to divide a cohesive module would only result in increased coupling and decreased readability.） —— Larry Constantine</p>
</blockquote>
<p><img loading="lazy" src="/media/images/20210114-fosa3/cohesion1.jpg" alt=""  />
</p>
<p>计算机科学家们已经定义了一系列的内聚的衡量标准，从最好到最坏列出如下：</p>
<ul>
<li>功能性内聚（Functional cohesion）：模块内所有元素都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分，具有最高的内聚；</li>
<li>顺序内聚（Sequential cohesion）：模块必须顺序执行；</li>
<li>通信内聚（Communicational cohesion）：两个不同操作的模块使用同样的数据。例如，在数据库中添加一条记录，并根据该信息生成一封邮件；</li>
<li>过程内聚（Procedural cohesion）：两个模块必须以特定的次序执行。</li>
<li>时间内聚（Temporal cohesion）：把需要同时执行的动作组合在一起形成的模块。</li>
<li>逻辑内聚（Logical cohesion）：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能。</li>
<li>巧合内聚（Coincidental cohesion）：模块内的各个元素之间没有任何联系，只是偶然地被凑到一起；内聚程度最低。</li>
</ul>
<p><img loading="lazy" src="/media/images/20210114-fosa3/cohesion2.jpg" alt=""  />
</p>
<p>内聚不容易考量，特定的模块需要架构师来具体决定，例如，考虑一个模块定义了：</p>
<p>Customer：</p>
<ul>
<li>add customer</li>
<li>update customer</li>
<li>get customer</li>
<li>notify customer</li>
<li>get customer orders</li>
<li>cancel customer orders</li>
</ul>
<p>或者说将后两个函数剥离出来，分成两个模块：</p>
<p>Customer：</p>
<ul>
<li>add customer</li>
<li>update customer</li>
<li>get customer</li>
<li>notify customer</li>
</ul>
<p>Order：</p>
<ul>
<li>get customer orders</li>
<li>cancel customer orders</li>
</ul>
<p>哪个更好？一如既往，这要看情况：</p>
<ul>
<li>订单只有这两个操作吗？如果是这样，将这些操作放在客户包中维护可能是有意义的；</li>
<li>客户包按预期是否会变得更大？</li>
<li>订单是否需要如此多的客户信息？</li>
</ul>
<p>这些问题代表了软件架构师工作核心的权衡分析。</p>
<p>由于内聚非常主观，计算机科学家制定了一个标准来衡量内聚性，其中 <strong>LCOM(Lack of Cohesion in Methods)</strong> 为著名。这里涉及到的数学公式平时很少用到，在此不再展开，只需要知道有这么一个公式，在需要的时候可以再查询拿出来用。想进一步了解的读者可以查看：<a href="https://en.wikipedia.org/wiki/Programming_complexity">https://en.wikipedia.org/wiki/Programming_complexity</a></p>
<h2 id="3-耦合coupling">3. 耦合（Coupling）<a hidden class="anchor" aria-hidden="true" href="#3-耦合coupling">#</a></h2>
<p>我们常常谈到要“解耦”，弱耦合是系统可维护的关键。</p>
<p>耦合其实也有多种类型，但在此不再介绍，因为它们已经被共生性（Connascence）所取代。</p>
<h2 id="4-共生性connascence">4. 共生性（Connascence）<a hidden class="anchor" aria-hidden="true" href="#4-共生性connascence">#</a></h2>
<p>1996 年 Meilir Page-Jones 发表了
<a href="https://dl.acm.org/doi/book/10.5555/231061">《What Every Programmer Should Know About Object-Oriented Design》</a>，完善了耦合的度量，并命名为：Connascence。</p>
<p>他是这样定义的：</p>
<blockquote>
<p>如果一个组件的改变会要求另一个组件进行修改，才能保持系统的整体正确性，那么这两个组件就是共生的。 —— Meilir Page-Jones</p>
</blockquote>
<p>共生性分为静态的和动态的。我们将分别介绍各种类型的共生性，对于部分重要的、不易理解的，我将补充一些代码案例，作为具体的参考来帮助理解。</p>
<p><strong>静态共生性：</strong></p>
<h3 id="41-名称共生性connascence-of-name-con">4.1 名称共生性（Connascence of Name, CoN）<a hidden class="anchor" aria-hidden="true" href="#41-名称共生性connascence-of-name-con">#</a></h3>
<p><code>methodA()</code> 改名为 <code>methodB()</code> 时,　调用 <code>methodA()</code> 的地方都要改名，这是代码库中最常见的耦合方式，现代的 IDE 的检索功能使修改代码的名称变得很容易，这是最理想的耦合方式；</p>
<p><img loading="lazy" src="/media/images/20210114-fosa3/con.jpg" alt=""  />
</p>
<h3 id="42-类型共生性connascence-of-type-cot">4.2 类型共生性（Connascence of Type, CoT)<a hidden class="anchor" aria-hidden="true" href="#42-类型共生性connascence-of-type-cot">#</a></h3>
<p>如果一个变量从值 100 变成了一个很大的数，变量的类型可能要从 int 改成 BigInteger</p>
<h3 id="43-意义共生性connascence-of-meaning-com">4.3 意义共生性（Connascence of Meaning, CoM）<a hidden class="anchor" aria-hidden="true" href="#43-意义共生性connascence-of-meaning-com">#</a></h3>
<p>例如，在很多语言中，通常会把大于 0 的数字认为是 True，0 认为是 False。下面是 Java 中的一个具体例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">a<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>b<span style="color:#f92672">)</span>
<span style="color:#75715e">// 如果 a = b，则返回值 0；
</span><span style="color:#75715e">// 如果 a &gt; b，则返回大于 0 的值；
</span><span style="color:#75715e">// 如果 a &lt; b，则返回小于 0 的值。
</span></code></pre></div><h3 id="44-位置共生性connascence-of-position-cop">4.4 位置共生性（Connascence of Position, CoP）<a hidden class="anchor" aria-hidden="true" href="#44-位置共生性connascence-of-position-cop">#</a></h3>
<p>函数的参数的位置顺序或个数耦合，例如下面的函数增加一个参数后，函数调用将会出错。</p>
<p><img loading="lazy" src="/media/images/20210114-fosa3/cop.jpg" alt=""  />
</p>
<p><img loading="lazy" src="/media/images/20210114-fosa3/cop2.jpg" alt=""  />
</p>
<p>针对这个例子，我们可以通过下面的办法，将位置共生性转为名称共生性来降低耦合性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">User</span> { <span style="color:#a6e22e">FirstName</span>, <span style="color:#a6e22e">LastName</span>, <span style="color:#a6e22e">Address</span> }
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SaveUser</span>(<span style="color:#a6e22e">User</span>);

<span style="color:#a6e22e">myrepo</span>.<span style="color:#a6e22e">SaveUser</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">User</span>{
        <span style="color:#a6e22e">FirstName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bob&#34;</span>,
        <span style="color:#a6e22e">LastName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Marley&#34;</span>,
        <span style="color:#a6e22e">Address</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Jamaica&#34;</span>});
</code></pre></div><h3 id="45-算法共生性connascence-of-algorithm-coa">4.5 算法共生性（Connascence of Algorithm, CoA）<a hidden class="anchor" aria-hidden="true" href="#45-算法共生性connascence-of-algorithm-coa">#</a></h3>
<p>多个组件必须就一个特定的算法达成一致。例如：客户端和服务端用相同的算法验证用户身份。这代表一种较高的耦合形式——如果算法细节改变，验证将不再有效。</p>
<hr>
<p><strong>动态共生性：</strong></p>
<h3 id="46-执行共生性connascence-of-execution-coe">4.6 执行共生性（Connascence of Execution, CoE）<a hidden class="anchor" aria-hidden="true" href="#46-执行共生性connascence-of-execution-coe">#</a></h3>
<p>代码的执行顺序上的耦合。例如下面的代码，在设置主题之前就发送了，明显在顺序上有问题。</p>
<pre tabindex="0"><code>email = new Email();
email.setRecipient(&quot;foo@example.com&quot;);
email.setSender(&quot;me@me.com&quot;);
email.send();
email.setSubject(&quot;whoops&quot;);
</code></pre><h3 id="47-时间共生性connascence-of-timing-cot">4.7 时间共生性（Connascence of Timing, CoT）<a hidden class="anchor" aria-hidden="true" href="#47-时间共生性connascence-of-timing-cot">#</a></h3>
<p>常见情况是两个线程同时执行造成的竞赛条件。</p>
<p>这里我们可以看一个有趣的例子，发生在 bootstrap 的一个 issue：<a href="https://github.com/twbs/bootstrap/issues/3902">https://github.com/twbs/bootstrap/issues/3902</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// using bootstrap modal
</span><span style="color:#75715e"></span><span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">element</span>).<span style="color:#a6e22e">modal</span>(<span style="color:#e6db74">&#39;hide&#39;</span>)
<span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">element</span>).<span style="color:#a6e22e">modal</span>(<span style="color:#e6db74">&#39;show&#39;</span>) <span style="color:#75715e">// Error!
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 隐藏一个 modal 大约需要 500ms 的动画，
</span><span style="color:#75715e">// 如果你在这时候直接调用了 &#39;show&#39;，将会发生异常
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 我们必须这样做
</span><span style="color:#75715e"></span><span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">element</span>).<span style="color:#a6e22e">modal</span>(<span style="color:#e6db74">&#39;hide&#39;</span>)
<span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">element</span>).<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;hidden.bs.modal&#39;</span>, ()=&gt;{
    <span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">element</span>).<span style="color:#a6e22e">modal</span>(<span style="color:#e6db74">&#39;show&#39;</span>) <span style="color:#75715e">// ok
</span><span style="color:#75715e"></span>})
</code></pre></div><h3 id="48-值共生性connascence-of-values-cov">4.8 值共生性（Connascence of Values, CoV）<a hidden class="anchor" aria-hidden="true" href="#48-值共生性connascence-of-values-cov">#</a></h3>
<p>常见的情况在分布式事务中，例如需要在多个独立的数据库中做分布式事务。</p>
<h3 id="49-身份共生性connascence-of-identity-coi">4.9 身份共生性（Connascence of Identity, CoI）<a hidden class="anchor" aria-hidden="true" href="#49-身份共生性connascence-of-identity-coi">#</a></h3>
<p>两个独立的模块需要共享和更新同一个数据结构，例如：分布式队列。</p>
<h2 id="5-共生性的属性">5. 共生性的属性<a hidden class="anchor" aria-hidden="true" href="#5-共生性的属性">#</a></h2>
<h3 id="51-强度strength">5.1 强度（Strength）<a hidden class="anchor" aria-hidden="true" href="#51-强度strength">#</a></h3>
<p>Page-Jones 指出，共生性有明确的强弱谱系，如下图所示，按强度递增排序。identity 具有最强的共生性，name 具有最弱的共生性。——也就是说用 name 的方式耦合则为最弱的耦合方式。</p>
<p><img loading="lazy" src="/media/images/20210114-fosa3/strength.jpg" alt=""  />
</p>
<p><strong>架构师应该倾向于静态共生性而不是动态共生性</strong>，因为开发人员可以通过现代的 IDE 来很快地确定它。</p>
<h3 id="52-局部性locality">5.2 局部性（Locality）<a hidden class="anchor" aria-hidden="true" href="#52-局部性locality">#</a></h3>
<p>局部性指两个模块的之间的远近程度。</p>
<p>通常情况下，在同一模块中、距离较近的类比在不同模块中、距离距离较远的类具有更高的共生性。换句话说，随着两个模块在代码中的距离增加，共生性会减弱。</p>
<h3 id="53-程度degree">5.3 程度（Degree）<a hidden class="anchor" aria-hidden="true" href="#53-程度degree">#</a></h3>
<p>共生性的程度与模块的影响大小有关——它影响了几个类还是几十个类？影响较小的共生性对代码库的损坏就较小。</p>
<h2 id="6-如何通过共生性来提高系统模块化">6. 如何通过共生性来提高系统模块化<a hidden class="anchor" aria-hidden="true" href="#6-如何通过共生性来提高系统模块化">#</a></h2>
<p>讲了这么多，我们到底如何实践共生性呢？</p>
<p>Page-Jones 提供了三个使用共生性来提高系统模块化的指南：
1.通过将系统拆分成封装的元素，使得整体的共生性达到最弱
2.最大限度地减少任何跨越封装边界的共生性
3.最大限度地提高封装边界的共生性</p>
<p>Jim Weirich （传奇的软件架构创新者，Ruby 社区活跃人士）简化了上面较为抽象的指导，提供了两个更具体的建议：</p>
<ul>
<li><strong>程度法则（Rule of Degree）：将强共生性转化为弱共生性。</strong></li>
<li><strong>局部性规则（Rule of Locality）：随着软件元素之间距离的增加，应使用较弱的共生性。</strong></li>
</ul>
<h2 id="7-耦合性和共生性">7. 耦合性和共生性<a hidden class="anchor" aria-hidden="true" href="#7-耦合性和共生性">#</a></h2>
<p>从架构师的角度来看，耦合和共生是有所重叠的，这是不同时代的产物，下图列出两者重叠的部分：</p>
<p><img loading="lazy" src="/media/images/20210114-fosa3/coupling_and_connascence.jpg" alt=""  />
</p>
<p>共生性提供了更精细化的考量，例如左边的数据耦合，在右边的静态共生性提供了更具体的建议。</p>
<h2 id="8-局限性">8. 局限性<a hidden class="anchor" aria-hidden="true" href="#8-局限性">#</a></h2>
<p>尽管如此，架构师在应用这些指标来分析和设计系统时，存在几个问题：</p>
<ul>
<li>这些度量从代码层面考察细节，关注代码质量，而不一定是架构。架构师更关注模块如何耦合，而不是耦合程度，例如，架构师关心的是同步或异步通信，而不关心如何实现。</li>
<li>共生性并没有真正解决许多现代架构师必须做出的一个基本决定&ndash;在分布式架构（例如：微服务）中，使用同步还是异步通信？在后面会介绍新的方法来思考现代的共生性。</li>
</ul>
<p>虽然对模块化进行了大量的介绍和思考，<strong>开发人员和架构师在实际实施过程中，还是会遇到很多的困难。</strong></p>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
<p>设计良好的架构，并非易事！</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tangwz.com/tags/%E6%9E%B6%E6%9E%84/">架构</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://tangwz.com/post/fosa4/">
    <span class="title">« Prev Page</span>
    <br>
    <span>软件架构基础 4: 你的架构需要考虑的架构特性</span>
  </a>
  <a class="next" href="https://tangwz.com/post/fosa2/">
    <span class="title">Next Page »</span>
    <br>
    <span> 软件架构基础 2：架构思维</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share  软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？ on twitter"
        href="https://twitter.com/intent/tweet/?text=%20%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e5%9f%ba%e7%a1%80%203%3a%20%e4%bb%80%e4%b9%88%e6%98%af%e5%a5%bd%e7%9a%84%e6%a8%a1%e5%9d%97%e5%8c%96%e4%bb%a3%e7%a0%81%ef%bc%9f%e9%ab%98%e5%86%85%e8%81%9a%e3%80%81%e4%bd%8e%e8%80%a6%e5%90%88%e5%a6%82%e4%bd%95%e8%a1%a1%e9%87%8f%ef%bc%9f&amp;url=https%3a%2f%2ftangwz.com%2fpost%2ffosa3%2f&amp;hashtags=%e6%9e%b6%e6%9e%84">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？ on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftangwz.com%2fpost%2ffosa3%2f&amp;title=%20%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e5%9f%ba%e7%a1%80%203%3a%20%e4%bb%80%e4%b9%88%e6%98%af%e5%a5%bd%e7%9a%84%e6%a8%a1%e5%9d%97%e5%8c%96%e4%bb%a3%e7%a0%81%ef%bc%9f%e9%ab%98%e5%86%85%e8%81%9a%e3%80%81%e4%bd%8e%e8%80%a6%e5%90%88%e5%a6%82%e4%bd%95%e8%a1%a1%e9%87%8f%ef%bc%9f&amp;summary=%20%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e5%9f%ba%e7%a1%80%203%3a%20%e4%bb%80%e4%b9%88%e6%98%af%e5%a5%bd%e7%9a%84%e6%a8%a1%e5%9d%97%e5%8c%96%e4%bb%a3%e7%a0%81%ef%bc%9f%e9%ab%98%e5%86%85%e8%81%9a%e3%80%81%e4%bd%8e%e8%80%a6%e5%90%88%e5%a6%82%e4%bd%95%e8%a1%a1%e9%87%8f%ef%bc%9f&amp;source=https%3a%2f%2ftangwz.com%2fpost%2ffosa3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？ on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ftangwz.com%2fpost%2ffosa3%2f&title=%20%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e5%9f%ba%e7%a1%80%203%3a%20%e4%bb%80%e4%b9%88%e6%98%af%e5%a5%bd%e7%9a%84%e6%a8%a1%e5%9d%97%e5%8c%96%e4%bb%a3%e7%a0%81%ef%bc%9f%e9%ab%98%e5%86%85%e8%81%9a%e3%80%81%e4%bd%8e%e8%80%a6%e5%90%88%e5%a6%82%e4%bd%95%e8%a1%a1%e9%87%8f%ef%bc%9f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？ on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftangwz.com%2fpost%2ffosa3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？ on whatsapp"
        href="https://api.whatsapp.com/send?text=%20%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e5%9f%ba%e7%a1%80%203%3a%20%e4%bb%80%e4%b9%88%e6%98%af%e5%a5%bd%e7%9a%84%e6%a8%a1%e5%9d%97%e5%8c%96%e4%bb%a3%e7%a0%81%ef%bc%9f%e9%ab%98%e5%86%85%e8%81%9a%e3%80%81%e4%bd%8e%e8%80%a6%e5%90%88%e5%a6%82%e4%bd%95%e8%a1%a1%e9%87%8f%ef%bc%9f%20-%20https%3a%2f%2ftangwz.com%2fpost%2ffosa3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  软件架构基础 3: 什么是好的模块化代码？高内聚、低耦合如何衡量？ on telegram"
        href="https://telegram.me/share/url?text=%20%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e5%9f%ba%e7%a1%80%203%3a%20%e4%bb%80%e4%b9%88%e6%98%af%e5%a5%bd%e7%9a%84%e6%a8%a1%e5%9d%97%e5%8c%96%e4%bb%a3%e7%a0%81%ef%bc%9f%e9%ab%98%e5%86%85%e8%81%9a%e3%80%81%e4%bd%8e%e8%80%a6%e5%90%88%e5%a6%82%e4%bd%95%e8%a1%a1%e9%87%8f%ef%bc%9f&amp;url=https%3a%2f%2ftangwz.com%2fpost%2ffosa3%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://tangwz.com/">多颗糖</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
